#! @PYTHON@

from __future__ import print_function
import getopt
import os
import re
import sys

import ovs.json
import ovs.db.error
import ovs.db.schema
from ovs.db.types import StringType, IntegerType, RealType

argv0 = sys.argv[0]

def parseSchema(filename):
    return ovs.db.schema.IdlSchema.from_json(ovs.json.from_file(filename))

def annotateSchema(schemaFile, annotationFile):
    schemaJson = ovs.json.from_file(schemaFile)
    exec(compile(open(annotationFile, "rb").read(), annotationFile, 'exec'), globals(), {"s": schemaJson})
    ovs.json.to_stream(schemaJson, sys.stdout)
    sys.stdout.write('\n')

def constify(cType, const):
    if (const
        and cType.endswith('*') and
        (cType == 'char **' or not cType.endswith('**'))):
        return 'const %s' % cType
    else:
        return cType

def cMembers(prefix, tableName, columnName, column, const, refTable=True):
    comment = ""
    type = column.type

    if type.is_smap():
        comment = """
/* Sets the "%(c)s" column's value from the "%(t)s" table in 'row'
 * to '%(c)s'.
 *
 * The caller retains ownership of '%(c)s' and everything in it. */""" \
             % {'c': columnName,
                't': tableName}
        return (comment, [{'name': columnName,
                           'type': 'struct smap ',
                           'comment': ''}])

    comment = """\n/* Sets the "%s" column from the "%s" table in """\
              """'row' to\n""" % (columnName, tableName)

    if type.n_min == 1 and type.n_max == 1:
        singleton = True
        pointer = ''
    else:
        singleton = False
        if type.is_optional_pointer():
            pointer = ''
        else:
            pointer = '*'


    if type.value:
        keyName = "key_%s" % columnName
        valueName = "value_%s" % columnName

        key = {'name': keyName,
               'type': constify(type.key.toCType(prefix, refTable) + pointer, const),
               'comment': ''}
        value = {'name': valueName,
                 'type': constify(type.value.toCType(prefix, refTable) + pointer, const),
                 'comment': ''}

        if singleton:
            comment += " * the map with key '%s' and value '%s'\n *" \
                       % (keyName, valueName)
        else:
            comment += " * the map with keys '%s' and values '%s'\n *" \
                       % (keyName, valueName)
        members = [key, value]
    else:
        m = {'name': columnName,
             'type': constify(type.key.toCType(prefix, refTable) + pointer, const),
             'comment': type.cDeclComment()}

        if singleton:
            comment += " * '%s'" % columnName
        else:
            comment += " * the '%s' set" % columnName
        members = [m]

    if not singleton and not type.is_optional_pointer():
        sizeName = "n_%s" % columnName

        comment += " with '%s' entries" % sizeName
        members.append({'name': sizeName,
                        'type': 'size_t ',
                        'comment': ''})

    comment += ".\n"

    if type.is_optional() and not type.is_optional_pointer():
        comment += """ *
 * '%s' may be 0 or 1; if it is 0, then '%s'
 * may be NULL.\n""" \
        % ("n_%s" % columnName, columnName)

    if type.is_optional_pointer():
        comment += """ *
 * If "%s" is null, the column will be the empty set,
 * otherwise it will contain the specified value.\n""" % columnName

    if type.constraintsToEnglish():
        comment += """ *
 * Argument constraints: %s\n""" \
        % type.constraintsToEnglish(lambda s : '"%s"' % s)

    comment += " *\n * The caller retains ownership of the arguments. */"

    return (comment, members)

# This is equivalent to sorted(table.columns.items()), except that the
# sorting includes a topological component: if column B has a
# dependency on column A, then A will be sorted before B.
def sorted_columns(table):
    input = []
    for name, column in table.columns.items():
        dependencies = column.extensions.get('dependencies', [])
        for d in dependencies:
            if d not in table.columns:
                sys.stderr.write("Table %s column %s depends on column %s "
                                 "but there is no such column\n"
                                 % (table.name, name, d))
                sys.exit(1)
        input += [(name, column, set(dependencies))]

    output = []
    satisfied_dependencies = set()
    while input:
        done = []
        next = []
        for name, column, dependencies in input:
            if dependencies <= satisfied_dependencies:
                done += [(name, column)]
            else:
                next += [(name, column, dependencies)]

        if not done:
            sys.stderr.write("Table %s columns have circular dependencies\n"
                             % table.name)
            sys.exit(1)

        for name, column in done:
            satisfied_dependencies.add(name)
        output += sorted(done)
        input = next
    return output

# If a column name in the schema is a C or C++ keyword, append an underscore
# to the column name.
def replace_cplusplus_keyword(schema):
    keywords = {'alignas', 'alignof', 'and', 'and_eq', 'asm', 'auto', 'bitand',
                'bitor', 'bool', 'break', 'case', 'catch', 'char', 'char16_t',
                'char32_t', 'class', 'compl', 'concept', 'const', 'const_cast',
                'constexpr', 'continue', 'decltype', 'default', 'delete', 'do',
                'double', 'dynamic_cast', 'else', 'enum', 'explicit', 'export',
                'extern', 'false', 'float', 'for', 'friend', 'goto', 'if',
                'inline', 'int', 'long', 'mutable', 'namespace', 'new',
                'noexcept', 'not', 'not_eq', 'nullptr', 'operator', 'or',
                'or_eq', 'private', 'protected', 'public', 'register',
                'reinterpret_cast', 'requires', 'restrict', 'return', 'short',
                'signed', 'sizeof', 'static', 'static_assert', 'static_cast',
                'struct', 'switch', 'template', 'this', 'thread_local',
                'throw', 'true', 'try', 'typedef', 'typeid', 'typename',
                'union', 'unsigned', 'using', 'virtual', 'void', 'volatile',
                'wchar_t', 'while', 'xor', 'xor_eq'}

    for tableName, table in schema.tables.items():
        for columnName in table.columns:
            if columnName in keywords:
                table.columns[columnName + '_'] = table.columns.pop(columnName)

def printCIDLHeader(schemaFile):
    schema = parseSchema(schemaFile)
    replace_cplusplus_keyword(schema)
    prefix = schema.idlPrefix
    print('''\
/* Generated automatically -- do not modify!    -*- buffer-read-only: t -*- */

#ifndef %(prefix)sIDL_HEADER
#define %(prefix)sIDL_HEADER 1

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include "ovsdb-data.h"
#include "ovsdb-idl-provider.h"
#include "smap.h"
#include "uuid.h"

#ifdef  __cplusplus
extern "C" {
#endif
%(hDecls)s''' % {'prefix': prefix.upper(),
                'hDecls': schema.hDecls})

    for tableName, table in sorted(schema.tables.items()):
        structName = "%s%s" % (prefix, tableName.lower())

        print("")
        print("/* %s table. */" % tableName)
        print("struct %s {" % structName)
        print("\tstruct ovsdb_idl_row header_;")
        for columnName, column in sorted_columns(table):
            print("\n\t/* %s column. */" % columnName)
            if column.extensions.get("members"):
                print("\t%s" % column.extensions["members"])
                continue
            comment, members = cMembers(prefix, tableName,
                                        columnName, column, False)
            for member in members:
                print("\t%(type)s%(name)s;%(comment)s" % member)
        print("};")

        # Column indexes.
        printEnum("%s_column_id" % structName.lower(), ["%s_COL_%s" % (structName.upper(), columnName.upper())
                                                        for columnName, column in sorted_columns(table)]
                  + ["%s_N_COLUMNS" % structName.upper()])

        print("")
        for columnName in table.columns:
            print("#define %(s)s_col_%(c)s (%(s)s_columns[%(S)s_COL_%(C)s])" % {
                's': structName,
                'S': structName.upper(),
                'c': columnName,
                'C': columnName.upper()})

        print("\nextern struct ovsdb_idl_column %s_columns[%s_N_COLUMNS];" % (structName, structName.upper()))

        print('''
const struct %(s)s_table *%(s)s_table_get(const struct ovsdb_idl *);
const struct %(s)s *%(s)s_table_first(const struct %(s)s_table *);

#define %(S)s_TABLE_FOR_EACH(ROW, TABLE) \\
        for ((ROW) = %(s)s_table_first(TABLE); \\
             (ROW); \\
             (ROW) = %(s)s_next(ROW))
#define %(S)s_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \\
        for ((ROW) = %(s)s_table_first(TABLE); \\
             (ROW) ? ((NEXT) = %(s)s_next(ROW), 1) : 0; \\
             (ROW) = (NEXT))

const struct %(s)s *%(s)s_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct %(s)s *%(s)s_table_get_for_uuid(const struct %(s)s_table *, const struct uuid *);
const struct %(s)s *%(s)s_first(const struct ovsdb_idl *);
const struct %(s)s *%(s)s_next(const struct %(s)s *);
#define %(S)s_FOR_EACH(ROW, IDL) \\
        for ((ROW) = %(s)s_first(IDL); \\
             (ROW); \\
             (ROW) = %(s)s_next(ROW))
#define %(S)s_FOR_EACH_SAFE(ROW, NEXT, IDL) \\
        for ((ROW) = %(s)s_first(IDL); \\
             (ROW) ? ((NEXT) = %(s)s_next(ROW), 1) : 0; \\
             (ROW) = (NEXT))

unsigned int %(s)s_get_seqno(const struct ovsdb_idl *);
unsigned int %(s)s_row_get_seqno(const struct %(s)s *row, enum ovsdb_idl_change change);
const struct %(s)s *%(s)s_track_get_first(const struct ovsdb_idl *);
const struct %(s)s *%(s)s_track_get_next(const struct %(s)s *);
#define %(S)s_FOR_EACH_TRACKED(ROW, IDL) \\
        for ((ROW) = %(s)s_track_get_first(IDL); \\
             (ROW); \\
             (ROW) = %(s)s_track_get_next(ROW))

const struct %(s)s *%(s)s_table_track_get_first(const struct %(s)s_table *);
#define %(S)s_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \\
        for ((ROW) = %(s)s_table_track_get_first(TABLE); \\
             (ROW); \\
             (ROW) = %(s)s_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool %(s)s_is_new(const struct %(s)s *row)
{
    return %(s)s_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool %(s)s_is_deleted(const struct %(s)s *row)
{
    return %(s)s_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void %(s)s_index_destroy_row(const struct %(s)s *);

struct %(s)s *%(s)s_index_find(struct ovsdb_idl_index *, const struct %(s)s *);

int %(s)s_index_compare(
    struct ovsdb_idl_index *, 
    const struct %(s)s *, 
    const struct %(s)s *);
struct ovsdb_idl_cursor %(s)s_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor %(s)s_cursor_first_eq(
    struct ovsdb_idl_index *, const struct %(s)s *);
struct ovsdb_idl_cursor %(s)s_cursor_first_ge(
    struct ovsdb_idl_index *, const struct %(s)s *);

struct %(s)s *%(s)s_cursor_data(struct ovsdb_idl_cursor *);

#define %(S)s_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \\
        for (struct ovsdb_idl_cursor cursor__ = %(s)s_cursor_first_ge(INDEX, FROM); \\
             (cursor__.position \\
              && ((ROW) = %(s)s_cursor_data(&cursor__), \\
                  !(TO) || %(s)s_index_compare(INDEX, ROW, TO) <= 0)); \\
             ovsdb_idl_cursor_next(&cursor__))
#define %(S)s_FOR_EACH_EQUAL(ROW, KEY, INDEX) \\
        for (struct ovsdb_idl_cursor cursor__ = %(s)s_cursor_first_eq(INDEX, KEY); \\
             (cursor__.position \\
              ? ((ROW) = %(s)s_cursor_data(&cursor__), \\
                 ovsdb_idl_cursor_next_eq(&cursor__), \\
                 true) \\
              : false); \\
            )
#define %(S)s_FOR_EACH_BYINDEX(ROW, INDEX) \\
        for (struct ovsdb_idl_cursor cursor__ = %(s)s_cursor_first(INDEX); \\
             (cursor__.position \\
              ? ((ROW) = %(s)s_cursor_data(&cursor__), \\
                 ovsdb_idl_cursor_next(&cursor__), \\
                 true) \\
              : false); \\
            )

void %(s)s_init(struct %(s)s *);
void %(s)s_delete(const struct %(s)s *);
struct %(s)s *%(s)s_insert(struct ovsdb_idl_txn *);
bool %(s)s_is_updated(const struct %(s)s *, enum %(s)s_column_id);
''' % {'s': structName, 'S': structName.upper()})

        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            print('void %(s)s_verify_%(c)s(const struct %(s)s *);' % {'s': structName, 'c': columnName})

        print("")
        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            if column.type.value:
                valueParam = ', enum ovsdb_atomic_type value_type'
            else:
                valueParam = ''
            print('const struct ovsdb_datum *%(s)s_get_%(c)s(const struct %(s)s *, enum ovsdb_atomic_type key_type%(v)s);' % {
                's': structName, 'c': columnName, 'v': valueParam})

        print("")
        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            print('void %(s)s_set_%(c)s(const struct %(s)s *,' % {'s': structName, 'c': columnName}, end=' ')
            if column.type.is_smap():
                args = ['const struct smap *']
            else:
                comment, members = cMembers(prefix, tableName, columnName,
                                            column, True)
                args = ['%(type)s%(name)s' % member for member in members]
            print('%s);' % ', '.join(args))

        print("")
        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            if column.type.is_map():
                print('void %(s)s_update_%(c)s_setkey(const struct %(s)s *, ' % {'s': structName, 'c': columnName}, end=' ')
                print('%(coltype)s, %(valtype)s);' % {'coltype':column.type.key.to_const_c_type(prefix), 'valtype':column.type.value.to_const_c_type(prefix)})
                print('void %(s)s_update_%(c)s_delkey(const struct %(s)s *, ' % {'s': structName, 'c': columnName}, end=' ')
                print('%(coltype)s);' % {'coltype':column.type.key.to_const_c_type(prefix)})
            if column.type.is_set():
                print('void %(s)s_update_%(c)s_addvalue(const struct %(s)s *, ' % {'s': structName, 'c': columnName}, end=' ')
                print('%(valtype)s);' % {'valtype':column.type.key.to_const_c_type(prefix)})
                print('void %(s)s_update_%(c)s_delvalue(const struct %(s)s *, ' % {'s': structName, 'c': columnName}, end=' ')
                print('%(valtype)s);' % {'valtype':column.type.key.to_const_c_type(prefix)})

            print('void %(s)s_add_clause_%(c)s(struct ovsdb_idl_condition *, enum ovsdb_function function,' % {'s': structName, 'c': columnName}, end=' ')
            if column.type.is_smap():
                args = ['const struct smap *']
            else:
                comment, members = cMembers(prefix, tableName, columnName,
                                            column, True, refTable=False)
                args = ['%(type)s%(name)s' % member for member in members]
            print('%s);' % ', '.join(args))

            print('void %(s)s_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);' % {'s': structName})

        print("")

    # Table indexes.
        print("struct %(s)s *%(s)s_index_init_row(struct ovsdb_idl_index *);" % {'s': structName})
        print
        for columnName, column in sorted(table.columns.items()):
            print('void %(s)s_index_set_%(c)s(const struct %(s)s *,' % {'s': structName, 'c': columnName})
            if column.type.is_smap():
                args = ['const struct smap *']
            else:
                comment, members = cMembers(prefix, tableName, columnName,
                                            column, True)
                args = ['%(type)s%(name)s' % member for member in members]
            print('%s);' % ', '.join(args))

        print
    printEnum("%stable_id" % prefix.lower(), ["%sTABLE_%s" % (prefix.upper(), tableName.upper()) for tableName in sorted(schema.tables)] + ["%sN_TABLES" % prefix.upper()])
    print("")
    for tableName in schema.tables:
        print("#define %(p)stable_%(t)s (%(p)stable_classes[%(P)sTABLE_%(T)s])" % {
            'p': prefix,
            'P': prefix.upper(),
            't': tableName.lower(),
            'T': tableName.upper()})
    print("\nextern struct ovsdb_idl_table_class %stable_classes[%sN_TABLES];" % (prefix, prefix.upper()))

    print("\nextern struct ovsdb_idl_class %sidl_class;" % prefix)

    print("\nconst char * %sget_db_version(void);" % prefix)
    print('''
#ifdef  __cplusplus
}
#endif''')
    print("\n#endif /* %(prefix)sIDL_HEADER */" % {'prefix': prefix.upper()})


def printEnum(type, members):
    if len(members) == 0:
        return

    print("\nenum %s {" % type)
    for member in members[:-1]:
        print("    %s," % member)
    print("    %s" % members[-1])
    print("};")

def printCIDLSource(schemaFile):
    schema = parseSchema(schemaFile)
    replace_cplusplus_keyword(schema)
    prefix = schema.idlPrefix
    print('''\
/* Generated automatically -- do not modify!    -*- buffer-read-only: t -*- */

#include <config.h>
#include %(header)s
#include <limits.h>
#include "ovs-thread.h"
#include "ovsdb-data.h"
#include "ovsdb-error.h"
#include "util.h"

%(cDecls)s

''' % {'header': schema.idlHeader,
       'cDecls': schema.cDecls})

    # Cast functions.
    for tableName, table in sorted(schema.tables.items()):
        structName = "%s%s" % (prefix, tableName.lower())
        print('''
static struct %(s)s *
%(s)s_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct %(s)s, header_) : NULL;
}\
''' % {'s': structName})


    for tableName, table in sorted(schema.tables.items()):
        structName = "%s%s" % (prefix, tableName.lower())
        print("")
        print("/* %s table. */" % (tableName))

        print('''
const struct %(s)s_table *
%(s)s_table_get(const struct ovsdb_idl *idl)
{
    return (const struct %(s)s_table *) idl;
}

const struct %(s)s *
%(s)s_table_first(const struct %(s)s_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return %(s)s_first(idl);
}


const struct %(s)s *
%(s)s_table_track_get_first(const struct %(s)s_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return %(s)s_track_get_first(idl);
}
''' % {'s': structName})

        # Parse functions.
        for columnName, column in sorted_columns(table):
            if 'parse' in column.extensions:
                print('''
static void
%(s)s_parse_%(c)s(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum OVS_UNUSED)
{
    struct %(s)s *row = %(s)s_cast(row_);\
''' % {'s': structName, 'c': columnName})
                print(column.extensions["parse"])
                print("}")
                continue
            if column.extensions.get('synthetic'):
                # Synthetic columns aren't parsed from a datum.
                unused = " OVS_UNUSED"
            else:
                unused = ""
            print('''
static void
%(s)s_parse_%(c)s(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct %(s)s *row = %(s)s_cast(row_);''' % {'s': structName,
                                                'c': columnName})
            type = column.type
            if 'parse' in column.extensions:
                print(column.extensions["parse"])
                print("}")
                continue
            if type.value:
                keyVar = "row->key_%s" % columnName
                valueVar = "row->value_%s" % columnName
            else:
                keyVar = "row->%s" % columnName
                valueVar = None

            if type.is_smap():
                print("    smap_init(&row->%s);" % columnName)
                print("    for (size_t i = 0; i < datum->n; i++) {")
                print("        smap_add(&row->%s," % columnName)
                print("                 datum->keys[i].string,")
                print("                 datum->values[i].string);")
                print("    }")
            elif (type.n_min == 1 and type.n_max == 1) or type.is_optional_pointer():
                print("")
                print("    if (datum->n >= 1) {")
                if not type.key.ref_table:
                    print("        %s = datum->keys[0].%s;" % (keyVar, type.key.type.to_string()))
                else:
                    print("        %s = %s%s_cast(ovsdb_idl_get_row_arc(row_, &%stable_%s, &datum->keys[0].uuid));" % (keyVar, prefix, type.key.ref_table.name.lower(), prefix, type.key.ref_table.name.lower()))

                if valueVar:
                    if not type.value.ref_table:
                        print("        %s = datum->values[0].%s;" % (valueVar, type.value.type.to_string()))
                    else:
                        print("        %s = %s%s_cast(ovsdb_idl_get_row_arc(row_, &%stable_%s, &datum->values[0].uuid));" % (valueVar, prefix, type.value.ref_table.name.lower(), prefix, type.value.ref_table.name.lower()))
                print("    } else {")
                print("        %s" % type.key.initCDefault(keyVar, type.n_min == 0))
                if valueVar:
                    print("        %s" % type.value.initCDefault(valueVar, type.n_min == 0))
                print("    }")
            else:
                if type.n_max != sys.maxsize:
                    print("    size_t n = MIN(%d, datum->n);" % type.n_max)
                    nMax = "n"
                else:
                    nMax = "datum->n"
                print("    %s = NULL;" % keyVar)
                if valueVar:
                    print("    %s = NULL;" % valueVar)
                print("    row->n_%s = 0;" % columnName)
                print("    for (size_t i = 0; i < %s; i++) {" % nMax)
                if type.key.ref_table:
                    print("""\
        struct %s%s *keyRow = %s%s_cast(ovsdb_idl_get_row_arc(row_, &%stable_%s, &datum->keys[i].uuid));
        if (!keyRow) {
            continue;
        }\
""" % (prefix, type.key.ref_table.name.lower(), prefix, type.key.ref_table.name.lower(), prefix, type.key.ref_table.name.lower()))
                    keySrc = "keyRow"
                else:
                    keySrc = "datum->keys[i].%s" % type.key.type.to_string()
                if type.value and type.value.ref_table:
                    print("""\
        struct %s%s *valueRow = %s%s_cast(ovsdb_idl_get_row_arc(row_, &%stable_%s, &datum->values[i].uuid));
        if (!valueRow) {
            continue;
        }\
""" % (prefix, type.value.ref_table.name.lower(), prefix, type.value.ref_table.name.lower(), prefix, type.value.ref_table.name.lower()))
                    valueSrc = "valueRow"
                elif valueVar:
                    valueSrc = "datum->values[i].%s" % type.value.type.to_string()
                print("        if (!row->n_%s) {" % (columnName))

                print("            %s = xmalloc(%s * sizeof *%s);" % (
                    keyVar, nMax, keyVar))
                if valueVar:
                    print("            %s = xmalloc(%s * sizeof *%s);" % (
                        valueVar, nMax, valueVar))
                print("        }")
                print("        %s[row->n_%s] = %s;" % (keyVar, columnName, keySrc))
                if valueVar:
                    print("        %s[row->n_%s] = %s;" % (valueVar, columnName, valueSrc))
                print("        row->n_%s++;" % columnName)
                print("    }")
            print("}")

        # Unparse functions.
        for columnName, column in sorted_columns(table):
            type = column.type
            if (type.is_smap() or (type.n_min != 1 or type.n_max != 1) and not type.is_optional_pointer()) or 'unparse' in column.extensions:
                print('''
static void
%(s)s_unparse_%(c)s(struct ovsdb_idl_row *row_)
{
    struct %(s)s *row = %(s)s_cast(row_);''' % {'s': structName,
                                                'c': columnName})
                if 'unparse' in column.extensions:
                    print(column.extensions["unparse"])
                elif type.is_smap():
                    print("    smap_destroy(&row->%s);" % columnName)
                else:
                    if type.value:
                        keyVar = "row->key_%s" % columnName
                        valueVar = "row->value_%s" % columnName
                    else:
                        keyVar = "row->%s" % columnName
                        valueVar = None
                    print("    free(%s);" % keyVar)
                    if valueVar:
                        print("    free(%s);" % valueVar)
                print('}')
            else:
                print('''
static void
%(s)s_unparse_%(c)s(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}''' % {'s': structName, 'c': columnName})

        # Generic Row Initialization function.
        print("""
static void
%(s)s_init__(struct ovsdb_idl_row *row)
{
    %(s)s_init(%(s)s_cast(row));
}""" % {'s': structName})

        # Row Initialization function.
        print("""
/* Clears the contents of 'row' in table "%(t)s". */
void
%(s)s_init(struct %(s)s *row)
{
    memset(row, 0, sizeof *row); """ % {'s': structName, 't': tableName})
        for columnName, column in sorted_columns(table):
            if column.type.is_smap():
                print("    smap_init(&row->%s);" % columnName)
            elif (column.type.n_min == 1 and
                  column.type.n_max == 1 and
                  column.type.key.type == ovs.db.types.StringType and
                  not column.type.value):
                print("    row->%s = \"\";" % columnName)
        print("}")

        # First, next functions.
        print('''
/* Searches table "%(t)s" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct %(s)s *
%(s)s_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return %(s)s_cast(ovsdb_idl_get_row_for_uuid(idl, &%(p)stable_%(tl)s, uuid));
}

/* Searches table "%(t)s" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct %(s)s *
%(s)s_table_get_for_uuid(const struct %(s)s_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return %(s)s_get_for_uuid(idl, uuid);
}

/* Returns a row in table "%(t)s" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct %(s)s *
%(s)s_first(const struct ovsdb_idl *idl)
{
    return %(s)s_cast(ovsdb_idl_first_row(idl, &%(p)stable_%(tl)s));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct %(s)s *
%(s)s_next(const struct %(s)s *row)
{
    return %(s)s_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int %(s)s_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &%(p)stable_%(tl)s);
}

unsigned int %(s)s_row_get_seqno(const struct %(s)s *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct %(s)s *
%(s)s_track_get_first(const struct ovsdb_idl *idl)
{
    return %(s)s_cast(ovsdb_idl_track_get_first(idl, &%(p)stable_%(tl)s));
}

const struct %(s)s
*%(s)s_track_get_next(const struct %(s)s *row)
{
    return %(s)s_cast(ovsdb_idl_track_get_next(&row->header_));
}''' % {'s': structName,
        'p': prefix,
        'P': prefix.upper(),
        't': tableName,
        'tl': tableName.lower(),
        'T': tableName.upper()})

        print('''

/* Deletes 'row' from table "%(t)s".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
%(s)s_delete(const struct %(s)s *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "%(t)s" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct %(s)s *
%(s)s_insert(struct ovsdb_idl_txn *txn)
{
    return %(s)s_cast(ovsdb_idl_txn_insert(txn, &%(p)stable_%(tl)s, NULL));
}

bool
%(s)s_is_updated(const struct %(s)s *row, enum %(s)s_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &%(s)s_columns[column]);
}''' % {'s': structName,
        'p': prefix,
        'P': prefix.upper(),
        't': tableName,
        'tl': tableName.lower(),
        'T': tableName.upper()})

        # Verify functions.
        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            print('''
/* Causes the original contents of column "%(c)s" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "%(c)s" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "%(c)s" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "%(c)s" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     %(s)s_insert()).
 *
 *   - If "%(c)s" has already been modified (with
 *     %(s)s_set_%(c)s()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * %(s)s_set_%(c)s() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
%(s)s_verify_%(c)s(const struct %(s)s *row)
{
    ovsdb_idl_txn_verify(&row->header_, &%(s)s_col_%(c)s);
}''' % {'s': structName,
        'S': structName.upper(),
        'c': columnName,
        'C': columnName.upper()})

        # Get functions.
        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            if column.type.value:
                valueParam = ',\n\tenum ovsdb_atomic_type value_type OVS_UNUSED'
                valueType = '\n    ovs_assert(value_type == %s);' % column.type.value.toAtomicType()
                valueComment = "\n * 'value_type' must be %s." % column.type.value.toAtomicType()
            else:
                valueParam = ''
                valueType = ''
                valueComment = ''
            print("""
/* Returns the "%(c)s" column's value from the "%(t)s" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be %(kt)s.%(vc)s
 * (This helps to avoid silent bugs if someone changes %(c)s's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "%(c)s" member in %(s)s. */
const struct ovsdb_datum *
%(s)s_get_%(c)s(const struct %(s)s *row,
\tenum ovsdb_atomic_type key_type OVS_UNUSED%(v)s)
{
    ovs_assert(key_type == %(kt)s);%(vt)s
    return ovsdb_idl_read(&row->header_, &%(s)s_col_%(c)s);
}""" % {'t': tableName, 's': structName, 'c': columnName,
       'kt': column.type.key.toAtomicType(),
       'v': valueParam, 'vt': valueType, 'vc': valueComment})

        # Set functions.
        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            type = column.type

            comment, members = cMembers(prefix, tableName, columnName,
                                        column, True)

            if type.is_smap():
                print(comment)
                print("""void
%(s)s_set_%(c)s(const struct %(s)s *row, const struct smap *%(c)s)
{
    struct ovsdb_datum datum;

    if (%(c)s) {
        ovsdb_datum_from_smap(&datum, %(c)s);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &%(s)s_col_%(c)s,
                        &datum);
}
""" % {'t': tableName,
       's': structName,
       'S': structName.upper(),
       'c': columnName,
       'C': columnName.upper()})
                continue

            keyVar = members[0]['name']
            nVar = None
            valueVar = None
            if type.value:
                valueVar = members[1]['name']
                if len(members) > 2:
                    nVar = members[2]['name']
            else:
                if len(members) > 1:
                    nVar = members[1]['name']

            print(comment)
            print("""\
void
%(s)s_set_%(c)s(const struct %(s)s *row, %(args)s)
{
    struct ovsdb_datum datum;""" % {'s': structName,
        'c': columnName,
        'args': ', '.join(['%(type)s%(name)s'
                           % m for m in members])})
            if type.n_min == 1 and type.n_max == 1:
                print("    union ovsdb_atom key;")
                if type.value:
                    print("    union ovsdb_atom value;")
                print("")
                print("    datum.n = 1;")
                print("    datum.keys = &key;")
                print("    " + type.key.assign_c_value_casting_away_const("key.%s" % type.key.type.to_string(), keyVar))
                if type.value:
                    print("    datum.values = &value;")
                    print("    "+ type.value.assign_c_value_casting_away_const("value.%s" % type.value.type.to_string(), valueVar))
                else:
                    print("    datum.values = NULL;")
                txn_write_func = "ovsdb_idl_txn_write_clone"
            elif type.is_optional_pointer():
                print("    union ovsdb_atom key;")
                print("")
                print("    if (%s) {" % keyVar)
                print("        datum.n = 1;")
                print("        datum.keys = &key;")
                print("        " + type.key.assign_c_value_casting_away_const("key.%s" % type.key.type.to_string(), keyVar))
                print("    } else {")
                print("        datum.n = 0;")
                print("        datum.keys = NULL;")
                print("    }")
                print("    datum.values = NULL;")
                txn_write_func = "ovsdb_idl_txn_write_clone"
            elif type.n_max == 1:
                print("    union ovsdb_atom key;")
                print("")
                print("    if (%s) {" % nVar)
                print("        datum.n = 1;")
                print("        datum.keys = &key;")
                print("        " + type.key.assign_c_value_casting_away_const("key.%s" % type.key.type.to_string(), "*" + keyVar))
                print("    } else {")
                print("        datum.n = 0;")
                print("        datum.keys = NULL;")
                print("    }")
                print("    datum.values = NULL;")
                txn_write_func = "ovsdb_idl_txn_write_clone"
            else:
                print("")
                print("    datum.n = %s;" % nVar)
                print("    datum.keys = %s ? xmalloc(%s * sizeof *datum.keys) : NULL;" % (nVar, nVar))
                if type.value:
                    print("    datum.values = xmalloc(%s * sizeof *datum.values);" % nVar)
                else:
                    print("    datum.values = NULL;")
                print("    for (size_t i = 0; i < %s; i++) {" % nVar)
                print("        " + type.key.copyCValue("datum.keys[i].%s" % type.key.type.to_string(), "%s[i]" % keyVar))
                if type.value:
                    print("        " + type.value.copyCValue("datum.values[i].%s" % type.value.type.to_string(), "%s[i]" % valueVar))
                print("    }")
                if type.value:
                    valueType = type.value.toAtomicType()
                else:
                    valueType = "OVSDB_TYPE_VOID"
                txn_write_func = "ovsdb_idl_txn_write"
            print("    %(f)s(&row->header_, &%(s)s_col_%(c)s, &datum);" \
                % {'f': txn_write_func,
                   's': structName,
                   'S': structName.upper(),
                   'c': columnName})
            print("}")
        # Update/Delete of partial map column functions
        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            type = column.type
            if type.is_map():
                print('''
/* Sets an element of the "%(c)s" map column from the "%(t)s" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
%(s)s_update_%(c)s_setkey(const struct %(s)s *row, %(coltype)snew_key, %(valtype)snew_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);
''' % {'s': structName, 'c': columnName,'coltype':column.type.key.to_const_c_type(prefix),
        'valtype':column.type.value.to_const_c_type(prefix), 'S': structName.upper(),
        'C': columnName.upper(), 't': tableName})

                print("    "+ type.key.copyCValue("datum->keys[0].%s" % type.key.type.to_string(), "new_key"))
                print("    "+ type.value.copyCValue("datum->values[0].%s" % type.value.type.to_string(), "new_value"))
                print('''
    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &%(s)s_col_%(c)s,
                                    datum);
}''' % {'s': structName, 'c': columnName,'coltype':column.type.key.toCType(prefix),
        'valtype':column.type.value.to_const_c_type(prefix), 'S': structName.upper()})
                print('''
/* Deletes an element of the "%(c)s" map column from the "%(t)s" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
%(s)s_update_%(c)s_delkey(const struct %(s)s *row, %(coltype)sdelete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;
''' % {'s': structName, 'c': columnName,'coltype':column.type.key.to_const_c_type(prefix),
        'valtype':column.type.value.to_const_c_type(prefix), 'S': structName.upper(),
        'C': columnName.upper(), 't': tableName})

                print("    "+ type.key.copyCValue("datum->keys[0].%s" % type.key.type.to_string(), "delete_key"))
                print('''
    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &%(s)s_col_%(c)s,
                                    datum);
}''' % {'s': structName, 'c': columnName,'coltype':column.type.key.toCType(prefix),
        'valtype':column.type.value.to_const_c_type(prefix), 'S': structName.upper()})
        # End Update/Delete of partial maps
        # Update/Delete of partial set column functions
            if type.is_set():
                print('''
/* Adds the value 'new_value' to the "%(c)s" set column from the "%(t)s" table
 * in 'row'.
 *
 */
void
%(s)s_update_%(c)s_addvalue(const struct %(s)s *row, %(valtype)snew_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;
''' % {'s': structName, 'c': columnName,
        'valtype':column.type.key.to_const_c_type(prefix), 't': tableName})

                print("    "+ type.key.copyCValue("datum->keys[0].%s" % type.key.type.to_string(), "new_value"))
                print('''
    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &%(s)s_col_%(c)s,
                                    datum);
}''' % {'s': structName, 'c': columnName,'coltype':column.type.key.toCType(prefix),
        'valtype':column.type.key.to_const_c_type(prefix), 'S': structName.upper()})
                print('''
/* Deletes the value 'delete_value' from the "%(c)s" set column from the
 * "%(t)s" table in 'row'.
 *
 */
void
%(s)s_update_%(c)s_delvalue(const struct %(s)s *row, %(valtype)sdelete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;
''' % {'s': structName, 'c': columnName,'coltype':column.type.key.to_const_c_type(prefix),
        'valtype':column.type.key.to_const_c_type(prefix), 'S': structName.upper(),
        'C': columnName.upper(), 't': tableName})

                print("    "+ type.key.copyCValue("datum->keys[0].%s" % type.key.type.to_string(), "delete_value"))
                print('''
    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &%(s)s_col_%(c)s,
                                    datum);
}''' % {'s': structName, 'c': columnName,'coltype':column.type.key.toCType(prefix),
        'valtype':column.type.key.to_const_c_type(prefix), 'S': structName.upper()})
        # End Update/Delete of partial set

        # Add clause functions.
        for columnName, column in sorted_columns(table):
            if column.extensions.get('synthetic'):
                continue
            type = column.type

            comment, members = cMembers(prefix, tableName, columnName,
                                        column, True, refTable=False)

            if type.is_smap():
                print(comment)
                print("""void
%(s)s_add_clause_%(c)s(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *%(c)s)
{
    struct ovsdb_datum datum;

    if (%(c)s) {
        ovsdb_datum_from_smap(&datum, %(c)s);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &%(s)s_col_%(c)s,
                                   &datum);

    ovsdb_datum_destroy(&datum, &%(s)s_col_%(c)s.type);
}
""" % {'t': tableName,
       'tl': tableName.lower(),
       'T': tableName.upper(),
       'p': prefix,
       'P': prefix.upper(),
       's': structName,
       'S': structName.upper(),
       'c': columnName})
                continue

            keyVar = members[0]['name']
            nVar = None
            valueVar = None
            if type.value:
                valueVar = members[1]['name']
                if len(members) > 2:
                    nVar = members[2]['name']
            else:
                if len(members) > 1:
                    nVar = members[1]['name']

            print(comment)
            print('void')
            print('%(s)s_add_clause_%(c)s(struct ovsdb_idl_condition *cond, enum ovsdb_function function, %(args)s)' % \
                {'s': structName, 'c': columnName,
                 'args': ', '.join(['%(type)s%(name)s' % m for m in members])})
            print("{")
            print("    struct ovsdb_datum datum;")
            free = []
            if type.n_min == 1 and type.n_max == 1:
                print("    union ovsdb_atom key;")
                if type.value:
                    print("    union ovsdb_atom value;")
                print("")
                print("    datum.n = 1;")
                print("    datum.keys = &key;")
                print("    " + type.key.assign_c_value_casting_away_const("key.%s" % type.key.type.to_string(), keyVar, refTable=False))
                if type.value:
                    print("    datum.values = &value;")
                    print("    "+ type.value.assign_c_value_casting_away_const("value.%s" % type.value.type.to_string(), valueVar, refTable=False))
                else:
                    print("    datum.values = NULL;")
            elif type.is_optional_pointer():
                print("    union ovsdb_atom key;")
                print("")
                print("    if (%s) {" % keyVar)
                print("        datum.n = 1;")
                print("        datum.keys = &key;")
                print("        " + type.key.assign_c_value_casting_away_const("key.%s" % type.key.type.to_string(), keyVar, refTable=False))
                print("    } else {")
                print("        datum.n = 0;")
                print("        datum.keys = NULL;")
                print("    }")
                print("    datum.values = NULL;")
            elif type.n_max == 1:
                print("    union ovsdb_atom key;")
                print("")
                print("    if (%s) {" % nVar)
                print("        datum.n = 1;")
                print("        datum.keys = &key;")
                print("        " + type.key.assign_c_value_casting_away_const("key.%s" % type.key.type.to_string(), "*" + keyVar, refTable=False))
                print("    } else {")
                print("        datum.n = 0;")
                print("        datum.keys = NULL;")
                print("    }")
                print("    datum.values = NULL;")
            else:
                print("    datum.n = %s;" % nVar)
                print("    datum.keys = %s ? xmalloc(%s * sizeof *datum.keys) : NULL;" % (nVar, nVar))
                free += ['datum.keys']
                if type.value:
                    print("    datum.values = xmalloc(%s * sizeof *datum.values);" % nVar)
                    free += ['datum.values']
                else:
                    print("    datum.values = NULL;")
                print("    for (size_t i = 0; i < %s; i++) {" % nVar)
                print("        " + type.key.assign_c_value_casting_away_const("datum.keys[i].%s" % type.key.type.to_string(), "%s[i]" % keyVar, refTable=False))
                if type.value:
                    print("        " + type.value.assign_c_value_casting_away_const("datum.values[i].%s" % type.value.type.to_string(), "%s[i]" % valueVar, refTable=False))
                print("    }")
                if type.value:
                    valueType = type.value.toAtomicType()
                else:
                    valueType = "OVSDB_TYPE_VOID"
                print("    ovsdb_datum_sort_unique(&datum, %s, %s);" % (
                    type.key.toAtomicType(), valueType))

            print("""    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &%(s)s_col_%(c)s,
                          &datum);\
""" % {'tl': tableName.lower(),
       'T': tableName.upper(),
       'p': prefix,
       'P': prefix.upper(),
       's': structName,
       'S': structName.upper(),
       'c': columnName})
            for var in free:
                print("    free(%s);" % var)
            print("}")

# Index table related functions
        print("""
/* Destroy 'row' of kind "%(t)s". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
%(s)s_index_destroy_row(const struct %(s)s *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        """ % { 's' : structName, 't': tableName })
        print("""
/* Creates a new row of kind "%(t)s". */
struct %(s)s *
%(s)s_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &%(p)stable_%(tl)s);
    return ALIGNED_CAST(struct %(s)s *, ovsdb_idl_index_init_row(index));
}

struct %(s)s *
%(s)s_index_find(struct ovsdb_idl_index *index, const struct %(s)s *target)
{
    ovs_assert(index->table->class_ == &%(p)stable_%(tl)s);
    return %(s)s_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
%(s)s_index_compare(
    struct ovsdb_idl_index *index, 
    const struct %(s)s *a, 
    const struct %(s)s *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
%(s)s_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &%(p)stable_%(tl)s);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
%(s)s_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct %(s)s *target)
{
    ovs_assert(index->table->class_ == &%(p)stable_%(tl)s);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
%(s)s_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct %(s)s *target)
{
    ovs_assert(index->table->class_ == &%(p)stable_%(tl)s);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct %(s)s *
%(s)s_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return %(s)s_cast(ovsdb_idl_cursor_data(cursor));
}
""" % {'s': structName,
        'c': columnName,
        't': tableName,
        'tl': tableName.lower(),
        'p': prefix})
        # Indexes Set functions
        for columnName, column in sorted(table.columns.items()):
            type = column.type

            comment, members = cMembers(prefix, tableName, columnName,
                                        column, True)

            if type.is_smap():
                print(comment)
                print("""void
%(s)s_index_set_%(c)s(const struct %(s)s *row, const struct smap *%(c)s)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (%(c)s) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(%(c)s);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, %(c)s) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &%(s)s_columns[%(S)s_COL_%(C)s],
                          datum,
                          &%(p)stable_classes[%(P)sTABLE_%(T)s]);
}
""" % {'t': tableName,
       'p': prefix,
       'P': prefix.upper(),
       's': structName,
       'S': structName.upper(),
       'c': columnName,
       'C': columnName.upper(),
       't': tableName,
       'T': tableName.upper()})
                continue

            keyVar = members[0]['name']
            nVar = None
            valueVar = None
            if type.value:
                valueVar = members[1]['name']
                if len(members) > 2:
                    nVar = members[2]['name']
            else:
                if len(members) > 1:
                    nVar = members[1]['name']

            print(comment)
            print('void')
            print('%(s)s_index_set_%(c)s(const struct %(s)s *row, %(args)s)' % \
                {'s': structName, 'c': columnName,
                 'args': ', '.join(['%(type)s%(name)s' % m for m in members])})
            print("{")
            print("    struct ovsdb_datum datum;")
            if type.n_min == 1 and type.n_max == 1:
                print("    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));")
                if type.value:
                    print("    union ovsdb_atom *value = xmalloc(sizeof(union ovsdb_atom));")
                print()
                print("    datum.n = 1;")
                print("    datum.keys = key;")
                print("    " + type.key.assign_c_value_casting_away_const("key->%s" % type.key.type.to_string(), keyVar))
                if type.value:
                    print("    datum.values = value;")
                    print("    "+ type.value.assign_c_value_casting_away_const("value->%s" % type.value.type.to_string(), valueVar))
                else:
                    print("    datum.values = NULL;")
                txn_write_func = "ovsdb_idl_index_write"
            elif type.is_optional_pointer():
                print("    union ovsdb_atom *key = xmalloc(sizeof (union ovsdb_atom));")
                print()
                print("    if (%s) {" % keyVar)
                print("        datum.n = 1;")
                print("        datum.keys = key;")
                print("        " + type.key.assign_c_value_casting_away_const("key->%s" % type.key.type.to_string(), keyVar))
                print("    } else {")
                print("        datum.n = 0;")
                print("        datum.keys = NULL;")
                print("    }")
                print("    datum.values = NULL;")
                txn_write_func = "ovsdb_idl_index_write"
            elif type.n_max == 1:
                print("    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));")
                print()
                print("    if (%s) {" % nVar)
                print("        datum.n = 1;")
                print("        datum.keys = key;")
                print("        " + type.key.assign_c_value_casting_away_const("key->%s" % type.key.type.to_string(), "*" + keyVar))
                print("    } else {")
                print("        datum.n = 0;")
                print("        datum.keys = NULL;")
                print("    }")
                print("    datum.values = NULL;")
                txn_write_func = "ovsdb_idl_index_write"
            else:
                print("    size_t i;")
                print()
                print("    datum.n = %s;" % nVar)
                print("    datum.keys = %s ? xmalloc(%s * sizeof *datum.keys) : NULL;" % (nVar, nVar))
                if type.value:
                    print("    datum.values = xmalloc(%s * sizeof *datum.values);" % nVar)
                else:
                    print("    datum.values = NULL;")
                print("    for (i = 0; i < %s; i++) {" % nVar)
                print("        " + type.key.copyCValue("datum.keys[i].%s" % type.key.type.to_string(), "%s[i]" % keyVar))
                if type.value:
                    print("        " + type.value.copyCValue("datum.values[i].%s" % type.value.type.to_string(), "%s[i]" % valueVar))
                print("    }")
                if type.value:
                    valueType = type.value.toAtomicType()
                else:
                    valueType = "OVSDB_TYPE_VOID"
                print("    ovsdb_datum_sort_unique(&datum, %s, %s);" % (
                    type.key.toAtomicType(), valueType))
                txn_write_func = "ovsdb_idl_index_write"
            print("    %(f)s(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &%(s)s_columns[ %(S)s_COL_%(C)s ], &datum, &%(p)stable_classes[%(P)sTABLE_%(T)s]);" \
                % {'f': txn_write_func,
                   's': structName,
                   'S': structName.upper(),
                   'C': columnName.upper(),
                   'p': prefix,
                   'P': prefix.upper(),
                   't': tableName,
                   'T': tableName.upper()})
            print("}")
# End Index table related functions

        # Table columns.
        print("\nstruct ovsdb_idl_column %s_columns[%s_N_COLUMNS];" % (
            structName, structName.upper()))
        print("""
void
%(s)s_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &%(p)stable_%(tl)s, condition);
}""" % {'p': prefix,
        's': structName,
        'tl': tableName.lower()})

        # Table columns.
        for columnName, column in sorted_columns(table):
            prereqs = []
            x = column.type.cInitType("%s_col_%s" % (tableName, columnName), prereqs)
            if prereqs:
                print('\n'.join(prereqs))
        print("\nstruct ovsdb_idl_column %s_columns[%s_N_COLUMNS] = {" % (
            structName, structName.upper()))
        for columnName, column in sorted_columns(table):
            if column.mutable:
                mutable = "true"
            else:
                mutable = "false"
            if column.extensions.get("synthetic"):
                synthetic = "true"
            else:
                synthetic = "false"
            type_init = '\n'.join("            " + x
                                  for x in column.type.cInitType("%s_col_%s" % (tableName, columnName), prereqs))
            print("""\
    [%(P)s%(T)s_COL_%(C)s] = {
         .name = "%(column_name_in_schema)s",
         .type = {
%(type)s
         },
         .is_mutable = %(mutable)s,
         .is_synthetic = %(synthetic)s,
         .parse = %(s)s_parse_%(c)s,
         .unparse = %(s)s_unparse_%(c)s,
    },\n""" % {'P': prefix.upper(),
               'T': tableName.upper(),
               'c': columnName,
               'C': columnName.upper(),
               's': structName,
               'mutable': mutable,
               'synthetic': synthetic,
               'type': type_init,
               'column_name_in_schema': column.name})
        print("};")

    # Table classes.
    print("")
    print("struct ovsdb_idl_table_class %stable_classes[%sN_TABLES] = {" % (prefix, prefix.upper()))
    for tableName, table in sorted(schema.tables.items()):
        structName = "%s%s" % (prefix, tableName.lower())
        if table.is_root:
            is_root = "true"
        else:
            is_root = "false"
        if table.max_rows == 1:
            is_singleton = "true"
        else:
            is_singleton = "false"
        print("    {\"%s\", %s, %s," % (tableName, is_root, is_singleton))
        print("     %s_columns, ARRAY_SIZE(%s_columns)," % (
              structName, structName))
        print("     sizeof(struct %s), %s_init__}," % (structName, structName))
    print("};")

    # IDL class.
    print("\nstruct ovsdb_idl_class %sidl_class = {" % prefix)
    print("    \"%s\", %stable_classes, ARRAY_SIZE(%stable_classes)" % (
        schema.name, prefix, prefix))
    print("};")

    print("""
/* Return the schema version.  The caller must not free the returned value. */
const char *
%sget_db_version(void)
{
    return "%s";
}
""" % (prefix, schema.version))

#Salam
def print_ovn_sb_idlh():
    print("""
/* Generated automatically -- do not modify!    -*- buffer-read-only: t -*- */

#ifndef SBREC_IDL_HEADER
#define SBREC_IDL_HEADER 1

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include "ovsdb-data.h"
#include "ovsdb-idl-provider.h"
#include "smap.h"
#include "uuid.h"
#include "ovn/lib/ovn-nb-idl.h" //Salam

#ifdef  __cplusplus
extern "C" {
#endif
#include "ovn/lib/ovn-util.h"

/* Address_Set table. */
struct sbrec_address_set {
    struct ovsdb_idl_row header_;

    /* addresses column. */
    char **addresses;
    size_t n_addresses;

    /* name column. */
    char *name;    /* Always nonnull. */
};

enum sbrec_address_set_column_id {
    SBREC_ADDRESS_SET_COL_ADDRESSES,
    SBREC_ADDRESS_SET_COL_NAME,
    SBREC_ADDRESS_SET_N_COLUMNS
};

#define sbrec_address_set_col_addresses (sbrec_address_set_columns[SBREC_ADDRESS_SET_COL_ADDRESSES])
#define sbrec_address_set_col_name (sbrec_address_set_columns[SBREC_ADDRESS_SET_COL_NAME])

extern struct ovsdb_idl_column sbrec_address_set_columns[SBREC_ADDRESS_SET_N_COLUMNS];

const struct sbrec_address_set_table *sbrec_address_set_table_get(const struct ovsdb_idl *);
const struct sbrec_address_set *sbrec_address_set_table_first(const struct sbrec_address_set_table *);

#define SBREC_ADDRESS_SET_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_address_set_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_address_set_next(ROW))
#define SBREC_ADDRESS_SET_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_address_set_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_address_set_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_address_set *sbrec_address_set_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_address_set *sbrec_address_set_table_get_for_uuid(const struct sbrec_address_set_table *, const struct uuid *);
const struct sbrec_address_set *sbrec_address_set_first(const struct ovsdb_idl *);
const struct sbrec_address_set *sbrec_address_set_next(const struct sbrec_address_set *);
#define SBREC_ADDRESS_SET_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_address_set_first(IDL); \
             (ROW); \
             (ROW) = sbrec_address_set_next(ROW))
#define SBREC_ADDRESS_SET_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_address_set_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_address_set_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_address_set_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_address_set_row_get_seqno(const struct sbrec_address_set *row, enum ovsdb_idl_change change);
const struct sbrec_address_set *sbrec_address_set_track_get_first(const struct ovsdb_idl *);
const struct sbrec_address_set *sbrec_address_set_track_get_next(const struct sbrec_address_set *);
#define SBREC_ADDRESS_SET_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_address_set_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_address_set_track_get_next(ROW))

const struct sbrec_address_set *sbrec_address_set_table_track_get_first(const struct sbrec_address_set_table *);
#define SBREC_ADDRESS_SET_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_address_set_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_address_set_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_address_set_is_new(const struct sbrec_address_set *row)
{
    return sbrec_address_set_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_address_set_is_deleted(const struct sbrec_address_set *row)
{
    return sbrec_address_set_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_address_set_index_destroy_row(const struct sbrec_address_set *);

struct sbrec_address_set *sbrec_address_set_index_find(struct ovsdb_idl_index *, const struct sbrec_address_set *);

int sbrec_address_set_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_address_set *, 
    const struct sbrec_address_set *);
struct ovsdb_idl_cursor sbrec_address_set_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_address_set_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_address_set *);
struct ovsdb_idl_cursor sbrec_address_set_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_address_set *);

struct sbrec_address_set *sbrec_address_set_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_ADDRESS_SET_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_address_set_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_address_set_cursor_data(&cursor__), \
                  !(TO) || sbrec_address_set_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_ADDRESS_SET_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_address_set_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_address_set_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_ADDRESS_SET_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_address_set_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_address_set_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_address_set_init(struct sbrec_address_set *);
void sbrec_address_set_delete(const struct sbrec_address_set *);
struct sbrec_address_set *sbrec_address_set_insert(struct ovsdb_idl_txn *);
bool sbrec_address_set_is_updated(const struct sbrec_address_set *, enum sbrec_address_set_column_id);

void sbrec_address_set_verify_addresses(const struct sbrec_address_set *);
void sbrec_address_set_verify_name(const struct sbrec_address_set *);

const struct ovsdb_datum *sbrec_address_set_get_addresses(const struct sbrec_address_set *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_address_set_get_name(const struct sbrec_address_set *, enum ovsdb_atomic_type key_type);

void sbrec_address_set_set_addresses(const struct sbrec_address_set *, const char **addresses, size_t n_addresses);
void sbrec_address_set_set_name(const struct sbrec_address_set *, const char *name);

void sbrec_address_set_update_addresses_addvalue(const struct sbrec_address_set *,  const char *);
void sbrec_address_set_update_addresses_delvalue(const struct sbrec_address_set *,  const char *);
void sbrec_address_set_add_clause_addresses(struct ovsdb_idl_condition *, enum ovsdb_function function, const char **addresses, size_t n_addresses);
void sbrec_address_set_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_address_set_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_address_set_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_address_set *sbrec_address_set_index_init_row(struct ovsdb_idl_index *);
void sbrec_address_set_index_set_addresses(const struct sbrec_address_set *,
const char **addresses, size_t n_addresses);
void sbrec_address_set_index_set_name(const struct sbrec_address_set *,
const char *name);

/* Chassis table. */
struct sbrec_chassis {
    struct ovsdb_idl_row header_;

    /* encaps column. */
    struct sbrec_encap **encaps;
    size_t n_encaps;

    /* external_ids column. */
    struct smap external_ids;

    /* hostname column. */
    char *hostname;    /* Always nonnull. */

    /* name column. */
    char *name;    /* Always nonnull. */

    /* nb_cfg column. */
    int64_t nb_cfg;

    /* vtep_logical_switches column. */
    char **vtep_logical_switches;
    size_t n_vtep_logical_switches;
};

enum sbrec_chassis_column_id {
    SBREC_CHASSIS_COL_ENCAPS,
    SBREC_CHASSIS_COL_EXTERNAL_IDS,
    SBREC_CHASSIS_COL_HOSTNAME,
    SBREC_CHASSIS_COL_NAME,
    SBREC_CHASSIS_COL_NB_CFG,
    SBREC_CHASSIS_COL_VTEP_LOGICAL_SWITCHES,
    SBREC_CHASSIS_N_COLUMNS
};

#define sbrec_chassis_col_name (sbrec_chassis_columns[SBREC_CHASSIS_COL_NAME])
#define sbrec_chassis_col_hostname (sbrec_chassis_columns[SBREC_CHASSIS_COL_HOSTNAME])
#define sbrec_chassis_col_encaps (sbrec_chassis_columns[SBREC_CHASSIS_COL_ENCAPS])
#define sbrec_chassis_col_nb_cfg (sbrec_chassis_columns[SBREC_CHASSIS_COL_NB_CFG])
#define sbrec_chassis_col_vtep_logical_switches (sbrec_chassis_columns[SBREC_CHASSIS_COL_VTEP_LOGICAL_SWITCHES])
#define sbrec_chassis_col_external_ids (sbrec_chassis_columns[SBREC_CHASSIS_COL_EXTERNAL_IDS])

extern struct ovsdb_idl_column sbrec_chassis_columns[SBREC_CHASSIS_N_COLUMNS];

const struct sbrec_chassis_table *sbrec_chassis_table_get(const struct ovsdb_idl *);
const struct sbrec_chassis *sbrec_chassis_table_first(const struct sbrec_chassis_table *);

#define SBREC_CHASSIS_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_chassis_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_chassis_next(ROW))
#define SBREC_CHASSIS_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_chassis_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_chassis_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_chassis *sbrec_chassis_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_chassis *sbrec_chassis_table_get_for_uuid(const struct sbrec_chassis_table *, const struct uuid *);
const struct sbrec_chassis *sbrec_chassis_first(const struct ovsdb_idl *);
const struct sbrec_chassis *sbrec_chassis_next(const struct sbrec_chassis *);
#define SBREC_CHASSIS_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_chassis_first(IDL); \
             (ROW); \
             (ROW) = sbrec_chassis_next(ROW))
#define SBREC_CHASSIS_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_chassis_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_chassis_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_chassis_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_chassis_row_get_seqno(const struct sbrec_chassis *row, enum ovsdb_idl_change change);
const struct sbrec_chassis *sbrec_chassis_track_get_first(const struct ovsdb_idl *);
const struct sbrec_chassis *sbrec_chassis_track_get_next(const struct sbrec_chassis *);
#define SBREC_CHASSIS_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_chassis_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_chassis_track_get_next(ROW))

const struct sbrec_chassis *sbrec_chassis_table_track_get_first(const struct sbrec_chassis_table *);
#define SBREC_CHASSIS_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_chassis_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_chassis_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_chassis_is_new(const struct sbrec_chassis *row)
{
    return sbrec_chassis_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_chassis_is_deleted(const struct sbrec_chassis *row)
{
    return sbrec_chassis_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_chassis_index_destroy_row(const struct sbrec_chassis *);

struct sbrec_chassis *sbrec_chassis_index_find(struct ovsdb_idl_index *, const struct sbrec_chassis *);

int sbrec_chassis_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_chassis *, 
    const struct sbrec_chassis *);
struct ovsdb_idl_cursor sbrec_chassis_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_chassis_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_chassis *);
struct ovsdb_idl_cursor sbrec_chassis_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_chassis *);

struct sbrec_chassis *sbrec_chassis_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_CHASSIS_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_chassis_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_chassis_cursor_data(&cursor__), \
                  !(TO) || sbrec_chassis_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_CHASSIS_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_chassis_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_chassis_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_CHASSIS_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_chassis_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_chassis_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_chassis_init(struct sbrec_chassis *);
void sbrec_chassis_delete(const struct sbrec_chassis *);
struct sbrec_chassis *sbrec_chassis_insert(struct ovsdb_idl_txn *);
bool sbrec_chassis_is_updated(const struct sbrec_chassis *, enum sbrec_chassis_column_id);

void sbrec_chassis_verify_encaps(const struct sbrec_chassis *);
void sbrec_chassis_verify_external_ids(const struct sbrec_chassis *);
void sbrec_chassis_verify_hostname(const struct sbrec_chassis *);
void sbrec_chassis_verify_name(const struct sbrec_chassis *);
void sbrec_chassis_verify_nb_cfg(const struct sbrec_chassis *);
void sbrec_chassis_verify_vtep_logical_switches(const struct sbrec_chassis *);

const struct ovsdb_datum *sbrec_chassis_get_encaps(const struct sbrec_chassis *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_chassis_get_external_ids(const struct sbrec_chassis *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_chassis_get_hostname(const struct sbrec_chassis *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_chassis_get_name(const struct sbrec_chassis *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_chassis_get_nb_cfg(const struct sbrec_chassis *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_chassis_get_vtep_logical_switches(const struct sbrec_chassis *, enum ovsdb_atomic_type key_type);

void sbrec_chassis_set_encaps(const struct sbrec_chassis *, struct sbrec_encap **encaps, size_t n_encaps);
void sbrec_chassis_set_external_ids(const struct sbrec_chassis *, const struct smap *);
void sbrec_chassis_set_hostname(const struct sbrec_chassis *, const char *hostname);
void sbrec_chassis_set_name(const struct sbrec_chassis *, const char *name);
void sbrec_chassis_set_nb_cfg(const struct sbrec_chassis *, int64_t nb_cfg);
void sbrec_chassis_set_vtep_logical_switches(const struct sbrec_chassis *, const char **vtep_logical_switches, size_t n_vtep_logical_switches);

void sbrec_chassis_update_encaps_addvalue(const struct sbrec_chassis *,  const struct sbrec_encap *);
void sbrec_chassis_update_encaps_delvalue(const struct sbrec_chassis *,  const struct sbrec_encap *);
void sbrec_chassis_add_clause_encaps(struct ovsdb_idl_condition *, enum ovsdb_function function, struct uuid **encaps, size_t n_encaps);
void sbrec_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_chassis_update_external_ids_setkey(const struct sbrec_chassis *,  const char *, const char *);
void sbrec_chassis_update_external_ids_delkey(const struct sbrec_chassis *,  const char *);
void sbrec_chassis_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_chassis_add_clause_hostname(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *hostname);
void sbrec_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_chassis_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_chassis_add_clause_nb_cfg(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t nb_cfg);
void sbrec_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_chassis_update_vtep_logical_switches_addvalue(const struct sbrec_chassis *,  const char *);
void sbrec_chassis_update_vtep_logical_switches_delvalue(const struct sbrec_chassis *,  const char *);
void sbrec_chassis_add_clause_vtep_logical_switches(struct ovsdb_idl_condition *, enum ovsdb_function function, const char **vtep_logical_switches, size_t n_vtep_logical_switches);
void sbrec_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_chassis *sbrec_chassis_index_init_row(struct ovsdb_idl_index *);
void sbrec_chassis_index_set_encaps(const struct sbrec_chassis *,
struct sbrec_encap **encaps, size_t n_encaps);
void sbrec_chassis_index_set_external_ids(const struct sbrec_chassis *,
const struct smap *);
void sbrec_chassis_index_set_hostname(const struct sbrec_chassis *,
const char *hostname);
void sbrec_chassis_index_set_name(const struct sbrec_chassis *,
const char *name);
void sbrec_chassis_index_set_nb_cfg(const struct sbrec_chassis *,
int64_t nb_cfg);
void sbrec_chassis_index_set_vtep_logical_switches(const struct sbrec_chassis *,
const char **vtep_logical_switches, size_t n_vtep_logical_switches);

/* Connection table. */
struct sbrec_connection {
    struct ovsdb_idl_row header_;

    /* external_ids column. */
    struct smap external_ids;

    /* inactivity_probe column. */
    int64_t *inactivity_probe;
    size_t n_inactivity_probe;

    /* is_connected column. */
    bool is_connected;

    /* max_backoff column. */
    int64_t *max_backoff;
    size_t n_max_backoff;

    /* other_config column. */
    struct smap other_config;

    /* read_only column. */
    bool read_only;

    /* role column. */
    char *role;    /* Always nonnull. */

    /* status column. */
    struct smap status;

    /* target column. */
    char *target;    /* Always nonnull. */
};

enum sbrec_connection_column_id {
    SBREC_CONNECTION_COL_EXTERNAL_IDS,
    SBREC_CONNECTION_COL_INACTIVITY_PROBE,
    SBREC_CONNECTION_COL_IS_CONNECTED,
    SBREC_CONNECTION_COL_MAX_BACKOFF,
    SBREC_CONNECTION_COL_OTHER_CONFIG,
    SBREC_CONNECTION_COL_READ_ONLY,
    SBREC_CONNECTION_COL_ROLE,
    SBREC_CONNECTION_COL_STATUS,
    SBREC_CONNECTION_COL_TARGET,
    SBREC_CONNECTION_N_COLUMNS
};

#define sbrec_connection_col_max_backoff (sbrec_connection_columns[SBREC_CONNECTION_COL_MAX_BACKOFF])
#define sbrec_connection_col_read_only (sbrec_connection_columns[SBREC_CONNECTION_COL_READ_ONLY])
#define sbrec_connection_col_target (sbrec_connection_columns[SBREC_CONNECTION_COL_TARGET])
#define sbrec_connection_col_other_config (sbrec_connection_columns[SBREC_CONNECTION_COL_OTHER_CONFIG])
#define sbrec_connection_col_inactivity_probe (sbrec_connection_columns[SBREC_CONNECTION_COL_INACTIVITY_PROBE])
#define sbrec_connection_col_status (sbrec_connection_columns[SBREC_CONNECTION_COL_STATUS])
#define sbrec_connection_col_role (sbrec_connection_columns[SBREC_CONNECTION_COL_ROLE])
#define sbrec_connection_col_external_ids (sbrec_connection_columns[SBREC_CONNECTION_COL_EXTERNAL_IDS])
#define sbrec_connection_col_is_connected (sbrec_connection_columns[SBREC_CONNECTION_COL_IS_CONNECTED])

extern struct ovsdb_idl_column sbrec_connection_columns[SBREC_CONNECTION_N_COLUMNS];

const struct sbrec_connection_table *sbrec_connection_table_get(const struct ovsdb_idl *);
const struct sbrec_connection *sbrec_connection_table_first(const struct sbrec_connection_table *);

#define SBREC_CONNECTION_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_connection_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_connection_next(ROW))
#define SBREC_CONNECTION_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_connection_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_connection_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_connection *sbrec_connection_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_connection *sbrec_connection_table_get_for_uuid(const struct sbrec_connection_table *, const struct uuid *);
const struct sbrec_connection *sbrec_connection_first(const struct ovsdb_idl *);
const struct sbrec_connection *sbrec_connection_next(const struct sbrec_connection *);
#define SBREC_CONNECTION_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_connection_first(IDL); \
             (ROW); \
             (ROW) = sbrec_connection_next(ROW))
#define SBREC_CONNECTION_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_connection_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_connection_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_connection_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_connection_row_get_seqno(const struct sbrec_connection *row, enum ovsdb_idl_change change);
const struct sbrec_connection *sbrec_connection_track_get_first(const struct ovsdb_idl *);
const struct sbrec_connection *sbrec_connection_track_get_next(const struct sbrec_connection *);
#define SBREC_CONNECTION_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_connection_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_connection_track_get_next(ROW))

const struct sbrec_connection *sbrec_connection_table_track_get_first(const struct sbrec_connection_table *);
#define SBREC_CONNECTION_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_connection_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_connection_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_connection_is_new(const struct sbrec_connection *row)
{
    return sbrec_connection_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_connection_is_deleted(const struct sbrec_connection *row)
{
    return sbrec_connection_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_connection_index_destroy_row(const struct sbrec_connection *);

struct sbrec_connection *sbrec_connection_index_find(struct ovsdb_idl_index *, const struct sbrec_connection *);

int sbrec_connection_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_connection *, 
    const struct sbrec_connection *);
struct ovsdb_idl_cursor sbrec_connection_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_connection_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_connection *);
struct ovsdb_idl_cursor sbrec_connection_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_connection *);

struct sbrec_connection *sbrec_connection_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_CONNECTION_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_connection_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_connection_cursor_data(&cursor__), \
                  !(TO) || sbrec_connection_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_CONNECTION_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_connection_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_connection_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_CONNECTION_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_connection_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_connection_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_connection_init(struct sbrec_connection *);
void sbrec_connection_delete(const struct sbrec_connection *);
struct sbrec_connection *sbrec_connection_insert(struct ovsdb_idl_txn *);
bool sbrec_connection_is_updated(const struct sbrec_connection *, enum sbrec_connection_column_id);

void sbrec_connection_verify_external_ids(const struct sbrec_connection *);
void sbrec_connection_verify_inactivity_probe(const struct sbrec_connection *);
void sbrec_connection_verify_is_connected(const struct sbrec_connection *);
void sbrec_connection_verify_max_backoff(const struct sbrec_connection *);
void sbrec_connection_verify_other_config(const struct sbrec_connection *);
void sbrec_connection_verify_read_only(const struct sbrec_connection *);
void sbrec_connection_verify_role(const struct sbrec_connection *);
void sbrec_connection_verify_status(const struct sbrec_connection *);
void sbrec_connection_verify_target(const struct sbrec_connection *);

const struct ovsdb_datum *sbrec_connection_get_external_ids(const struct sbrec_connection *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_connection_get_inactivity_probe(const struct sbrec_connection *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_connection_get_is_connected(const struct sbrec_connection *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_connection_get_max_backoff(const struct sbrec_connection *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_connection_get_other_config(const struct sbrec_connection *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_connection_get_read_only(const struct sbrec_connection *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_connection_get_role(const struct sbrec_connection *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_connection_get_status(const struct sbrec_connection *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_connection_get_target(const struct sbrec_connection *, enum ovsdb_atomic_type key_type);

void sbrec_connection_set_external_ids(const struct sbrec_connection *, const struct smap *);
void sbrec_connection_set_inactivity_probe(const struct sbrec_connection *, const int64_t *inactivity_probe, size_t n_inactivity_probe);
void sbrec_connection_set_is_connected(const struct sbrec_connection *, bool is_connected);
void sbrec_connection_set_max_backoff(const struct sbrec_connection *, const int64_t *max_backoff, size_t n_max_backoff);
void sbrec_connection_set_other_config(const struct sbrec_connection *, const struct smap *);
void sbrec_connection_set_read_only(const struct sbrec_connection *, bool read_only);
void sbrec_connection_set_role(const struct sbrec_connection *, const char *role);
void sbrec_connection_set_status(const struct sbrec_connection *, const struct smap *);
void sbrec_connection_set_target(const struct sbrec_connection *, const char *target);

void sbrec_connection_update_external_ids_setkey(const struct sbrec_connection *,  const char *, const char *);
void sbrec_connection_update_external_ids_delkey(const struct sbrec_connection *,  const char *);
void sbrec_connection_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_connection_update_inactivity_probe_addvalue(const struct sbrec_connection *,  int64_t );
void sbrec_connection_update_inactivity_probe_delvalue(const struct sbrec_connection *,  int64_t );
void sbrec_connection_add_clause_inactivity_probe(struct ovsdb_idl_condition *, enum ovsdb_function function, const int64_t *inactivity_probe, size_t n_inactivity_probe);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_connection_add_clause_is_connected(struct ovsdb_idl_condition *, enum ovsdb_function function, bool is_connected);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_connection_update_max_backoff_addvalue(const struct sbrec_connection *,  int64_t );
void sbrec_connection_update_max_backoff_delvalue(const struct sbrec_connection *,  int64_t );
void sbrec_connection_add_clause_max_backoff(struct ovsdb_idl_condition *, enum ovsdb_function function, const int64_t *max_backoff, size_t n_max_backoff);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_connection_update_other_config_setkey(const struct sbrec_connection *,  const char *, const char *);
void sbrec_connection_update_other_config_delkey(const struct sbrec_connection *,  const char *);
void sbrec_connection_add_clause_other_config(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_connection_add_clause_read_only(struct ovsdb_idl_condition *, enum ovsdb_function function, bool read_only);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_connection_add_clause_role(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *role);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_connection_update_status_setkey(const struct sbrec_connection *,  const char *, const char *);
void sbrec_connection_update_status_delkey(const struct sbrec_connection *,  const char *);
void sbrec_connection_add_clause_status(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_connection_add_clause_target(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *target);
void sbrec_connection_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_connection *sbrec_connection_index_init_row(struct ovsdb_idl_index *);
void sbrec_connection_index_set_external_ids(const struct sbrec_connection *,
const struct smap *);
void sbrec_connection_index_set_inactivity_probe(const struct sbrec_connection *,
const int64_t *inactivity_probe, size_t n_inactivity_probe);
void sbrec_connection_index_set_is_connected(const struct sbrec_connection *,
bool is_connected);
void sbrec_connection_index_set_max_backoff(const struct sbrec_connection *,
const int64_t *max_backoff, size_t n_max_backoff);
void sbrec_connection_index_set_other_config(const struct sbrec_connection *,
const struct smap *);
void sbrec_connection_index_set_read_only(const struct sbrec_connection *,
bool read_only);
void sbrec_connection_index_set_role(const struct sbrec_connection *,
const char *role);
void sbrec_connection_index_set_status(const struct sbrec_connection *,
const struct smap *);
void sbrec_connection_index_set_target(const struct sbrec_connection *,
const char *target);

/* DHCP_Options table. */
struct sbrec_dhcp_options {
    struct ovsdb_idl_row header_;

    /* code column. */
    int64_t code;

    /* name column. */
    char *name;    /* Always nonnull. */

    /* type column. */
    char *type;    /* Always nonnull. */
};

enum sbrec_dhcp_options_column_id {
    SBREC_DHCP_OPTIONS_COL_CODE,
    SBREC_DHCP_OPTIONS_COL_NAME,
    SBREC_DHCP_OPTIONS_COL_TYPE,
    SBREC_DHCP_OPTIONS_N_COLUMNS
};

#define sbrec_dhcp_options_col_code (sbrec_dhcp_options_columns[SBREC_DHCP_OPTIONS_COL_CODE])
#define sbrec_dhcp_options_col_type (sbrec_dhcp_options_columns[SBREC_DHCP_OPTIONS_COL_TYPE])
#define sbrec_dhcp_options_col_name (sbrec_dhcp_options_columns[SBREC_DHCP_OPTIONS_COL_NAME])

extern struct ovsdb_idl_column sbrec_dhcp_options_columns[SBREC_DHCP_OPTIONS_N_COLUMNS];

const struct sbrec_dhcp_options_table *sbrec_dhcp_options_table_get(const struct ovsdb_idl *);
const struct sbrec_dhcp_options *sbrec_dhcp_options_table_first(const struct sbrec_dhcp_options_table *);

#define SBREC_DHCP_OPTIONS_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_dhcp_options_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_dhcp_options_next(ROW))
#define SBREC_DHCP_OPTIONS_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_dhcp_options_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_dhcp_options_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_dhcp_options *sbrec_dhcp_options_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_dhcp_options *sbrec_dhcp_options_table_get_for_uuid(const struct sbrec_dhcp_options_table *, const struct uuid *);
const struct sbrec_dhcp_options *sbrec_dhcp_options_first(const struct ovsdb_idl *);
const struct sbrec_dhcp_options *sbrec_dhcp_options_next(const struct sbrec_dhcp_options *);
#define SBREC_DHCP_OPTIONS_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_dhcp_options_first(IDL); \
             (ROW); \
             (ROW) = sbrec_dhcp_options_next(ROW))
#define SBREC_DHCP_OPTIONS_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_dhcp_options_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_dhcp_options_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_dhcp_options_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_dhcp_options_row_get_seqno(const struct sbrec_dhcp_options *row, enum ovsdb_idl_change change);
const struct sbrec_dhcp_options *sbrec_dhcp_options_track_get_first(const struct ovsdb_idl *);
const struct sbrec_dhcp_options *sbrec_dhcp_options_track_get_next(const struct sbrec_dhcp_options *);
#define SBREC_DHCP_OPTIONS_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_dhcp_options_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_dhcp_options_track_get_next(ROW))

const struct sbrec_dhcp_options *sbrec_dhcp_options_table_track_get_first(const struct sbrec_dhcp_options_table *);
#define SBREC_DHCP_OPTIONS_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_dhcp_options_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_dhcp_options_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_dhcp_options_is_new(const struct sbrec_dhcp_options *row)
{
    return sbrec_dhcp_options_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_dhcp_options_is_deleted(const struct sbrec_dhcp_options *row)
{
    return sbrec_dhcp_options_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_dhcp_options_index_destroy_row(const struct sbrec_dhcp_options *);

struct sbrec_dhcp_options *sbrec_dhcp_options_index_find(struct ovsdb_idl_index *, const struct sbrec_dhcp_options *);

int sbrec_dhcp_options_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_dhcp_options *, 
    const struct sbrec_dhcp_options *);
struct ovsdb_idl_cursor sbrec_dhcp_options_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_dhcp_options_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_dhcp_options *);
struct ovsdb_idl_cursor sbrec_dhcp_options_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_dhcp_options *);

struct sbrec_dhcp_options *sbrec_dhcp_options_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_DHCP_OPTIONS_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dhcp_options_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_dhcp_options_cursor_data(&cursor__), \
                  !(TO) || sbrec_dhcp_options_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_DHCP_OPTIONS_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dhcp_options_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_dhcp_options_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_DHCP_OPTIONS_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dhcp_options_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_dhcp_options_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_dhcp_options_init(struct sbrec_dhcp_options *);
void sbrec_dhcp_options_delete(const struct sbrec_dhcp_options *);
struct sbrec_dhcp_options *sbrec_dhcp_options_insert(struct ovsdb_idl_txn *);
bool sbrec_dhcp_options_is_updated(const struct sbrec_dhcp_options *, enum sbrec_dhcp_options_column_id);

void sbrec_dhcp_options_verify_code(const struct sbrec_dhcp_options *);
void sbrec_dhcp_options_verify_name(const struct sbrec_dhcp_options *);
void sbrec_dhcp_options_verify_type(const struct sbrec_dhcp_options *);

const struct ovsdb_datum *sbrec_dhcp_options_get_code(const struct sbrec_dhcp_options *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_dhcp_options_get_name(const struct sbrec_dhcp_options *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_dhcp_options_get_type(const struct sbrec_dhcp_options *, enum ovsdb_atomic_type key_type);

void sbrec_dhcp_options_set_code(const struct sbrec_dhcp_options *, int64_t code);
void sbrec_dhcp_options_set_name(const struct sbrec_dhcp_options *, const char *name);
void sbrec_dhcp_options_set_type(const struct sbrec_dhcp_options *, const char *type);

void sbrec_dhcp_options_add_clause_code(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t code);
void sbrec_dhcp_options_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_dhcp_options_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_dhcp_options_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_dhcp_options_add_clause_type(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *type);
void sbrec_dhcp_options_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_dhcp_options *sbrec_dhcp_options_index_init_row(struct ovsdb_idl_index *);
void sbrec_dhcp_options_index_set_code(const struct sbrec_dhcp_options *,
int64_t code);
void sbrec_dhcp_options_index_set_name(const struct sbrec_dhcp_options *,
const char *name);
void sbrec_dhcp_options_index_set_type(const struct sbrec_dhcp_options *,
const char *type);

/* DHCPv6_Options table. */
struct sbrec_dhcpv6_options {
    struct ovsdb_idl_row header_;

    /* code column. */
    int64_t code;

    /* name column. */
    char *name;    /* Always nonnull. */

    /* type column. */
    char *type;    /* Always nonnull. */
};

enum sbrec_dhcpv6_options_column_id {
    SBREC_DHCPV6_OPTIONS_COL_CODE,
    SBREC_DHCPV6_OPTIONS_COL_NAME,
    SBREC_DHCPV6_OPTIONS_COL_TYPE,
    SBREC_DHCPV6_OPTIONS_N_COLUMNS
};

#define sbrec_dhcpv6_options_col_code (sbrec_dhcpv6_options_columns[SBREC_DHCPV6_OPTIONS_COL_CODE])
#define sbrec_dhcpv6_options_col_type (sbrec_dhcpv6_options_columns[SBREC_DHCPV6_OPTIONS_COL_TYPE])
#define sbrec_dhcpv6_options_col_name (sbrec_dhcpv6_options_columns[SBREC_DHCPV6_OPTIONS_COL_NAME])

extern struct ovsdb_idl_column sbrec_dhcpv6_options_columns[SBREC_DHCPV6_OPTIONS_N_COLUMNS];

const struct sbrec_dhcpv6_options_table *sbrec_dhcpv6_options_table_get(const struct ovsdb_idl *);
const struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_table_first(const struct sbrec_dhcpv6_options_table *);

#define SBREC_DHCPV6_OPTIONS_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_dhcpv6_options_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_dhcpv6_options_next(ROW))
#define SBREC_DHCPV6_OPTIONS_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_dhcpv6_options_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_dhcpv6_options_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_table_get_for_uuid(const struct sbrec_dhcpv6_options_table *, const struct uuid *);
const struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_first(const struct ovsdb_idl *);
const struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_next(const struct sbrec_dhcpv6_options *);
#define SBREC_DHCPV6_OPTIONS_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_dhcpv6_options_first(IDL); \
             (ROW); \
             (ROW) = sbrec_dhcpv6_options_next(ROW))
#define SBREC_DHCPV6_OPTIONS_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_dhcpv6_options_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_dhcpv6_options_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_dhcpv6_options_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_dhcpv6_options_row_get_seqno(const struct sbrec_dhcpv6_options *row, enum ovsdb_idl_change change);
const struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_track_get_first(const struct ovsdb_idl *);
const struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_track_get_next(const struct sbrec_dhcpv6_options *);
#define SBREC_DHCPV6_OPTIONS_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_dhcpv6_options_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_dhcpv6_options_track_get_next(ROW))

const struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_table_track_get_first(const struct sbrec_dhcpv6_options_table *);
#define SBREC_DHCPV6_OPTIONS_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_dhcpv6_options_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_dhcpv6_options_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_dhcpv6_options_is_new(const struct sbrec_dhcpv6_options *row)
{
    return sbrec_dhcpv6_options_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_dhcpv6_options_is_deleted(const struct sbrec_dhcpv6_options *row)
{
    return sbrec_dhcpv6_options_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_dhcpv6_options_index_destroy_row(const struct sbrec_dhcpv6_options *);

struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_index_find(struct ovsdb_idl_index *, const struct sbrec_dhcpv6_options *);

int sbrec_dhcpv6_options_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_dhcpv6_options *, 
    const struct sbrec_dhcpv6_options *);
struct ovsdb_idl_cursor sbrec_dhcpv6_options_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_dhcpv6_options_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_dhcpv6_options *);
struct ovsdb_idl_cursor sbrec_dhcpv6_options_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_dhcpv6_options *);

struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_DHCPV6_OPTIONS_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dhcpv6_options_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_dhcpv6_options_cursor_data(&cursor__), \
                  !(TO) || sbrec_dhcpv6_options_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_DHCPV6_OPTIONS_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dhcpv6_options_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_dhcpv6_options_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_DHCPV6_OPTIONS_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dhcpv6_options_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_dhcpv6_options_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_dhcpv6_options_init(struct sbrec_dhcpv6_options *);
void sbrec_dhcpv6_options_delete(const struct sbrec_dhcpv6_options *);
struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_insert(struct ovsdb_idl_txn *);
bool sbrec_dhcpv6_options_is_updated(const struct sbrec_dhcpv6_options *, enum sbrec_dhcpv6_options_column_id);

void sbrec_dhcpv6_options_verify_code(const struct sbrec_dhcpv6_options *);
void sbrec_dhcpv6_options_verify_name(const struct sbrec_dhcpv6_options *);
void sbrec_dhcpv6_options_verify_type(const struct sbrec_dhcpv6_options *);

const struct ovsdb_datum *sbrec_dhcpv6_options_get_code(const struct sbrec_dhcpv6_options *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_dhcpv6_options_get_name(const struct sbrec_dhcpv6_options *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_dhcpv6_options_get_type(const struct sbrec_dhcpv6_options *, enum ovsdb_atomic_type key_type);

void sbrec_dhcpv6_options_set_code(const struct sbrec_dhcpv6_options *, int64_t code);
void sbrec_dhcpv6_options_set_name(const struct sbrec_dhcpv6_options *, const char *name);
void sbrec_dhcpv6_options_set_type(const struct sbrec_dhcpv6_options *, const char *type);

void sbrec_dhcpv6_options_add_clause_code(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t code);
void sbrec_dhcpv6_options_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_dhcpv6_options_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_dhcpv6_options_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_dhcpv6_options_add_clause_type(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *type);
void sbrec_dhcpv6_options_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_dhcpv6_options *sbrec_dhcpv6_options_index_init_row(struct ovsdb_idl_index *);
void sbrec_dhcpv6_options_index_set_code(const struct sbrec_dhcpv6_options *,
int64_t code);
void sbrec_dhcpv6_options_index_set_name(const struct sbrec_dhcpv6_options *,
const char *name);
void sbrec_dhcpv6_options_index_set_type(const struct sbrec_dhcpv6_options *,
const char *type);

/* DNS table. */
struct sbrec_dns {
    struct ovsdb_idl_row header_;

    /* datapaths column. */
    struct sbrec_datapath_binding **datapaths;
    size_t n_datapaths;

    /* external_ids column. */
    struct smap external_ids;

    /* records column. */
    struct smap records;
};

enum sbrec_dns_column_id {
    SBREC_DNS_COL_DATAPATHS,
    SBREC_DNS_COL_EXTERNAL_IDS,
    SBREC_DNS_COL_RECORDS,
    SBREC_DNS_N_COLUMNS
};

#define sbrec_dns_col_records (sbrec_dns_columns[SBREC_DNS_COL_RECORDS])
#define sbrec_dns_col_external_ids (sbrec_dns_columns[SBREC_DNS_COL_EXTERNAL_IDS])
#define sbrec_dns_col_datapaths (sbrec_dns_columns[SBREC_DNS_COL_DATAPATHS])

extern struct ovsdb_idl_column sbrec_dns_columns[SBREC_DNS_N_COLUMNS];

const struct sbrec_dns_table *sbrec_dns_table_get(const struct ovsdb_idl *);
const struct sbrec_dns *sbrec_dns_table_first(const struct sbrec_dns_table *);

#define SBREC_DNS_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_dns_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_dns_next(ROW))
#define SBREC_DNS_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_dns_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_dns_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_dns *sbrec_dns_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_dns *sbrec_dns_table_get_for_uuid(const struct sbrec_dns_table *, const struct uuid *);
const struct sbrec_dns *sbrec_dns_first(const struct ovsdb_idl *);
const struct sbrec_dns *sbrec_dns_next(const struct sbrec_dns *);
#define SBREC_DNS_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_dns_first(IDL); \
             (ROW); \
             (ROW) = sbrec_dns_next(ROW))
#define SBREC_DNS_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_dns_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_dns_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_dns_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_dns_row_get_seqno(const struct sbrec_dns *row, enum ovsdb_idl_change change);
const struct sbrec_dns *sbrec_dns_track_get_first(const struct ovsdb_idl *);
const struct sbrec_dns *sbrec_dns_track_get_next(const struct sbrec_dns *);
#define SBREC_DNS_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_dns_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_dns_track_get_next(ROW))

const struct sbrec_dns *sbrec_dns_table_track_get_first(const struct sbrec_dns_table *);
#define SBREC_DNS_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_dns_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_dns_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_dns_is_new(const struct sbrec_dns *row)
{
    return sbrec_dns_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_dns_is_deleted(const struct sbrec_dns *row)
{
    return sbrec_dns_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_dns_index_destroy_row(const struct sbrec_dns *);

struct sbrec_dns *sbrec_dns_index_find(struct ovsdb_idl_index *, const struct sbrec_dns *);

int sbrec_dns_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_dns *, 
    const struct sbrec_dns *);
struct ovsdb_idl_cursor sbrec_dns_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_dns_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_dns *);
struct ovsdb_idl_cursor sbrec_dns_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_dns *);

struct sbrec_dns *sbrec_dns_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_DNS_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dns_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_dns_cursor_data(&cursor__), \
                  !(TO) || sbrec_dns_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_DNS_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dns_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_dns_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_DNS_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_dns_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_dns_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_dns_init(struct sbrec_dns *);
void sbrec_dns_delete(const struct sbrec_dns *);
struct sbrec_dns *sbrec_dns_insert(struct ovsdb_idl_txn *);
bool sbrec_dns_is_updated(const struct sbrec_dns *, enum sbrec_dns_column_id);

void sbrec_dns_verify_datapaths(const struct sbrec_dns *);
void sbrec_dns_verify_external_ids(const struct sbrec_dns *);
void sbrec_dns_verify_records(const struct sbrec_dns *);

const struct ovsdb_datum *sbrec_dns_get_datapaths(const struct sbrec_dns *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_dns_get_external_ids(const struct sbrec_dns *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_dns_get_records(const struct sbrec_dns *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);

void sbrec_dns_set_datapaths(const struct sbrec_dns *, struct sbrec_datapath_binding **datapaths, size_t n_datapaths);
void sbrec_dns_set_external_ids(const struct sbrec_dns *, const struct smap *);
void sbrec_dns_set_records(const struct sbrec_dns *, const struct smap *);

void sbrec_dns_update_datapaths_addvalue(const struct sbrec_dns *,  const struct sbrec_datapath_binding *);
void sbrec_dns_update_datapaths_delvalue(const struct sbrec_dns *,  const struct sbrec_datapath_binding *);
void sbrec_dns_add_clause_datapaths(struct ovsdb_idl_condition *, enum ovsdb_function function, struct uuid **datapaths, size_t n_datapaths);
void sbrec_dns_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_dns_update_external_ids_setkey(const struct sbrec_dns *,  const char *, const char *);
void sbrec_dns_update_external_ids_delkey(const struct sbrec_dns *,  const char *);
void sbrec_dns_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_dns_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_dns_update_records_setkey(const struct sbrec_dns *,  const char *, const char *);
void sbrec_dns_update_records_delkey(const struct sbrec_dns *,  const char *);
void sbrec_dns_add_clause_records(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_dns_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_dns *sbrec_dns_index_init_row(struct ovsdb_idl_index *);
void sbrec_dns_index_set_datapaths(const struct sbrec_dns *,
struct sbrec_datapath_binding **datapaths, size_t n_datapaths);
void sbrec_dns_index_set_external_ids(const struct sbrec_dns *,
const struct smap *);
void sbrec_dns_index_set_records(const struct sbrec_dns *,
const struct smap *);

/* Datapath_Binding table. */
struct sbrec_datapath_binding {
    struct ovsdb_idl_row header_;

    /* external_ids column. */
    struct smap external_ids;

    /* tunnel_key column. */
    int64_t tunnel_key;
};

enum sbrec_datapath_binding_column_id {
    SBREC_DATAPATH_BINDING_COL_EXTERNAL_IDS,
    SBREC_DATAPATH_BINDING_COL_TUNNEL_KEY,
    SBREC_DATAPATH_BINDING_N_COLUMNS
};

#define sbrec_datapath_binding_col_tunnel_key (sbrec_datapath_binding_columns[SBREC_DATAPATH_BINDING_COL_TUNNEL_KEY])
#define sbrec_datapath_binding_col_external_ids (sbrec_datapath_binding_columns[SBREC_DATAPATH_BINDING_COL_EXTERNAL_IDS])

extern struct ovsdb_idl_column sbrec_datapath_binding_columns[SBREC_DATAPATH_BINDING_N_COLUMNS];

const struct sbrec_datapath_binding_table *sbrec_datapath_binding_table_get(const struct ovsdb_idl *);
const struct sbrec_datapath_binding *sbrec_datapath_binding_table_first(const struct sbrec_datapath_binding_table *);

#define SBREC_DATAPATH_BINDING_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_datapath_binding_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_datapath_binding_next(ROW))
#define SBREC_DATAPATH_BINDING_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_datapath_binding_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_datapath_binding_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_datapath_binding *sbrec_datapath_binding_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_datapath_binding *sbrec_datapath_binding_table_get_for_uuid(const struct sbrec_datapath_binding_table *, const struct uuid *);
const struct sbrec_datapath_binding *sbrec_datapath_binding_first(const struct ovsdb_idl *);
const struct sbrec_datapath_binding *sbrec_datapath_binding_next(const struct sbrec_datapath_binding *);
#define SBREC_DATAPATH_BINDING_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_datapath_binding_first(IDL); \
             (ROW); \
             (ROW) = sbrec_datapath_binding_next(ROW))
#define SBREC_DATAPATH_BINDING_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_datapath_binding_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_datapath_binding_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_datapath_binding_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_datapath_binding_row_get_seqno(const struct sbrec_datapath_binding *row, enum ovsdb_idl_change change);
const struct sbrec_datapath_binding *sbrec_datapath_binding_track_get_first(const struct ovsdb_idl *);
const struct sbrec_datapath_binding *sbrec_datapath_binding_track_get_next(const struct sbrec_datapath_binding *);
#define SBREC_DATAPATH_BINDING_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_datapath_binding_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_datapath_binding_track_get_next(ROW))

const struct sbrec_datapath_binding *sbrec_datapath_binding_table_track_get_first(const struct sbrec_datapath_binding_table *);
#define SBREC_DATAPATH_BINDING_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_datapath_binding_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_datapath_binding_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_datapath_binding_is_new(const struct sbrec_datapath_binding *row)
{
    return sbrec_datapath_binding_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_datapath_binding_is_deleted(const struct sbrec_datapath_binding *row)
{
    return sbrec_datapath_binding_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_datapath_binding_index_destroy_row(const struct sbrec_datapath_binding *);

struct sbrec_datapath_binding *sbrec_datapath_binding_index_find(struct ovsdb_idl_index *, const struct sbrec_datapath_binding *);

int sbrec_datapath_binding_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_datapath_binding *, 
    const struct sbrec_datapath_binding *);
struct ovsdb_idl_cursor sbrec_datapath_binding_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_datapath_binding_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_datapath_binding *);
struct ovsdb_idl_cursor sbrec_datapath_binding_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_datapath_binding *);

struct sbrec_datapath_binding *sbrec_datapath_binding_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_DATAPATH_BINDING_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_datapath_binding_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_datapath_binding_cursor_data(&cursor__), \
                  !(TO) || sbrec_datapath_binding_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_DATAPATH_BINDING_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_datapath_binding_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_datapath_binding_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_DATAPATH_BINDING_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_datapath_binding_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_datapath_binding_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_datapath_binding_init(struct sbrec_datapath_binding *);
void sbrec_datapath_binding_delete(const struct sbrec_datapath_binding *);
struct sbrec_datapath_binding *sbrec_datapath_binding_insert(struct ovsdb_idl_txn *);
bool sbrec_datapath_binding_is_updated(const struct sbrec_datapath_binding *, enum sbrec_datapath_binding_column_id);

void sbrec_datapath_binding_verify_external_ids(const struct sbrec_datapath_binding *);
void sbrec_datapath_binding_verify_tunnel_key(const struct sbrec_datapath_binding *);

const struct ovsdb_datum *sbrec_datapath_binding_get_external_ids(const struct sbrec_datapath_binding *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_datapath_binding_get_tunnel_key(const struct sbrec_datapath_binding *, enum ovsdb_atomic_type key_type);

void sbrec_datapath_binding_set_external_ids(const struct sbrec_datapath_binding *, const struct smap *);
void sbrec_datapath_binding_set_tunnel_key(const struct sbrec_datapath_binding *, int64_t tunnel_key);

void sbrec_datapath_binding_update_external_ids_setkey(const struct sbrec_datapath_binding *,  const char *, const char *);
void sbrec_datapath_binding_update_external_ids_delkey(const struct sbrec_datapath_binding *,  const char *);
void sbrec_datapath_binding_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_datapath_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_datapath_binding_add_clause_tunnel_key(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t tunnel_key);
void sbrec_datapath_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_datapath_binding *sbrec_datapath_binding_index_init_row(struct ovsdb_idl_index *);
void sbrec_datapath_binding_index_set_external_ids(const struct sbrec_datapath_binding *,
const struct smap *);
void sbrec_datapath_binding_index_set_tunnel_key(const struct sbrec_datapath_binding *,
int64_t tunnel_key);

/* Encap table. */
struct sbrec_encap {
    struct ovsdb_idl_row header_;

    /* chassis_name column. */
    char *chassis_name;    /* Always nonnull. */

    /* ip column. */
    char *ip;    /* Always nonnull. */

    /* options column. */
    struct smap options;

    /* type column. */
    char *type;    /* Always nonnull. */
};

enum sbrec_encap_column_id {
    SBREC_ENCAP_COL_CHASSIS_NAME,
    SBREC_ENCAP_COL_IP,
    SBREC_ENCAP_COL_OPTIONS,
    SBREC_ENCAP_COL_TYPE,
    SBREC_ENCAP_N_COLUMNS
};

#define sbrec_encap_col_ip (sbrec_encap_columns[SBREC_ENCAP_COL_IP])
#define sbrec_encap_col_chassis_name (sbrec_encap_columns[SBREC_ENCAP_COL_CHASSIS_NAME])
#define sbrec_encap_col_type (sbrec_encap_columns[SBREC_ENCAP_COL_TYPE])
#define sbrec_encap_col_options (sbrec_encap_columns[SBREC_ENCAP_COL_OPTIONS])

extern struct ovsdb_idl_column sbrec_encap_columns[SBREC_ENCAP_N_COLUMNS];

const struct sbrec_encap_table *sbrec_encap_table_get(const struct ovsdb_idl *);
const struct sbrec_encap *sbrec_encap_table_first(const struct sbrec_encap_table *);

#define SBREC_ENCAP_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_encap_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_encap_next(ROW))
#define SBREC_ENCAP_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_encap_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_encap_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_encap *sbrec_encap_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_encap *sbrec_encap_table_get_for_uuid(const struct sbrec_encap_table *, const struct uuid *);
const struct sbrec_encap *sbrec_encap_first(const struct ovsdb_idl *);
const struct sbrec_encap *sbrec_encap_next(const struct sbrec_encap *);
#define SBREC_ENCAP_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_encap_first(IDL); \
             (ROW); \
             (ROW) = sbrec_encap_next(ROW))
#define SBREC_ENCAP_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_encap_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_encap_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_encap_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_encap_row_get_seqno(const struct sbrec_encap *row, enum ovsdb_idl_change change);
const struct sbrec_encap *sbrec_encap_track_get_first(const struct ovsdb_idl *);
const struct sbrec_encap *sbrec_encap_track_get_next(const struct sbrec_encap *);
#define SBREC_ENCAP_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_encap_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_encap_track_get_next(ROW))

const struct sbrec_encap *sbrec_encap_table_track_get_first(const struct sbrec_encap_table *);
#define SBREC_ENCAP_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_encap_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_encap_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_encap_is_new(const struct sbrec_encap *row)
{
    return sbrec_encap_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_encap_is_deleted(const struct sbrec_encap *row)
{
    return sbrec_encap_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_encap_index_destroy_row(const struct sbrec_encap *);

struct sbrec_encap *sbrec_encap_index_find(struct ovsdb_idl_index *, const struct sbrec_encap *);

int sbrec_encap_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_encap *, 
    const struct sbrec_encap *);
struct ovsdb_idl_cursor sbrec_encap_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_encap_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_encap *);
struct ovsdb_idl_cursor sbrec_encap_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_encap *);

struct sbrec_encap *sbrec_encap_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_ENCAP_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_encap_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_encap_cursor_data(&cursor__), \
                  !(TO) || sbrec_encap_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_ENCAP_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_encap_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_encap_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_ENCAP_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_encap_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_encap_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_encap_init(struct sbrec_encap *);
void sbrec_encap_delete(const struct sbrec_encap *);
struct sbrec_encap *sbrec_encap_insert(struct ovsdb_idl_txn *);
bool sbrec_encap_is_updated(const struct sbrec_encap *, enum sbrec_encap_column_id);

void sbrec_encap_verify_chassis_name(const struct sbrec_encap *);
void sbrec_encap_verify_ip(const struct sbrec_encap *);
void sbrec_encap_verify_options(const struct sbrec_encap *);
void sbrec_encap_verify_type(const struct sbrec_encap *);

const struct ovsdb_datum *sbrec_encap_get_chassis_name(const struct sbrec_encap *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_encap_get_ip(const struct sbrec_encap *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_encap_get_options(const struct sbrec_encap *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_encap_get_type(const struct sbrec_encap *, enum ovsdb_atomic_type key_type);

void sbrec_encap_set_chassis_name(const struct sbrec_encap *, const char *chassis_name);
void sbrec_encap_set_ip(const struct sbrec_encap *, const char *ip);
void sbrec_encap_set_options(const struct sbrec_encap *, const struct smap *);
void sbrec_encap_set_type(const struct sbrec_encap *, const char *type);

void sbrec_encap_add_clause_chassis_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *chassis_name);
void sbrec_encap_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_encap_add_clause_ip(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *ip);
void sbrec_encap_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_encap_update_options_setkey(const struct sbrec_encap *,  const char *, const char *);
void sbrec_encap_update_options_delkey(const struct sbrec_encap *,  const char *);
void sbrec_encap_add_clause_options(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_encap_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_encap_add_clause_type(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *type);
void sbrec_encap_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_encap *sbrec_encap_index_init_row(struct ovsdb_idl_index *);
void sbrec_encap_index_set_chassis_name(const struct sbrec_encap *,
const char *chassis_name);
void sbrec_encap_index_set_ip(const struct sbrec_encap *,
const char *ip);
void sbrec_encap_index_set_options(const struct sbrec_encap *,
const struct smap *);
void sbrec_encap_index_set_type(const struct sbrec_encap *,
const char *type);

/* Gateway_Chassis table. */
struct sbrec_gateway_chassis {
    struct ovsdb_idl_row header_;

    /* chassis column. */
    struct sbrec_chassis *chassis;

    /* external_ids column. */
    struct smap external_ids;

    /* name column. */
    char *name;    /* Always nonnull. */

    /* options column. */
    struct smap options;

    /* priority column. */
    int64_t priority;
};

enum sbrec_gateway_chassis_column_id {
    SBREC_GATEWAY_CHASSIS_COL_CHASSIS,
    SBREC_GATEWAY_CHASSIS_COL_EXTERNAL_IDS,
    SBREC_GATEWAY_CHASSIS_COL_NAME,
    SBREC_GATEWAY_CHASSIS_COL_OPTIONS,
    SBREC_GATEWAY_CHASSIS_COL_PRIORITY,
    SBREC_GATEWAY_CHASSIS_N_COLUMNS
};

#define sbrec_gateway_chassis_col_priority (sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_COL_PRIORITY])
#define sbrec_gateway_chassis_col_external_ids (sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_COL_EXTERNAL_IDS])
#define sbrec_gateway_chassis_col_chassis (sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_COL_CHASSIS])
#define sbrec_gateway_chassis_col_name (sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_COL_NAME])
#define sbrec_gateway_chassis_col_options (sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_COL_OPTIONS])

extern struct ovsdb_idl_column sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_N_COLUMNS];

const struct sbrec_gateway_chassis_table *sbrec_gateway_chassis_table_get(const struct ovsdb_idl *);
const struct sbrec_gateway_chassis *sbrec_gateway_chassis_table_first(const struct sbrec_gateway_chassis_table *);

#define SBREC_GATEWAY_CHASSIS_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_gateway_chassis_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_gateway_chassis_next(ROW))
#define SBREC_GATEWAY_CHASSIS_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_gateway_chassis_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_gateway_chassis_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_gateway_chassis *sbrec_gateway_chassis_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_gateway_chassis *sbrec_gateway_chassis_table_get_for_uuid(const struct sbrec_gateway_chassis_table *, const struct uuid *);
const struct sbrec_gateway_chassis *sbrec_gateway_chassis_first(const struct ovsdb_idl *);
const struct sbrec_gateway_chassis *sbrec_gateway_chassis_next(const struct sbrec_gateway_chassis *);
#define SBREC_GATEWAY_CHASSIS_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_gateway_chassis_first(IDL); \
             (ROW); \
             (ROW) = sbrec_gateway_chassis_next(ROW))
#define SBREC_GATEWAY_CHASSIS_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_gateway_chassis_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_gateway_chassis_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_gateway_chassis_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_gateway_chassis_row_get_seqno(const struct sbrec_gateway_chassis *row, enum ovsdb_idl_change change);
const struct sbrec_gateway_chassis *sbrec_gateway_chassis_track_get_first(const struct ovsdb_idl *);
const struct sbrec_gateway_chassis *sbrec_gateway_chassis_track_get_next(const struct sbrec_gateway_chassis *);
#define SBREC_GATEWAY_CHASSIS_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_gateway_chassis_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_gateway_chassis_track_get_next(ROW))

const struct sbrec_gateway_chassis *sbrec_gateway_chassis_table_track_get_first(const struct sbrec_gateway_chassis_table *);
#define SBREC_GATEWAY_CHASSIS_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_gateway_chassis_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_gateway_chassis_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_gateway_chassis_is_new(const struct sbrec_gateway_chassis *row)
{
    return sbrec_gateway_chassis_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_gateway_chassis_is_deleted(const struct sbrec_gateway_chassis *row)
{
    return sbrec_gateway_chassis_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_gateway_chassis_index_destroy_row(const struct sbrec_gateway_chassis *);

struct sbrec_gateway_chassis *sbrec_gateway_chassis_index_find(struct ovsdb_idl_index *, const struct sbrec_gateway_chassis *);

int sbrec_gateway_chassis_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_gateway_chassis *, 
    const struct sbrec_gateway_chassis *);
struct ovsdb_idl_cursor sbrec_gateway_chassis_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_gateway_chassis_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_gateway_chassis *);
struct ovsdb_idl_cursor sbrec_gateway_chassis_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_gateway_chassis *);

struct sbrec_gateway_chassis *sbrec_gateway_chassis_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_GATEWAY_CHASSIS_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_gateway_chassis_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_gateway_chassis_cursor_data(&cursor__), \
                  !(TO) || sbrec_gateway_chassis_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_GATEWAY_CHASSIS_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_gateway_chassis_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_gateway_chassis_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_GATEWAY_CHASSIS_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_gateway_chassis_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_gateway_chassis_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_gateway_chassis_init(struct sbrec_gateway_chassis *);
void sbrec_gateway_chassis_delete(const struct sbrec_gateway_chassis *);
struct sbrec_gateway_chassis *sbrec_gateway_chassis_insert(struct ovsdb_idl_txn *);
bool sbrec_gateway_chassis_is_updated(const struct sbrec_gateway_chassis *, enum sbrec_gateway_chassis_column_id);

void sbrec_gateway_chassis_verify_chassis(const struct sbrec_gateway_chassis *);
void sbrec_gateway_chassis_verify_external_ids(const struct sbrec_gateway_chassis *);
void sbrec_gateway_chassis_verify_name(const struct sbrec_gateway_chassis *);
void sbrec_gateway_chassis_verify_options(const struct sbrec_gateway_chassis *);
void sbrec_gateway_chassis_verify_priority(const struct sbrec_gateway_chassis *);

const struct ovsdb_datum *sbrec_gateway_chassis_get_chassis(const struct sbrec_gateway_chassis *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_gateway_chassis_get_external_ids(const struct sbrec_gateway_chassis *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_gateway_chassis_get_name(const struct sbrec_gateway_chassis *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_gateway_chassis_get_options(const struct sbrec_gateway_chassis *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_gateway_chassis_get_priority(const struct sbrec_gateway_chassis *, enum ovsdb_atomic_type key_type);

void sbrec_gateway_chassis_set_chassis(const struct sbrec_gateway_chassis *, const struct sbrec_chassis *chassis);
void sbrec_gateway_chassis_set_external_ids(const struct sbrec_gateway_chassis *, const struct smap *);
void sbrec_gateway_chassis_set_name(const struct sbrec_gateway_chassis *, const char *name);
void sbrec_gateway_chassis_set_options(const struct sbrec_gateway_chassis *, const struct smap *);
void sbrec_gateway_chassis_set_priority(const struct sbrec_gateway_chassis *, int64_t priority);

void sbrec_gateway_chassis_update_chassis_addvalue(const struct sbrec_gateway_chassis *,  const struct sbrec_chassis *);
void sbrec_gateway_chassis_update_chassis_delvalue(const struct sbrec_gateway_chassis *,  const struct sbrec_chassis *);
void sbrec_gateway_chassis_add_clause_chassis(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct uuid *chassis);
void sbrec_gateway_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_gateway_chassis_update_external_ids_setkey(const struct sbrec_gateway_chassis *,  const char *, const char *);
void sbrec_gateway_chassis_update_external_ids_delkey(const struct sbrec_gateway_chassis *,  const char *);
void sbrec_gateway_chassis_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_gateway_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_gateway_chassis_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_gateway_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_gateway_chassis_update_options_setkey(const struct sbrec_gateway_chassis *,  const char *, const char *);
void sbrec_gateway_chassis_update_options_delkey(const struct sbrec_gateway_chassis *,  const char *);
void sbrec_gateway_chassis_add_clause_options(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_gateway_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_gateway_chassis_add_clause_priority(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t priority);
void sbrec_gateway_chassis_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_gateway_chassis *sbrec_gateway_chassis_index_init_row(struct ovsdb_idl_index *);
void sbrec_gateway_chassis_index_set_chassis(const struct sbrec_gateway_chassis *,
const struct sbrec_chassis *chassis);
void sbrec_gateway_chassis_index_set_external_ids(const struct sbrec_gateway_chassis *,
const struct smap *);
void sbrec_gateway_chassis_index_set_name(const struct sbrec_gateway_chassis *,
const char *name);
void sbrec_gateway_chassis_index_set_options(const struct sbrec_gateway_chassis *,
const struct smap *);
void sbrec_gateway_chassis_index_set_priority(const struct sbrec_gateway_chassis *,
int64_t priority);

/* Logical_Flow table. */
struct sbrec_logical_flow {
    struct ovsdb_idl_row header_;

    /* actions column. */
    char *actions;    /* Always nonnull. */

    /* external_ids column. */
    struct smap external_ids;

    /* logical_datapath column. */
    struct nbrec_sb_datapath_binding *logical_datapath; //Salam

    /* match column. */
    char *match;    /* Always nonnull. */

    /* pipeline column. */
    char *pipeline;    /* Always nonnull. */

    /* priority column. */
    int64_t priority;

    /* table_id column. */
    int64_t table_id;

    /* hash column. */
    int64_t hash;
};

enum sbrec_logical_flow_column_id {
    SBREC_LOGICAL_FLOW_COL_ACTIONS,
    SBREC_LOGICAL_FLOW_COL_EXTERNAL_IDS,
    SBREC_LOGICAL_FLOW_COL_LOGICAL_DATAPATH,
    SBREC_LOGICAL_FLOW_COL_MATCH,
    SBREC_LOGICAL_FLOW_COL_PIPELINE,
    SBREC_LOGICAL_FLOW_COL_PRIORITY,
    SBREC_LOGICAL_FLOW_COL_TABLE_ID,
    SBREC_LOGICAL_FLOW_COL_HASH,
    SBREC_LOGICAL_FLOW_N_COLUMNS
};

#define sbrec_logical_flow_col_logical_datapath (sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_LOGICAL_DATAPATH])
#define sbrec_logical_flow_col_pipeline (sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_PIPELINE])
#define sbrec_logical_flow_col_hash (sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_HASH])
#define sbrec_logical_flow_col_actions (sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_ACTIONS])
#define sbrec_logical_flow_col_priority (sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_PRIORITY])
#define sbrec_logical_flow_col_table_id (sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_TABLE_ID])
#define sbrec_logical_flow_col_external_ids (sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_EXTERNAL_IDS])
#define sbrec_logical_flow_col_match (sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_MATCH])

extern struct ovsdb_idl_column sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_N_COLUMNS];

const struct sbrec_logical_flow_table *sbrec_logical_flow_table_get(const struct ovsdb_idl *);
const struct sbrec_logical_flow *sbrec_logical_flow_table_first(const struct sbrec_logical_flow_table *);

#define SBREC_LOGICAL_FLOW_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_logical_flow_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_logical_flow_next(ROW))
#define SBREC_LOGICAL_FLOW_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_logical_flow_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_logical_flow_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_logical_flow *sbrec_logical_flow_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_logical_flow *sbrec_logical_flow_table_get_for_uuid(const struct sbrec_logical_flow_table *, const struct uuid *);
const struct sbrec_logical_flow *sbrec_logical_flow_first(const struct ovsdb_idl *);
const struct sbrec_logical_flow *sbrec_logical_flow_next(const struct sbrec_logical_flow *);
#define SBREC_LOGICAL_FLOW_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_logical_flow_first(IDL); \
             (ROW); \
             (ROW) = sbrec_logical_flow_next(ROW))
#define SBREC_LOGICAL_FLOW_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_logical_flow_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_logical_flow_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_logical_flow_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_logical_flow_row_get_seqno(const struct sbrec_logical_flow *row, enum ovsdb_idl_change change);
const struct sbrec_logical_flow *sbrec_logical_flow_track_get_first(const struct ovsdb_idl *);
const struct sbrec_logical_flow *sbrec_logical_flow_track_get_next(const struct sbrec_logical_flow *);
#define SBREC_LOGICAL_FLOW_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_logical_flow_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_logical_flow_track_get_next(ROW))

const struct sbrec_logical_flow *sbrec_logical_flow_table_track_get_first(const struct sbrec_logical_flow_table *);
#define SBREC_LOGICAL_FLOW_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_logical_flow_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_logical_flow_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_logical_flow_is_new(const struct sbrec_logical_flow *row)
{
    return sbrec_logical_flow_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_logical_flow_is_deleted(const struct sbrec_logical_flow *row)
{
    return sbrec_logical_flow_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_logical_flow_index_destroy_row(const struct sbrec_logical_flow *);

struct sbrec_logical_flow *sbrec_logical_flow_index_find(struct ovsdb_idl_index *, const struct sbrec_logical_flow *);

int sbrec_logical_flow_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_logical_flow *, 
    const struct sbrec_logical_flow *);
struct ovsdb_idl_cursor sbrec_logical_flow_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_logical_flow_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_logical_flow *);
struct ovsdb_idl_cursor sbrec_logical_flow_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_logical_flow *);

struct sbrec_logical_flow *sbrec_logical_flow_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_LOGICAL_FLOW_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_logical_flow_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_logical_flow_cursor_data(&cursor__), \
                  !(TO) || sbrec_logical_flow_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_LOGICAL_FLOW_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_logical_flow_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_logical_flow_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_LOGICAL_FLOW_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_logical_flow_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_logical_flow_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_logical_flow_init(struct sbrec_logical_flow *);
void sbrec_logical_flow_delete(const struct sbrec_logical_flow *);
struct sbrec_logical_flow *sbrec_logical_flow_insert(struct ovsdb_idl_txn *);
bool sbrec_logical_flow_is_updated(const struct sbrec_logical_flow *, enum sbrec_logical_flow_column_id);

void sbrec_logical_flow_verify_actions(const struct sbrec_logical_flow *);
void sbrec_logical_flow_verify_external_ids(const struct sbrec_logical_flow *);
void sbrec_logical_flow_verify_logical_datapath(const struct sbrec_logical_flow *);
void sbrec_logical_flow_verify_match(const struct sbrec_logical_flow *);
void sbrec_logical_flow_verify_pipeline(const struct sbrec_logical_flow *);
void sbrec_logical_flow_verify_priority(const struct sbrec_logical_flow *);
void sbrec_logical_flow_verify_table_id(const struct sbrec_logical_flow *);

const struct ovsdb_datum *sbrec_logical_flow_get_actions(const struct sbrec_logical_flow *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_logical_flow_get_external_ids(const struct sbrec_logical_flow *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_logical_flow_get_logical_datapath(const struct sbrec_logical_flow *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_logical_flow_get_match(const struct sbrec_logical_flow *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_logical_flow_get_pipeline(const struct sbrec_logical_flow *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_logical_flow_get_priority(const struct sbrec_logical_flow *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_logical_flow_get_table_id(const struct sbrec_logical_flow *, enum ovsdb_atomic_type key_type);

void sbrec_logical_flow_set_actions(const struct sbrec_logical_flow *, const char *actions);
void sbrec_logical_flow_set_external_ids(const struct sbrec_logical_flow *, const struct smap *);
void sbrec_logical_flow_set_logical_datapath(const struct sbrec_logical_flow *, const struct nbrec_sb_datapath_binding *logical_datapath); //Salam
void sbrec_logical_flow_set_match(const struct sbrec_logical_flow *, const char *match);
void sbrec_logical_flow_set_pipeline(const struct sbrec_logical_flow *, const char *pipeline);
void sbrec_logical_flow_set_priority(const struct sbrec_logical_flow *, int64_t priority);
void sbrec_logical_flow_set_table_id(const struct sbrec_logical_flow *, int64_t table_id);

void sbrec_logical_flow_add_clause_actions(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *actions);
void sbrec_logical_flow_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_logical_flow_update_external_ids_setkey(const struct sbrec_logical_flow *,  const char *, const char *);
void sbrec_logical_flow_update_external_ids_delkey(const struct sbrec_logical_flow *,  const char *);
void sbrec_logical_flow_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_logical_flow_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_logical_flow_add_clause_logical_datapath(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct uuid *logical_datapath);
void sbrec_logical_flow_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_logical_flow_add_clause_match(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *match);
void sbrec_logical_flow_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_logical_flow_add_clause_pipeline(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *pipeline);
void sbrec_logical_flow_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_logical_flow_add_clause_priority(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t priority);
void sbrec_logical_flow_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_logical_flow_add_clause_table_id(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t table_id);
void sbrec_logical_flow_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_logical_flow *sbrec_logical_flow_index_init_row(struct ovsdb_idl_index *);
void sbrec_logical_flow_index_set_actions(const struct sbrec_logical_flow *,
const char *actions);
void sbrec_logical_flow_index_set_external_ids(const struct sbrec_logical_flow *,
const struct smap *);
void sbrec_logical_flow_index_set_hash(const struct sbrec_logical_flow *,
int64_t hash);
void sbrec_logical_flow_index_set_logical_datapath(const struct sbrec_logical_flow *,
const struct nbrec_sb_datapath_binding *logical_datapath); //Salam
void sbrec_logical_flow_index_set_match(const struct sbrec_logical_flow *,
const char *match);
void sbrec_logical_flow_index_set_pipeline(const struct sbrec_logical_flow *,
const char *pipeline);
void sbrec_logical_flow_index_set_priority(const struct sbrec_logical_flow *,
int64_t priority);
void sbrec_logical_flow_index_set_table_id(const struct sbrec_logical_flow *,
int64_t table_id);

/* MAC_Binding table. */
struct sbrec_mac_binding {
    struct ovsdb_idl_row header_;

    /* datapath column. */
    struct sbrec_datapath_binding *datapath;

    /* ip column. */
    char *ip;    /* Always nonnull. */

    /* logical_port column. */
    char *logical_port;    /* Always nonnull. */

    /* mac column. */
    char *mac;    /* Always nonnull. */
};

enum sbrec_mac_binding_column_id {
    SBREC_MAC_BINDING_COL_DATAPATH,
    SBREC_MAC_BINDING_COL_IP,
    SBREC_MAC_BINDING_COL_LOGICAL_PORT,
    SBREC_MAC_BINDING_COL_MAC,
    SBREC_MAC_BINDING_N_COLUMNS
};

#define sbrec_mac_binding_col_ip (sbrec_mac_binding_columns[SBREC_MAC_BINDING_COL_IP])
#define sbrec_mac_binding_col_mac (sbrec_mac_binding_columns[SBREC_MAC_BINDING_COL_MAC])
#define sbrec_mac_binding_col_datapath (sbrec_mac_binding_columns[SBREC_MAC_BINDING_COL_DATAPATH])
#define sbrec_mac_binding_col_logical_port (sbrec_mac_binding_columns[SBREC_MAC_BINDING_COL_LOGICAL_PORT])

extern struct ovsdb_idl_column sbrec_mac_binding_columns[SBREC_MAC_BINDING_N_COLUMNS];

const struct sbrec_mac_binding_table *sbrec_mac_binding_table_get(const struct ovsdb_idl *);
const struct sbrec_mac_binding *sbrec_mac_binding_table_first(const struct sbrec_mac_binding_table *);

#define SBREC_MAC_BINDING_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_mac_binding_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_mac_binding_next(ROW))
#define SBREC_MAC_BINDING_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_mac_binding_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_mac_binding_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_mac_binding *sbrec_mac_binding_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_mac_binding *sbrec_mac_binding_table_get_for_uuid(const struct sbrec_mac_binding_table *, const struct uuid *);
const struct sbrec_mac_binding *sbrec_mac_binding_first(const struct ovsdb_idl *);
const struct sbrec_mac_binding *sbrec_mac_binding_next(const struct sbrec_mac_binding *);
#define SBREC_MAC_BINDING_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_mac_binding_first(IDL); \
             (ROW); \
             (ROW) = sbrec_mac_binding_next(ROW))
#define SBREC_MAC_BINDING_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_mac_binding_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_mac_binding_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_mac_binding_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_mac_binding_row_get_seqno(const struct sbrec_mac_binding *row, enum ovsdb_idl_change change);
const struct sbrec_mac_binding *sbrec_mac_binding_track_get_first(const struct ovsdb_idl *);
const struct sbrec_mac_binding *sbrec_mac_binding_track_get_next(const struct sbrec_mac_binding *);
#define SBREC_MAC_BINDING_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_mac_binding_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_mac_binding_track_get_next(ROW))

const struct sbrec_mac_binding *sbrec_mac_binding_table_track_get_first(const struct sbrec_mac_binding_table *);
#define SBREC_MAC_BINDING_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_mac_binding_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_mac_binding_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_mac_binding_is_new(const struct sbrec_mac_binding *row)
{
    return sbrec_mac_binding_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_mac_binding_is_deleted(const struct sbrec_mac_binding *row)
{
    return sbrec_mac_binding_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_mac_binding_index_destroy_row(const struct sbrec_mac_binding *);

struct sbrec_mac_binding *sbrec_mac_binding_index_find(struct ovsdb_idl_index *, const struct sbrec_mac_binding *);

int sbrec_mac_binding_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_mac_binding *, 
    const struct sbrec_mac_binding *);
struct ovsdb_idl_cursor sbrec_mac_binding_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_mac_binding_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_mac_binding *);
struct ovsdb_idl_cursor sbrec_mac_binding_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_mac_binding *);

struct sbrec_mac_binding *sbrec_mac_binding_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_MAC_BINDING_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_mac_binding_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_mac_binding_cursor_data(&cursor__), \
                  !(TO) || sbrec_mac_binding_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_MAC_BINDING_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_mac_binding_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_mac_binding_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_MAC_BINDING_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_mac_binding_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_mac_binding_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_mac_binding_init(struct sbrec_mac_binding *);
void sbrec_mac_binding_delete(const struct sbrec_mac_binding *);
struct sbrec_mac_binding *sbrec_mac_binding_insert(struct ovsdb_idl_txn *);
bool sbrec_mac_binding_is_updated(const struct sbrec_mac_binding *, enum sbrec_mac_binding_column_id);

void sbrec_mac_binding_verify_datapath(const struct sbrec_mac_binding *);
void sbrec_mac_binding_verify_ip(const struct sbrec_mac_binding *);
void sbrec_mac_binding_verify_logical_port(const struct sbrec_mac_binding *);
void sbrec_mac_binding_verify_mac(const struct sbrec_mac_binding *);

const struct ovsdb_datum *sbrec_mac_binding_get_datapath(const struct sbrec_mac_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_mac_binding_get_ip(const struct sbrec_mac_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_mac_binding_get_logical_port(const struct sbrec_mac_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_mac_binding_get_mac(const struct sbrec_mac_binding *, enum ovsdb_atomic_type key_type);

void sbrec_mac_binding_set_datapath(const struct sbrec_mac_binding *, const struct sbrec_datapath_binding *datapath);
void sbrec_mac_binding_set_ip(const struct sbrec_mac_binding *, const char *ip);
void sbrec_mac_binding_set_logical_port(const struct sbrec_mac_binding *, const char *logical_port);
void sbrec_mac_binding_set_mac(const struct sbrec_mac_binding *, const char *mac);

void sbrec_mac_binding_add_clause_datapath(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct uuid *datapath);
void sbrec_mac_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_mac_binding_add_clause_ip(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *ip);
void sbrec_mac_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_mac_binding_add_clause_logical_port(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *logical_port);
void sbrec_mac_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_mac_binding_add_clause_mac(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *mac);
void sbrec_mac_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_mac_binding *sbrec_mac_binding_index_init_row(struct ovsdb_idl_index *);
void sbrec_mac_binding_index_set_datapath(const struct sbrec_mac_binding *,
const struct sbrec_datapath_binding *datapath);
void sbrec_mac_binding_index_set_ip(const struct sbrec_mac_binding *,
const char *ip);
void sbrec_mac_binding_index_set_logical_port(const struct sbrec_mac_binding *,
const char *logical_port);
void sbrec_mac_binding_index_set_mac(const struct sbrec_mac_binding *,
const char *mac);

/* Meter table. */
struct sbrec_meter {
    struct ovsdb_idl_row header_;

    /* bands column. */
    struct sbrec_meter_band **bands;
    size_t n_bands;

    /* name column. */
    char *name;    /* Always nonnull. */

    /* unit column. */
    char *unit;    /* Always nonnull. */
};

enum sbrec_meter_column_id {
    SBREC_METER_COL_BANDS,
    SBREC_METER_COL_NAME,
    SBREC_METER_COL_UNIT,
    SBREC_METER_N_COLUMNS
};

#define sbrec_meter_col_bands (sbrec_meter_columns[SBREC_METER_COL_BANDS])
#define sbrec_meter_col_name (sbrec_meter_columns[SBREC_METER_COL_NAME])
#define sbrec_meter_col_unit (sbrec_meter_columns[SBREC_METER_COL_UNIT])

extern struct ovsdb_idl_column sbrec_meter_columns[SBREC_METER_N_COLUMNS];

const struct sbrec_meter_table *sbrec_meter_table_get(const struct ovsdb_idl *);
const struct sbrec_meter *sbrec_meter_table_first(const struct sbrec_meter_table *);

#define SBREC_METER_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_meter_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_meter_next(ROW))
#define SBREC_METER_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_meter_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_meter_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_meter *sbrec_meter_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_meter *sbrec_meter_table_get_for_uuid(const struct sbrec_meter_table *, const struct uuid *);
const struct sbrec_meter *sbrec_meter_first(const struct ovsdb_idl *);
const struct sbrec_meter *sbrec_meter_next(const struct sbrec_meter *);
#define SBREC_METER_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_meter_first(IDL); \
             (ROW); \
             (ROW) = sbrec_meter_next(ROW))
#define SBREC_METER_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_meter_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_meter_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_meter_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_meter_row_get_seqno(const struct sbrec_meter *row, enum ovsdb_idl_change change);
const struct sbrec_meter *sbrec_meter_track_get_first(const struct ovsdb_idl *);
const struct sbrec_meter *sbrec_meter_track_get_next(const struct sbrec_meter *);
#define SBREC_METER_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_meter_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_meter_track_get_next(ROW))

const struct sbrec_meter *sbrec_meter_table_track_get_first(const struct sbrec_meter_table *);
#define SBREC_METER_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_meter_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_meter_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_meter_is_new(const struct sbrec_meter *row)
{
    return sbrec_meter_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_meter_is_deleted(const struct sbrec_meter *row)
{
    return sbrec_meter_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_meter_index_destroy_row(const struct sbrec_meter *);

struct sbrec_meter *sbrec_meter_index_find(struct ovsdb_idl_index *, const struct sbrec_meter *);

int sbrec_meter_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_meter *, 
    const struct sbrec_meter *);
struct ovsdb_idl_cursor sbrec_meter_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_meter_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_meter *);
struct ovsdb_idl_cursor sbrec_meter_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_meter *);

struct sbrec_meter *sbrec_meter_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_METER_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_meter_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_meter_cursor_data(&cursor__), \
                  !(TO) || sbrec_meter_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_METER_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_meter_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_meter_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_METER_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_meter_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_meter_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_meter_init(struct sbrec_meter *);
void sbrec_meter_delete(const struct sbrec_meter *);
struct sbrec_meter *sbrec_meter_insert(struct ovsdb_idl_txn *);
bool sbrec_meter_is_updated(const struct sbrec_meter *, enum sbrec_meter_column_id);

void sbrec_meter_verify_bands(const struct sbrec_meter *);
void sbrec_meter_verify_name(const struct sbrec_meter *);
void sbrec_meter_verify_unit(const struct sbrec_meter *);

const struct ovsdb_datum *sbrec_meter_get_bands(const struct sbrec_meter *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_meter_get_name(const struct sbrec_meter *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_meter_get_unit(const struct sbrec_meter *, enum ovsdb_atomic_type key_type);

void sbrec_meter_set_bands(const struct sbrec_meter *, struct sbrec_meter_band **bands, size_t n_bands);
void sbrec_meter_set_name(const struct sbrec_meter *, const char *name);
void sbrec_meter_set_unit(const struct sbrec_meter *, const char *unit);

void sbrec_meter_update_bands_addvalue(const struct sbrec_meter *,  const struct sbrec_meter_band *);
void sbrec_meter_update_bands_delvalue(const struct sbrec_meter *,  const struct sbrec_meter_band *);
void sbrec_meter_add_clause_bands(struct ovsdb_idl_condition *, enum ovsdb_function function, struct uuid **bands, size_t n_bands);
void sbrec_meter_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_meter_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_meter_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_meter_add_clause_unit(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *unit);
void sbrec_meter_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_meter *sbrec_meter_index_init_row(struct ovsdb_idl_index *);
void sbrec_meter_index_set_bands(const struct sbrec_meter *,
struct sbrec_meter_band **bands, size_t n_bands);
void sbrec_meter_index_set_name(const struct sbrec_meter *,
const char *name);
void sbrec_meter_index_set_unit(const struct sbrec_meter *,
const char *unit);

/* Meter_Band table. */
struct sbrec_meter_band {
    struct ovsdb_idl_row header_;

    /* action column. */
    char *action;    /* Always nonnull. */

    /* burst_size column. */
    int64_t burst_size;

    /* rate column. */
    int64_t rate;
};

enum sbrec_meter_band_column_id {
    SBREC_METER_BAND_COL_ACTION,
    SBREC_METER_BAND_COL_BURST_SIZE,
    SBREC_METER_BAND_COL_RATE,
    SBREC_METER_BAND_N_COLUMNS
};

#define sbrec_meter_band_col_action (sbrec_meter_band_columns[SBREC_METER_BAND_COL_ACTION])
#define sbrec_meter_band_col_rate (sbrec_meter_band_columns[SBREC_METER_BAND_COL_RATE])
#define sbrec_meter_band_col_burst_size (sbrec_meter_band_columns[SBREC_METER_BAND_COL_BURST_SIZE])

extern struct ovsdb_idl_column sbrec_meter_band_columns[SBREC_METER_BAND_N_COLUMNS];

const struct sbrec_meter_band_table *sbrec_meter_band_table_get(const struct ovsdb_idl *);
const struct sbrec_meter_band *sbrec_meter_band_table_first(const struct sbrec_meter_band_table *);

#define SBREC_METER_BAND_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_meter_band_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_meter_band_next(ROW))
#define SBREC_METER_BAND_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_meter_band_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_meter_band_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_meter_band *sbrec_meter_band_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_meter_band *sbrec_meter_band_table_get_for_uuid(const struct sbrec_meter_band_table *, const struct uuid *);
const struct sbrec_meter_band *sbrec_meter_band_first(const struct ovsdb_idl *);
const struct sbrec_meter_band *sbrec_meter_band_next(const struct sbrec_meter_band *);
#define SBREC_METER_BAND_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_meter_band_first(IDL); \
             (ROW); \
             (ROW) = sbrec_meter_band_next(ROW))
#define SBREC_METER_BAND_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_meter_band_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_meter_band_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_meter_band_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_meter_band_row_get_seqno(const struct sbrec_meter_band *row, enum ovsdb_idl_change change);
const struct sbrec_meter_band *sbrec_meter_band_track_get_first(const struct ovsdb_idl *);
const struct sbrec_meter_band *sbrec_meter_band_track_get_next(const struct sbrec_meter_band *);
#define SBREC_METER_BAND_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_meter_band_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_meter_band_track_get_next(ROW))

const struct sbrec_meter_band *sbrec_meter_band_table_track_get_first(const struct sbrec_meter_band_table *);
#define SBREC_METER_BAND_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_meter_band_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_meter_band_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_meter_band_is_new(const struct sbrec_meter_band *row)
{
    return sbrec_meter_band_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_meter_band_is_deleted(const struct sbrec_meter_band *row)
{
    return sbrec_meter_band_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_meter_band_index_destroy_row(const struct sbrec_meter_band *);

struct sbrec_meter_band *sbrec_meter_band_index_find(struct ovsdb_idl_index *, const struct sbrec_meter_band *);

int sbrec_meter_band_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_meter_band *, 
    const struct sbrec_meter_band *);
struct ovsdb_idl_cursor sbrec_meter_band_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_meter_band_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_meter_band *);
struct ovsdb_idl_cursor sbrec_meter_band_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_meter_band *);

struct sbrec_meter_band *sbrec_meter_band_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_METER_BAND_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_meter_band_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_meter_band_cursor_data(&cursor__), \
                  !(TO) || sbrec_meter_band_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_METER_BAND_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_meter_band_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_meter_band_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_METER_BAND_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_meter_band_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_meter_band_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_meter_band_init(struct sbrec_meter_band *);
void sbrec_meter_band_delete(const struct sbrec_meter_band *);
struct sbrec_meter_band *sbrec_meter_band_insert(struct ovsdb_idl_txn *);
bool sbrec_meter_band_is_updated(const struct sbrec_meter_band *, enum sbrec_meter_band_column_id);

void sbrec_meter_band_verify_action(const struct sbrec_meter_band *);
void sbrec_meter_band_verify_burst_size(const struct sbrec_meter_band *);
void sbrec_meter_band_verify_rate(const struct sbrec_meter_band *);

const struct ovsdb_datum *sbrec_meter_band_get_action(const struct sbrec_meter_band *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_meter_band_get_burst_size(const struct sbrec_meter_band *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_meter_band_get_rate(const struct sbrec_meter_band *, enum ovsdb_atomic_type key_type);

void sbrec_meter_band_set_action(const struct sbrec_meter_band *, const char *action);
void sbrec_meter_band_set_burst_size(const struct sbrec_meter_band *, int64_t burst_size);
void sbrec_meter_band_set_rate(const struct sbrec_meter_band *, int64_t rate);

void sbrec_meter_band_add_clause_action(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *action);
void sbrec_meter_band_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_meter_band_add_clause_burst_size(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t burst_size);
void sbrec_meter_band_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_meter_band_add_clause_rate(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t rate);
void sbrec_meter_band_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_meter_band *sbrec_meter_band_index_init_row(struct ovsdb_idl_index *);
void sbrec_meter_band_index_set_action(const struct sbrec_meter_band *,
const char *action);
void sbrec_meter_band_index_set_burst_size(const struct sbrec_meter_band *,
int64_t burst_size);
void sbrec_meter_band_index_set_rate(const struct sbrec_meter_band *,
int64_t rate);

/* Multicast_Group table. */
struct sbrec_multicast_group {
    struct ovsdb_idl_row header_;

    /* datapath column. */
    struct sbrec_datapath_binding *datapath;

    /* name column. */
    char *name;    /* Always nonnull. */

    /* ports column. */
    struct sbrec_port_binding **ports;
    size_t n_ports;

    /* tunnel_key column. */
    int64_t tunnel_key;
};

enum sbrec_multicast_group_column_id {
    SBREC_MULTICAST_GROUP_COL_DATAPATH,
    SBREC_MULTICAST_GROUP_COL_NAME,
    SBREC_MULTICAST_GROUP_COL_PORTS,
    SBREC_MULTICAST_GROUP_COL_TUNNEL_KEY,
    SBREC_MULTICAST_GROUP_N_COLUMNS
};

#define sbrec_multicast_group_col_tunnel_key (sbrec_multicast_group_columns[SBREC_MULTICAST_GROUP_COL_TUNNEL_KEY])
#define sbrec_multicast_group_col_ports (sbrec_multicast_group_columns[SBREC_MULTICAST_GROUP_COL_PORTS])
#define sbrec_multicast_group_col_name (sbrec_multicast_group_columns[SBREC_MULTICAST_GROUP_COL_NAME])
#define sbrec_multicast_group_col_datapath (sbrec_multicast_group_columns[SBREC_MULTICAST_GROUP_COL_DATAPATH])

extern struct ovsdb_idl_column sbrec_multicast_group_columns[SBREC_MULTICAST_GROUP_N_COLUMNS];

const struct sbrec_multicast_group_table *sbrec_multicast_group_table_get(const struct ovsdb_idl *);
const struct sbrec_multicast_group *sbrec_multicast_group_table_first(const struct sbrec_multicast_group_table *);

#define SBREC_MULTICAST_GROUP_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_multicast_group_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_multicast_group_next(ROW))
#define SBREC_MULTICAST_GROUP_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_multicast_group_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_multicast_group_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_multicast_group *sbrec_multicast_group_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_multicast_group *sbrec_multicast_group_table_get_for_uuid(const struct sbrec_multicast_group_table *, const struct uuid *);
const struct sbrec_multicast_group *sbrec_multicast_group_first(const struct ovsdb_idl *);
const struct sbrec_multicast_group *sbrec_multicast_group_next(const struct sbrec_multicast_group *);
#define SBREC_MULTICAST_GROUP_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_multicast_group_first(IDL); \
             (ROW); \
             (ROW) = sbrec_multicast_group_next(ROW))
#define SBREC_MULTICAST_GROUP_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_multicast_group_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_multicast_group_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_multicast_group_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_multicast_group_row_get_seqno(const struct sbrec_multicast_group *row, enum ovsdb_idl_change change);
const struct sbrec_multicast_group *sbrec_multicast_group_track_get_first(const struct ovsdb_idl *);
const struct sbrec_multicast_group *sbrec_multicast_group_track_get_next(const struct sbrec_multicast_group *);
#define SBREC_MULTICAST_GROUP_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_multicast_group_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_multicast_group_track_get_next(ROW))

const struct sbrec_multicast_group *sbrec_multicast_group_table_track_get_first(const struct sbrec_multicast_group_table *);
#define SBREC_MULTICAST_GROUP_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_multicast_group_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_multicast_group_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_multicast_group_is_new(const struct sbrec_multicast_group *row)
{
    return sbrec_multicast_group_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_multicast_group_is_deleted(const struct sbrec_multicast_group *row)
{
    return sbrec_multicast_group_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_multicast_group_index_destroy_row(const struct sbrec_multicast_group *);

struct sbrec_multicast_group *sbrec_multicast_group_index_find(struct ovsdb_idl_index *, const struct sbrec_multicast_group *);

int sbrec_multicast_group_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_multicast_group *, 
    const struct sbrec_multicast_group *);
struct ovsdb_idl_cursor sbrec_multicast_group_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_multicast_group_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_multicast_group *);
struct ovsdb_idl_cursor sbrec_multicast_group_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_multicast_group *);

struct sbrec_multicast_group *sbrec_multicast_group_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_MULTICAST_GROUP_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_multicast_group_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_multicast_group_cursor_data(&cursor__), \
                  !(TO) || sbrec_multicast_group_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_MULTICAST_GROUP_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_multicast_group_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_multicast_group_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_MULTICAST_GROUP_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_multicast_group_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_multicast_group_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_multicast_group_init(struct sbrec_multicast_group *);
void sbrec_multicast_group_delete(const struct sbrec_multicast_group *);
struct sbrec_multicast_group *sbrec_multicast_group_insert(struct ovsdb_idl_txn *);
bool sbrec_multicast_group_is_updated(const struct sbrec_multicast_group *, enum sbrec_multicast_group_column_id);

void sbrec_multicast_group_verify_datapath(const struct sbrec_multicast_group *);
void sbrec_multicast_group_verify_name(const struct sbrec_multicast_group *);
void sbrec_multicast_group_verify_ports(const struct sbrec_multicast_group *);
void sbrec_multicast_group_verify_tunnel_key(const struct sbrec_multicast_group *);

const struct ovsdb_datum *sbrec_multicast_group_get_datapath(const struct sbrec_multicast_group *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_multicast_group_get_name(const struct sbrec_multicast_group *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_multicast_group_get_ports(const struct sbrec_multicast_group *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_multicast_group_get_tunnel_key(const struct sbrec_multicast_group *, enum ovsdb_atomic_type key_type);

void sbrec_multicast_group_set_datapath(const struct sbrec_multicast_group *, const struct sbrec_datapath_binding *datapath);
void sbrec_multicast_group_set_name(const struct sbrec_multicast_group *, const char *name);
void sbrec_multicast_group_set_ports(const struct sbrec_multicast_group *, struct sbrec_port_binding **ports, size_t n_ports);
void sbrec_multicast_group_set_tunnel_key(const struct sbrec_multicast_group *, int64_t tunnel_key);

void sbrec_multicast_group_add_clause_datapath(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct uuid *datapath);
void sbrec_multicast_group_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_multicast_group_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_multicast_group_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_multicast_group_update_ports_addvalue(const struct sbrec_multicast_group *,  const struct sbrec_port_binding *);
void sbrec_multicast_group_update_ports_delvalue(const struct sbrec_multicast_group *,  const struct sbrec_port_binding *);
void sbrec_multicast_group_add_clause_ports(struct ovsdb_idl_condition *, enum ovsdb_function function, struct uuid **ports, size_t n_ports);
void sbrec_multicast_group_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_multicast_group_add_clause_tunnel_key(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t tunnel_key);
void sbrec_multicast_group_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_multicast_group *sbrec_multicast_group_index_init_row(struct ovsdb_idl_index *);
void sbrec_multicast_group_index_set_datapath(const struct sbrec_multicast_group *,
const struct sbrec_datapath_binding *datapath);
void sbrec_multicast_group_index_set_name(const struct sbrec_multicast_group *,
const char *name);
void sbrec_multicast_group_index_set_ports(const struct sbrec_multicast_group *,
struct sbrec_port_binding **ports, size_t n_ports);
void sbrec_multicast_group_index_set_tunnel_key(const struct sbrec_multicast_group *,
int64_t tunnel_key);

/* Port_Binding table. */
struct sbrec_port_binding {
    struct ovsdb_idl_row header_;

    /* chassis column. */
    struct sbrec_chassis *chassis;

    /* datapath column. */
    struct sbrec_datapath_binding *datapath;

    /* encap column. */
    struct sbrec_encap *encap;

    /* external_ids column. */
    struct smap external_ids;

    /* gateway_chassis column. */
    struct sbrec_gateway_chassis **gateway_chassis;
    size_t n_gateway_chassis;

    /* logical_port column. */
    char *logical_port;    /* Always nonnull. */

    /* mac column. */
    char **mac;
    size_t n_mac;

    /* nat_addresses column. */
    char **nat_addresses;
    size_t n_nat_addresses;

    /* options column. */
    struct smap options;

    /* parent_port column. */
    char *parent_port;

    /* tag column. */
    int64_t *tag;
    size_t n_tag;

    /* tunnel_key column. */
    int64_t tunnel_key;

    /* type column. */
    char *type;    /* Always nonnull. */
};

enum sbrec_port_binding_column_id {
    SBREC_PORT_BINDING_COL_CHASSIS,
    SBREC_PORT_BINDING_COL_DATAPATH,
    SBREC_PORT_BINDING_COL_ENCAP,
    SBREC_PORT_BINDING_COL_EXTERNAL_IDS,
    SBREC_PORT_BINDING_COL_GATEWAY_CHASSIS,
    SBREC_PORT_BINDING_COL_LOGICAL_PORT,
    SBREC_PORT_BINDING_COL_MAC,
    SBREC_PORT_BINDING_COL_NAT_ADDRESSES,
    SBREC_PORT_BINDING_COL_OPTIONS,
    SBREC_PORT_BINDING_COL_PARENT_PORT,
    SBREC_PORT_BINDING_COL_TAG,
    SBREC_PORT_BINDING_COL_TUNNEL_KEY,
    SBREC_PORT_BINDING_COL_TYPE,
    SBREC_PORT_BINDING_N_COLUMNS
};

#define sbrec_port_binding_col_nat_addresses (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_NAT_ADDRESSES])
#define sbrec_port_binding_col_gateway_chassis (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_GATEWAY_CHASSIS])
#define sbrec_port_binding_col_chassis (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_CHASSIS])
#define sbrec_port_binding_col_parent_port (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_PARENT_PORT])
#define sbrec_port_binding_col_datapath (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_DATAPATH])
#define sbrec_port_binding_col_logical_port (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_LOGICAL_PORT])
#define sbrec_port_binding_col_mac (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_MAC])
#define sbrec_port_binding_col_tag (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_TAG])
#define sbrec_port_binding_col_encap (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_ENCAP])
#define sbrec_port_binding_col_tunnel_key (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_TUNNEL_KEY])
#define sbrec_port_binding_col_external_ids (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_EXTERNAL_IDS])
#define sbrec_port_binding_col_type (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_TYPE])
#define sbrec_port_binding_col_options (sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_OPTIONS])

extern struct ovsdb_idl_column sbrec_port_binding_columns[SBREC_PORT_BINDING_N_COLUMNS];

const struct sbrec_port_binding_table *sbrec_port_binding_table_get(const struct ovsdb_idl *);
const struct sbrec_port_binding *sbrec_port_binding_table_first(const struct sbrec_port_binding_table *);

#define SBREC_PORT_BINDING_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_port_binding_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_port_binding_next(ROW))
#define SBREC_PORT_BINDING_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_port_binding_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_port_binding_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_port_binding *sbrec_port_binding_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_port_binding *sbrec_port_binding_table_get_for_uuid(const struct sbrec_port_binding_table *, const struct uuid *);
const struct sbrec_port_binding *sbrec_port_binding_first(const struct ovsdb_idl *);
const struct sbrec_port_binding *sbrec_port_binding_next(const struct sbrec_port_binding *);
#define SBREC_PORT_BINDING_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_port_binding_first(IDL); \
             (ROW); \
             (ROW) = sbrec_port_binding_next(ROW))
#define SBREC_PORT_BINDING_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_port_binding_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_port_binding_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_port_binding_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_port_binding_row_get_seqno(const struct sbrec_port_binding *row, enum ovsdb_idl_change change);
const struct sbrec_port_binding *sbrec_port_binding_track_get_first(const struct ovsdb_idl *);
const struct sbrec_port_binding *sbrec_port_binding_track_get_next(const struct sbrec_port_binding *);
#define SBREC_PORT_BINDING_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_port_binding_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_port_binding_track_get_next(ROW))

const struct sbrec_port_binding *sbrec_port_binding_table_track_get_first(const struct sbrec_port_binding_table *);
#define SBREC_PORT_BINDING_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_port_binding_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_port_binding_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_port_binding_is_new(const struct sbrec_port_binding *row)
{
    return sbrec_port_binding_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_port_binding_is_deleted(const struct sbrec_port_binding *row)
{
    return sbrec_port_binding_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_port_binding_index_destroy_row(const struct sbrec_port_binding *);

struct sbrec_port_binding *sbrec_port_binding_index_find(struct ovsdb_idl_index *, const struct sbrec_port_binding *);

int sbrec_port_binding_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_port_binding *, 
    const struct sbrec_port_binding *);
struct ovsdb_idl_cursor sbrec_port_binding_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_port_binding_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_port_binding *);
struct ovsdb_idl_cursor sbrec_port_binding_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_port_binding *);

struct sbrec_port_binding *sbrec_port_binding_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_PORT_BINDING_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_port_binding_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_port_binding_cursor_data(&cursor__), \
                  !(TO) || sbrec_port_binding_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_PORT_BINDING_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_port_binding_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_port_binding_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_PORT_BINDING_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_port_binding_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_port_binding_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_port_binding_init(struct sbrec_port_binding *);
void sbrec_port_binding_delete(const struct sbrec_port_binding *);
struct sbrec_port_binding *sbrec_port_binding_insert(struct ovsdb_idl_txn *);
bool sbrec_port_binding_is_updated(const struct sbrec_port_binding *, enum sbrec_port_binding_column_id);

void sbrec_port_binding_verify_chassis(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_datapath(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_encap(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_external_ids(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_gateway_chassis(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_logical_port(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_mac(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_nat_addresses(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_options(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_parent_port(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_tag(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_tunnel_key(const struct sbrec_port_binding *);
void sbrec_port_binding_verify_type(const struct sbrec_port_binding *);

const struct ovsdb_datum *sbrec_port_binding_get_chassis(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_datapath(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_encap(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_external_ids(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_port_binding_get_gateway_chassis(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_logical_port(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_mac(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_nat_addresses(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_options(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_port_binding_get_parent_port(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_tag(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_tunnel_key(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_binding_get_type(const struct sbrec_port_binding *, enum ovsdb_atomic_type key_type);

void sbrec_port_binding_set_chassis(const struct sbrec_port_binding *, const struct sbrec_chassis *chassis);
void sbrec_port_binding_set_datapath(const struct sbrec_port_binding *, const struct sbrec_datapath_binding *datapath);
void sbrec_port_binding_set_encap(const struct sbrec_port_binding *, const struct sbrec_encap *encap);
void sbrec_port_binding_set_external_ids(const struct sbrec_port_binding *, const struct smap *);
void sbrec_port_binding_set_gateway_chassis(const struct sbrec_port_binding *, struct sbrec_gateway_chassis **gateway_chassis, size_t n_gateway_chassis);
void sbrec_port_binding_set_logical_port(const struct sbrec_port_binding *, const char *logical_port);
void sbrec_port_binding_set_mac(const struct sbrec_port_binding *, const char **mac, size_t n_mac);
void sbrec_port_binding_set_nat_addresses(const struct sbrec_port_binding *, const char **nat_addresses, size_t n_nat_addresses);
void sbrec_port_binding_set_options(const struct sbrec_port_binding *, const struct smap *);
void sbrec_port_binding_set_parent_port(const struct sbrec_port_binding *, const char *parent_port);
void sbrec_port_binding_set_tag(const struct sbrec_port_binding *, const int64_t *tag, size_t n_tag);
void sbrec_port_binding_set_tunnel_key(const struct sbrec_port_binding *, int64_t tunnel_key);
void sbrec_port_binding_set_type(const struct sbrec_port_binding *, const char *type);

void sbrec_port_binding_update_chassis_addvalue(const struct sbrec_port_binding *,  const struct sbrec_chassis *);
void sbrec_port_binding_update_chassis_delvalue(const struct sbrec_port_binding *,  const struct sbrec_chassis *);
void sbrec_port_binding_add_clause_chassis(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct uuid *chassis);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_add_clause_datapath(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct uuid *datapath);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_update_encap_addvalue(const struct sbrec_port_binding *,  const struct sbrec_encap *);
void sbrec_port_binding_update_encap_delvalue(const struct sbrec_port_binding *,  const struct sbrec_encap *);
void sbrec_port_binding_add_clause_encap(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct uuid *encap);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_update_external_ids_setkey(const struct sbrec_port_binding *,  const char *, const char *);
void sbrec_port_binding_update_external_ids_delkey(const struct sbrec_port_binding *,  const char *);
void sbrec_port_binding_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_update_gateway_chassis_addvalue(const struct sbrec_port_binding *,  const struct sbrec_gateway_chassis *);
void sbrec_port_binding_update_gateway_chassis_delvalue(const struct sbrec_port_binding *,  const struct sbrec_gateway_chassis *);
void sbrec_port_binding_add_clause_gateway_chassis(struct ovsdb_idl_condition *, enum ovsdb_function function, struct uuid **gateway_chassis, size_t n_gateway_chassis);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_add_clause_logical_port(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *logical_port);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_update_mac_addvalue(const struct sbrec_port_binding *,  const char *);
void sbrec_port_binding_update_mac_delvalue(const struct sbrec_port_binding *,  const char *);
void sbrec_port_binding_add_clause_mac(struct ovsdb_idl_condition *, enum ovsdb_function function, const char **mac, size_t n_mac);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_update_nat_addresses_addvalue(const struct sbrec_port_binding *,  const char *);
void sbrec_port_binding_update_nat_addresses_delvalue(const struct sbrec_port_binding *,  const char *);
void sbrec_port_binding_add_clause_nat_addresses(struct ovsdb_idl_condition *, enum ovsdb_function function, const char **nat_addresses, size_t n_nat_addresses);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_update_options_setkey(const struct sbrec_port_binding *,  const char *, const char *);
void sbrec_port_binding_update_options_delkey(const struct sbrec_port_binding *,  const char *);
void sbrec_port_binding_add_clause_options(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_update_parent_port_addvalue(const struct sbrec_port_binding *,  const char *);
void sbrec_port_binding_update_parent_port_delvalue(const struct sbrec_port_binding *,  const char *);
void sbrec_port_binding_add_clause_parent_port(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *parent_port);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_update_tag_addvalue(const struct sbrec_port_binding *,  int64_t );
void sbrec_port_binding_update_tag_delvalue(const struct sbrec_port_binding *,  int64_t );
void sbrec_port_binding_add_clause_tag(struct ovsdb_idl_condition *, enum ovsdb_function function, const int64_t *tag, size_t n_tag);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_add_clause_tunnel_key(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t tunnel_key);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_binding_add_clause_type(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *type);
void sbrec_port_binding_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_port_binding *sbrec_port_binding_index_init_row(struct ovsdb_idl_index *);
void sbrec_port_binding_index_set_chassis(const struct sbrec_port_binding *,
const struct sbrec_chassis *chassis);
void sbrec_port_binding_index_set_datapath(const struct sbrec_port_binding *,
const struct sbrec_datapath_binding *datapath);
void sbrec_port_binding_index_set_encap(const struct sbrec_port_binding *,
const struct sbrec_encap *encap);
void sbrec_port_binding_index_set_external_ids(const struct sbrec_port_binding *,
const struct smap *);
void sbrec_port_binding_index_set_gateway_chassis(const struct sbrec_port_binding *,
struct sbrec_gateway_chassis **gateway_chassis, size_t n_gateway_chassis);
void sbrec_port_binding_index_set_logical_port(const struct sbrec_port_binding *,
const char *logical_port);
void sbrec_port_binding_index_set_mac(const struct sbrec_port_binding *,
const char **mac, size_t n_mac);
void sbrec_port_binding_index_set_nat_addresses(const struct sbrec_port_binding *,
const char **nat_addresses, size_t n_nat_addresses);
void sbrec_port_binding_index_set_options(const struct sbrec_port_binding *,
const struct smap *);
void sbrec_port_binding_index_set_parent_port(const struct sbrec_port_binding *,
const char *parent_port);
void sbrec_port_binding_index_set_tag(const struct sbrec_port_binding *,
const int64_t *tag, size_t n_tag);
void sbrec_port_binding_index_set_tunnel_key(const struct sbrec_port_binding *,
int64_t tunnel_key);
void sbrec_port_binding_index_set_type(const struct sbrec_port_binding *,
const char *type);

/* Port_Group table. */
struct sbrec_port_group {
    struct ovsdb_idl_row header_;

    /* name column. */
    char *name;    /* Always nonnull. */

    /* ports column. */
    char **ports;
    size_t n_ports;
};

enum sbrec_port_group_column_id {
    SBREC_PORT_GROUP_COL_NAME,
    SBREC_PORT_GROUP_COL_PORTS,
    SBREC_PORT_GROUP_N_COLUMNS
};

#define sbrec_port_group_col_name (sbrec_port_group_columns[SBREC_PORT_GROUP_COL_NAME])
#define sbrec_port_group_col_ports (sbrec_port_group_columns[SBREC_PORT_GROUP_COL_PORTS])

extern struct ovsdb_idl_column sbrec_port_group_columns[SBREC_PORT_GROUP_N_COLUMNS];

const struct sbrec_port_group_table *sbrec_port_group_table_get(const struct ovsdb_idl *);
const struct sbrec_port_group *sbrec_port_group_table_first(const struct sbrec_port_group_table *);

#define SBREC_PORT_GROUP_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_port_group_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_port_group_next(ROW))
#define SBREC_PORT_GROUP_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_port_group_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_port_group_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_port_group *sbrec_port_group_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_port_group *sbrec_port_group_table_get_for_uuid(const struct sbrec_port_group_table *, const struct uuid *);
const struct sbrec_port_group *sbrec_port_group_first(const struct ovsdb_idl *);
const struct sbrec_port_group *sbrec_port_group_next(const struct sbrec_port_group *);
#define SBREC_PORT_GROUP_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_port_group_first(IDL); \
             (ROW); \
             (ROW) = sbrec_port_group_next(ROW))
#define SBREC_PORT_GROUP_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_port_group_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_port_group_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_port_group_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_port_group_row_get_seqno(const struct sbrec_port_group *row, enum ovsdb_idl_change change);
const struct sbrec_port_group *sbrec_port_group_track_get_first(const struct ovsdb_idl *);
const struct sbrec_port_group *sbrec_port_group_track_get_next(const struct sbrec_port_group *);
#define SBREC_PORT_GROUP_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_port_group_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_port_group_track_get_next(ROW))

const struct sbrec_port_group *sbrec_port_group_table_track_get_first(const struct sbrec_port_group_table *);
#define SBREC_PORT_GROUP_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_port_group_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_port_group_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_port_group_is_new(const struct sbrec_port_group *row)
{
    return sbrec_port_group_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_port_group_is_deleted(const struct sbrec_port_group *row)
{
    return sbrec_port_group_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_port_group_index_destroy_row(const struct sbrec_port_group *);

struct sbrec_port_group *sbrec_port_group_index_find(struct ovsdb_idl_index *, const struct sbrec_port_group *);

int sbrec_port_group_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_port_group *, 
    const struct sbrec_port_group *);
struct ovsdb_idl_cursor sbrec_port_group_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_port_group_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_port_group *);
struct ovsdb_idl_cursor sbrec_port_group_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_port_group *);

struct sbrec_port_group *sbrec_port_group_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_PORT_GROUP_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_port_group_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_port_group_cursor_data(&cursor__), \
                  !(TO) || sbrec_port_group_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_PORT_GROUP_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_port_group_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_port_group_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_PORT_GROUP_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_port_group_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_port_group_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_port_group_init(struct sbrec_port_group *);
void sbrec_port_group_delete(const struct sbrec_port_group *);
struct sbrec_port_group *sbrec_port_group_insert(struct ovsdb_idl_txn *);
bool sbrec_port_group_is_updated(const struct sbrec_port_group *, enum sbrec_port_group_column_id);

void sbrec_port_group_verify_name(const struct sbrec_port_group *);
void sbrec_port_group_verify_ports(const struct sbrec_port_group *);

const struct ovsdb_datum *sbrec_port_group_get_name(const struct sbrec_port_group *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_port_group_get_ports(const struct sbrec_port_group *, enum ovsdb_atomic_type key_type);

void sbrec_port_group_set_name(const struct sbrec_port_group *, const char *name);
void sbrec_port_group_set_ports(const struct sbrec_port_group *, const char **ports, size_t n_ports);

void sbrec_port_group_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_port_group_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_port_group_update_ports_addvalue(const struct sbrec_port_group *,  const char *);
void sbrec_port_group_update_ports_delvalue(const struct sbrec_port_group *,  const char *);
void sbrec_port_group_add_clause_ports(struct ovsdb_idl_condition *, enum ovsdb_function function, const char **ports, size_t n_ports);
void sbrec_port_group_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_port_group *sbrec_port_group_index_init_row(struct ovsdb_idl_index *);
void sbrec_port_group_index_set_name(const struct sbrec_port_group *,
const char *name);
void sbrec_port_group_index_set_ports(const struct sbrec_port_group *,
const char **ports, size_t n_ports);

/* RBAC_Permission table. */
struct sbrec_rbac_permission {
    struct ovsdb_idl_row header_;

    /* authorization column. */
    char **authorization;
    size_t n_authorization;

    /* insert_delete column. */
    bool insert_delete;

    /* table column. */
    char *table;    /* Always nonnull. */

    /* update column. */
    char **update;
    size_t n_update;
};

enum sbrec_rbac_permission_column_id {
    SBREC_RBAC_PERMISSION_COL_AUTHORIZATION,
    SBREC_RBAC_PERMISSION_COL_INSERT_DELETE,
    SBREC_RBAC_PERMISSION_COL_TABLE,
    SBREC_RBAC_PERMISSION_COL_UPDATE,
    SBREC_RBAC_PERMISSION_N_COLUMNS
};

#define sbrec_rbac_permission_col_table (sbrec_rbac_permission_columns[SBREC_RBAC_PERMISSION_COL_TABLE])
#define sbrec_rbac_permission_col_authorization (sbrec_rbac_permission_columns[SBREC_RBAC_PERMISSION_COL_AUTHORIZATION])
#define sbrec_rbac_permission_col_insert_delete (sbrec_rbac_permission_columns[SBREC_RBAC_PERMISSION_COL_INSERT_DELETE])
#define sbrec_rbac_permission_col_update (sbrec_rbac_permission_columns[SBREC_RBAC_PERMISSION_COL_UPDATE])

extern struct ovsdb_idl_column sbrec_rbac_permission_columns[SBREC_RBAC_PERMISSION_N_COLUMNS];

const struct sbrec_rbac_permission_table *sbrec_rbac_permission_table_get(const struct ovsdb_idl *);
const struct sbrec_rbac_permission *sbrec_rbac_permission_table_first(const struct sbrec_rbac_permission_table *);

#define SBREC_RBAC_PERMISSION_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_rbac_permission_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_rbac_permission_next(ROW))
#define SBREC_RBAC_PERMISSION_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_rbac_permission_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_rbac_permission_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_rbac_permission *sbrec_rbac_permission_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_rbac_permission *sbrec_rbac_permission_table_get_for_uuid(const struct sbrec_rbac_permission_table *, const struct uuid *);
const struct sbrec_rbac_permission *sbrec_rbac_permission_first(const struct ovsdb_idl *);
const struct sbrec_rbac_permission *sbrec_rbac_permission_next(const struct sbrec_rbac_permission *);
#define SBREC_RBAC_PERMISSION_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_rbac_permission_first(IDL); \
             (ROW); \
             (ROW) = sbrec_rbac_permission_next(ROW))
#define SBREC_RBAC_PERMISSION_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_rbac_permission_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_rbac_permission_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_rbac_permission_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_rbac_permission_row_get_seqno(const struct sbrec_rbac_permission *row, enum ovsdb_idl_change change);
const struct sbrec_rbac_permission *sbrec_rbac_permission_track_get_first(const struct ovsdb_idl *);
const struct sbrec_rbac_permission *sbrec_rbac_permission_track_get_next(const struct sbrec_rbac_permission *);
#define SBREC_RBAC_PERMISSION_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_rbac_permission_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_rbac_permission_track_get_next(ROW))

const struct sbrec_rbac_permission *sbrec_rbac_permission_table_track_get_first(const struct sbrec_rbac_permission_table *);
#define SBREC_RBAC_PERMISSION_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_rbac_permission_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_rbac_permission_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_rbac_permission_is_new(const struct sbrec_rbac_permission *row)
{
    return sbrec_rbac_permission_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_rbac_permission_is_deleted(const struct sbrec_rbac_permission *row)
{
    return sbrec_rbac_permission_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_rbac_permission_index_destroy_row(const struct sbrec_rbac_permission *);

struct sbrec_rbac_permission *sbrec_rbac_permission_index_find(struct ovsdb_idl_index *, const struct sbrec_rbac_permission *);

int sbrec_rbac_permission_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_rbac_permission *, 
    const struct sbrec_rbac_permission *);
struct ovsdb_idl_cursor sbrec_rbac_permission_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_rbac_permission_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_rbac_permission *);
struct ovsdb_idl_cursor sbrec_rbac_permission_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_rbac_permission *);

struct sbrec_rbac_permission *sbrec_rbac_permission_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_RBAC_PERMISSION_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_rbac_permission_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_rbac_permission_cursor_data(&cursor__), \
                  !(TO) || sbrec_rbac_permission_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_RBAC_PERMISSION_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_rbac_permission_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_rbac_permission_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_RBAC_PERMISSION_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_rbac_permission_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_rbac_permission_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_rbac_permission_init(struct sbrec_rbac_permission *);
void sbrec_rbac_permission_delete(const struct sbrec_rbac_permission *);
struct sbrec_rbac_permission *sbrec_rbac_permission_insert(struct ovsdb_idl_txn *);
bool sbrec_rbac_permission_is_updated(const struct sbrec_rbac_permission *, enum sbrec_rbac_permission_column_id);

void sbrec_rbac_permission_verify_authorization(const struct sbrec_rbac_permission *);
void sbrec_rbac_permission_verify_insert_delete(const struct sbrec_rbac_permission *);
void sbrec_rbac_permission_verify_table(const struct sbrec_rbac_permission *);
void sbrec_rbac_permission_verify_update(const struct sbrec_rbac_permission *);

const struct ovsdb_datum *sbrec_rbac_permission_get_authorization(const struct sbrec_rbac_permission *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_rbac_permission_get_insert_delete(const struct sbrec_rbac_permission *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_rbac_permission_get_table(const struct sbrec_rbac_permission *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_rbac_permission_get_update(const struct sbrec_rbac_permission *, enum ovsdb_atomic_type key_type);

void sbrec_rbac_permission_set_authorization(const struct sbrec_rbac_permission *, const char **authorization, size_t n_authorization);
void sbrec_rbac_permission_set_insert_delete(const struct sbrec_rbac_permission *, bool insert_delete);
void sbrec_rbac_permission_set_table(const struct sbrec_rbac_permission *, const char *table);
void sbrec_rbac_permission_set_update(const struct sbrec_rbac_permission *, const char **update, size_t n_update);

void sbrec_rbac_permission_update_authorization_addvalue(const struct sbrec_rbac_permission *,  const char *);
void sbrec_rbac_permission_update_authorization_delvalue(const struct sbrec_rbac_permission *,  const char *);
void sbrec_rbac_permission_add_clause_authorization(struct ovsdb_idl_condition *, enum ovsdb_function function, const char **authorization, size_t n_authorization);
void sbrec_rbac_permission_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_rbac_permission_add_clause_insert_delete(struct ovsdb_idl_condition *, enum ovsdb_function function, bool insert_delete);
void sbrec_rbac_permission_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_rbac_permission_add_clause_table(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *table);
void sbrec_rbac_permission_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_rbac_permission_update_update_addvalue(const struct sbrec_rbac_permission *,  const char *);
void sbrec_rbac_permission_update_update_delvalue(const struct sbrec_rbac_permission *,  const char *);
void sbrec_rbac_permission_add_clause_update(struct ovsdb_idl_condition *, enum ovsdb_function function, const char **update, size_t n_update);
void sbrec_rbac_permission_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_rbac_permission *sbrec_rbac_permission_index_init_row(struct ovsdb_idl_index *);
void sbrec_rbac_permission_index_set_authorization(const struct sbrec_rbac_permission *,
const char **authorization, size_t n_authorization);
void sbrec_rbac_permission_index_set_insert_delete(const struct sbrec_rbac_permission *,
bool insert_delete);
void sbrec_rbac_permission_index_set_table(const struct sbrec_rbac_permission *,
const char *table);
void sbrec_rbac_permission_index_set_update(const struct sbrec_rbac_permission *,
const char **update, size_t n_update);

/* RBAC_Role table. */
struct sbrec_rbac_role {
    struct ovsdb_idl_row header_;

    /* name column. */
    char *name;    /* Always nonnull. */

    /* permissions column. */
    char **key_permissions;
    struct sbrec_rbac_permission **value_permissions;
    size_t n_permissions;
};

enum sbrec_rbac_role_column_id {
    SBREC_RBAC_ROLE_COL_NAME,
    SBREC_RBAC_ROLE_COL_PERMISSIONS,
    SBREC_RBAC_ROLE_N_COLUMNS
};

#define sbrec_rbac_role_col_name (sbrec_rbac_role_columns[SBREC_RBAC_ROLE_COL_NAME])
#define sbrec_rbac_role_col_permissions (sbrec_rbac_role_columns[SBREC_RBAC_ROLE_COL_PERMISSIONS])

extern struct ovsdb_idl_column sbrec_rbac_role_columns[SBREC_RBAC_ROLE_N_COLUMNS];

const struct sbrec_rbac_role_table *sbrec_rbac_role_table_get(const struct ovsdb_idl *);
const struct sbrec_rbac_role *sbrec_rbac_role_table_first(const struct sbrec_rbac_role_table *);

#define SBREC_RBAC_ROLE_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_rbac_role_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_rbac_role_next(ROW))
#define SBREC_RBAC_ROLE_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_rbac_role_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_rbac_role_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_rbac_role *sbrec_rbac_role_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_rbac_role *sbrec_rbac_role_table_get_for_uuid(const struct sbrec_rbac_role_table *, const struct uuid *);
const struct sbrec_rbac_role *sbrec_rbac_role_first(const struct ovsdb_idl *);
const struct sbrec_rbac_role *sbrec_rbac_role_next(const struct sbrec_rbac_role *);
#define SBREC_RBAC_ROLE_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_rbac_role_first(IDL); \
             (ROW); \
             (ROW) = sbrec_rbac_role_next(ROW))
#define SBREC_RBAC_ROLE_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_rbac_role_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_rbac_role_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_rbac_role_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_rbac_role_row_get_seqno(const struct sbrec_rbac_role *row, enum ovsdb_idl_change change);
const struct sbrec_rbac_role *sbrec_rbac_role_track_get_first(const struct ovsdb_idl *);
const struct sbrec_rbac_role *sbrec_rbac_role_track_get_next(const struct sbrec_rbac_role *);
#define SBREC_RBAC_ROLE_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_rbac_role_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_rbac_role_track_get_next(ROW))

const struct sbrec_rbac_role *sbrec_rbac_role_table_track_get_first(const struct sbrec_rbac_role_table *);
#define SBREC_RBAC_ROLE_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_rbac_role_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_rbac_role_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_rbac_role_is_new(const struct sbrec_rbac_role *row)
{
    return sbrec_rbac_role_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_rbac_role_is_deleted(const struct sbrec_rbac_role *row)
{
    return sbrec_rbac_role_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_rbac_role_index_destroy_row(const struct sbrec_rbac_role *);

struct sbrec_rbac_role *sbrec_rbac_role_index_find(struct ovsdb_idl_index *, const struct sbrec_rbac_role *);

int sbrec_rbac_role_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_rbac_role *, 
    const struct sbrec_rbac_role *);
struct ovsdb_idl_cursor sbrec_rbac_role_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_rbac_role_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_rbac_role *);
struct ovsdb_idl_cursor sbrec_rbac_role_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_rbac_role *);

struct sbrec_rbac_role *sbrec_rbac_role_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_RBAC_ROLE_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_rbac_role_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_rbac_role_cursor_data(&cursor__), \
                  !(TO) || sbrec_rbac_role_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_RBAC_ROLE_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_rbac_role_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_rbac_role_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_RBAC_ROLE_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_rbac_role_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_rbac_role_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_rbac_role_init(struct sbrec_rbac_role *);
void sbrec_rbac_role_delete(const struct sbrec_rbac_role *);
struct sbrec_rbac_role *sbrec_rbac_role_insert(struct ovsdb_idl_txn *);
bool sbrec_rbac_role_is_updated(const struct sbrec_rbac_role *, enum sbrec_rbac_role_column_id);

void sbrec_rbac_role_verify_name(const struct sbrec_rbac_role *);
void sbrec_rbac_role_verify_permissions(const struct sbrec_rbac_role *);

const struct ovsdb_datum *sbrec_rbac_role_get_name(const struct sbrec_rbac_role *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_rbac_role_get_permissions(const struct sbrec_rbac_role *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);

void sbrec_rbac_role_set_name(const struct sbrec_rbac_role *, const char *name);
void sbrec_rbac_role_set_permissions(const struct sbrec_rbac_role *, const char **key_permissions, struct sbrec_rbac_permission **value_permissions, size_t n_permissions);

void sbrec_rbac_role_add_clause_name(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *name);
void sbrec_rbac_role_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_rbac_role_update_permissions_setkey(const struct sbrec_rbac_role *,  const char *, const struct sbrec_rbac_permission *);
void sbrec_rbac_role_update_permissions_delkey(const struct sbrec_rbac_role *,  const char *);
void sbrec_rbac_role_add_clause_permissions(struct ovsdb_idl_condition *, enum ovsdb_function function, const char **key_permissions, struct uuid **value_permissions, size_t n_permissions);
void sbrec_rbac_role_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_rbac_role *sbrec_rbac_role_index_init_row(struct ovsdb_idl_index *);
void sbrec_rbac_role_index_set_name(const struct sbrec_rbac_role *,
const char *name);
void sbrec_rbac_role_index_set_permissions(const struct sbrec_rbac_role *,
const char **key_permissions, struct sbrec_rbac_permission **value_permissions, size_t n_permissions);

/* SB_Global table. */
struct sbrec_sb_global {
    struct ovsdb_idl_row header_;

    /* connections column. */
    struct sbrec_connection **connections;
    size_t n_connections;

    /* external_ids column. */
    struct smap external_ids;

    /* ipsec column. */
    bool ipsec;

    /* nb_cfg column. */
    int64_t nb_cfg;

    /* options column. */
    struct smap options;

    /* ssl column. */
    struct sbrec_ssl *ssl;
};

enum sbrec_sb_global_column_id {
    SBREC_SB_GLOBAL_COL_CONNECTIONS,
    SBREC_SB_GLOBAL_COL_EXTERNAL_IDS,
    SBREC_SB_GLOBAL_COL_IPSEC,
    SBREC_SB_GLOBAL_COL_NB_CFG,
    SBREC_SB_GLOBAL_COL_OPTIONS,
    SBREC_SB_GLOBAL_COL_SSL,
    SBREC_SB_GLOBAL_N_COLUMNS
};

#define sbrec_sb_global_col_nb_cfg (sbrec_sb_global_columns[SBREC_SB_GLOBAL_COL_NB_CFG])
#define sbrec_sb_global_col_connections (sbrec_sb_global_columns[SBREC_SB_GLOBAL_COL_CONNECTIONS])
#define sbrec_sb_global_col_ssl (sbrec_sb_global_columns[SBREC_SB_GLOBAL_COL_SSL])
#define sbrec_sb_global_col_external_ids (sbrec_sb_global_columns[SBREC_SB_GLOBAL_COL_EXTERNAL_IDS])
#define sbrec_sb_global_col_options (sbrec_sb_global_columns[SBREC_SB_GLOBAL_COL_OPTIONS])
#define sbrec_sb_global_col_ipsec (sbrec_sb_global_columns[SBREC_SB_GLOBAL_COL_IPSEC])

extern struct ovsdb_idl_column sbrec_sb_global_columns[SBREC_SB_GLOBAL_N_COLUMNS];

const struct sbrec_sb_global_table *sbrec_sb_global_table_get(const struct ovsdb_idl *);
const struct sbrec_sb_global *sbrec_sb_global_table_first(const struct sbrec_sb_global_table *);

#define SBREC_SB_GLOBAL_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_sb_global_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_sb_global_next(ROW))
#define SBREC_SB_GLOBAL_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_sb_global_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_sb_global_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_sb_global *sbrec_sb_global_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_sb_global *sbrec_sb_global_table_get_for_uuid(const struct sbrec_sb_global_table *, const struct uuid *);
const struct sbrec_sb_global *sbrec_sb_global_first(const struct ovsdb_idl *);
const struct sbrec_sb_global *sbrec_sb_global_next(const struct sbrec_sb_global *);
#define SBREC_SB_GLOBAL_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_sb_global_first(IDL); \
             (ROW); \
             (ROW) = sbrec_sb_global_next(ROW))
#define SBREC_SB_GLOBAL_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_sb_global_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_sb_global_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_sb_global_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_sb_global_row_get_seqno(const struct sbrec_sb_global *row, enum ovsdb_idl_change change);
const struct sbrec_sb_global *sbrec_sb_global_track_get_first(const struct ovsdb_idl *);
const struct sbrec_sb_global *sbrec_sb_global_track_get_next(const struct sbrec_sb_global *);
#define SBREC_SB_GLOBAL_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_sb_global_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_sb_global_track_get_next(ROW))

const struct sbrec_sb_global *sbrec_sb_global_table_track_get_first(const struct sbrec_sb_global_table *);
#define SBREC_SB_GLOBAL_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_sb_global_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_sb_global_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_sb_global_is_new(const struct sbrec_sb_global *row)
{
    return sbrec_sb_global_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_sb_global_is_deleted(const struct sbrec_sb_global *row)
{
    return sbrec_sb_global_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_sb_global_index_destroy_row(const struct sbrec_sb_global *);

struct sbrec_sb_global *sbrec_sb_global_index_find(struct ovsdb_idl_index *, const struct sbrec_sb_global *);

int sbrec_sb_global_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_sb_global *, 
    const struct sbrec_sb_global *);
struct ovsdb_idl_cursor sbrec_sb_global_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_sb_global_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_sb_global *);
struct ovsdb_idl_cursor sbrec_sb_global_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_sb_global *);

struct sbrec_sb_global *sbrec_sb_global_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_SB_GLOBAL_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_sb_global_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_sb_global_cursor_data(&cursor__), \
                  !(TO) || sbrec_sb_global_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_SB_GLOBAL_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_sb_global_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_sb_global_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_SB_GLOBAL_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_sb_global_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_sb_global_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_sb_global_init(struct sbrec_sb_global *);
void sbrec_sb_global_delete(const struct sbrec_sb_global *);
struct sbrec_sb_global *sbrec_sb_global_insert(struct ovsdb_idl_txn *);
bool sbrec_sb_global_is_updated(const struct sbrec_sb_global *, enum sbrec_sb_global_column_id);

void sbrec_sb_global_verify_connections(const struct sbrec_sb_global *);
void sbrec_sb_global_verify_external_ids(const struct sbrec_sb_global *);
void sbrec_sb_global_verify_ipsec(const struct sbrec_sb_global *);
void sbrec_sb_global_verify_nb_cfg(const struct sbrec_sb_global *);
void sbrec_sb_global_verify_options(const struct sbrec_sb_global *);
void sbrec_sb_global_verify_ssl(const struct sbrec_sb_global *);

const struct ovsdb_datum *sbrec_sb_global_get_connections(const struct sbrec_sb_global *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_sb_global_get_external_ids(const struct sbrec_sb_global *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_sb_global_get_ipsec(const struct sbrec_sb_global *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_sb_global_get_nb_cfg(const struct sbrec_sb_global *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_sb_global_get_options(const struct sbrec_sb_global *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_sb_global_get_ssl(const struct sbrec_sb_global *, enum ovsdb_atomic_type key_type);

void sbrec_sb_global_set_connections(const struct sbrec_sb_global *, struct sbrec_connection **connections, size_t n_connections);
void sbrec_sb_global_set_external_ids(const struct sbrec_sb_global *, const struct smap *);
void sbrec_sb_global_set_ipsec(const struct sbrec_sb_global *, bool ipsec);
void sbrec_sb_global_set_nb_cfg(const struct sbrec_sb_global *, int64_t nb_cfg);
void sbrec_sb_global_set_options(const struct sbrec_sb_global *, const struct smap *);
void sbrec_sb_global_set_ssl(const struct sbrec_sb_global *, const struct sbrec_ssl *ssl);

void sbrec_sb_global_update_connections_addvalue(const struct sbrec_sb_global *,  const struct sbrec_connection *);
void sbrec_sb_global_update_connections_delvalue(const struct sbrec_sb_global *,  const struct sbrec_connection *);
void sbrec_sb_global_add_clause_connections(struct ovsdb_idl_condition *, enum ovsdb_function function, struct uuid **connections, size_t n_connections);
void sbrec_sb_global_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_sb_global_update_external_ids_setkey(const struct sbrec_sb_global *,  const char *, const char *);
void sbrec_sb_global_update_external_ids_delkey(const struct sbrec_sb_global *,  const char *);
void sbrec_sb_global_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_sb_global_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_sb_global_add_clause_ipsec(struct ovsdb_idl_condition *, enum ovsdb_function function, bool ipsec);
void sbrec_sb_global_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_sb_global_add_clause_nb_cfg(struct ovsdb_idl_condition *, enum ovsdb_function function, int64_t nb_cfg);
void sbrec_sb_global_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_sb_global_update_options_setkey(const struct sbrec_sb_global *,  const char *, const char *);
void sbrec_sb_global_update_options_delkey(const struct sbrec_sb_global *,  const char *);
void sbrec_sb_global_add_clause_options(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_sb_global_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_sb_global_update_ssl_addvalue(const struct sbrec_sb_global *,  const struct sbrec_ssl *);
void sbrec_sb_global_update_ssl_delvalue(const struct sbrec_sb_global *,  const struct sbrec_ssl *);
void sbrec_sb_global_add_clause_ssl(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct uuid *ssl);
void sbrec_sb_global_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_sb_global *sbrec_sb_global_index_init_row(struct ovsdb_idl_index *);
void sbrec_sb_global_index_set_connections(const struct sbrec_sb_global *,
struct sbrec_connection **connections, size_t n_connections);
void sbrec_sb_global_index_set_external_ids(const struct sbrec_sb_global *,
const struct smap *);
void sbrec_sb_global_index_set_ipsec(const struct sbrec_sb_global *,
bool ipsec);
void sbrec_sb_global_index_set_nb_cfg(const struct sbrec_sb_global *,
int64_t nb_cfg);
void sbrec_sb_global_index_set_options(const struct sbrec_sb_global *,
const struct smap *);
void sbrec_sb_global_index_set_ssl(const struct sbrec_sb_global *,
const struct sbrec_ssl *ssl);

/* SSL table. */
struct sbrec_ssl {
    struct ovsdb_idl_row header_;

    /* bootstrap_ca_cert column. */
    bool bootstrap_ca_cert;

    /* ca_cert column. */
    char *ca_cert;    /* Always nonnull. */

    /* certificate column. */
    char *certificate;    /* Always nonnull. */

    /* external_ids column. */
    struct smap external_ids;

    /* private_key column. */
    char *private_key;    /* Always nonnull. */

    /* ssl_ciphers column. */
    char *ssl_ciphers;    /* Always nonnull. */

    /* ssl_protocols column. */
    char *ssl_protocols;    /* Always nonnull. */
};

enum sbrec_ssl_column_id {
    SBREC_SSL_COL_BOOTSTRAP_CA_CERT,
    SBREC_SSL_COL_CA_CERT,
    SBREC_SSL_COL_CERTIFICATE,
    SBREC_SSL_COL_EXTERNAL_IDS,
    SBREC_SSL_COL_PRIVATE_KEY,
    SBREC_SSL_COL_SSL_CIPHERS,
    SBREC_SSL_COL_SSL_PROTOCOLS,
    SBREC_SSL_N_COLUMNS
};

#define sbrec_ssl_col_private_key (sbrec_ssl_columns[SBREC_SSL_COL_PRIVATE_KEY])
#define sbrec_ssl_col_ca_cert (sbrec_ssl_columns[SBREC_SSL_COL_CA_CERT])
#define sbrec_ssl_col_certificate (sbrec_ssl_columns[SBREC_SSL_COL_CERTIFICATE])
#define sbrec_ssl_col_ssl_ciphers (sbrec_ssl_columns[SBREC_SSL_COL_SSL_CIPHERS])
#define sbrec_ssl_col_bootstrap_ca_cert (sbrec_ssl_columns[SBREC_SSL_COL_BOOTSTRAP_CA_CERT])
#define sbrec_ssl_col_ssl_protocols (sbrec_ssl_columns[SBREC_SSL_COL_SSL_PROTOCOLS])
#define sbrec_ssl_col_external_ids (sbrec_ssl_columns[SBREC_SSL_COL_EXTERNAL_IDS])

extern struct ovsdb_idl_column sbrec_ssl_columns[SBREC_SSL_N_COLUMNS];

const struct sbrec_ssl_table *sbrec_ssl_table_get(const struct ovsdb_idl *);
const struct sbrec_ssl *sbrec_ssl_table_first(const struct sbrec_ssl_table *);

#define SBREC_SSL_TABLE_FOR_EACH(ROW, TABLE) \
        for ((ROW) = sbrec_ssl_table_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_ssl_next(ROW))
#define SBREC_SSL_TABLE_FOR_EACH_SAFE(ROW, NEXT, TABLE) \
        for ((ROW) = sbrec_ssl_table_first(TABLE); \
             (ROW) ? ((NEXT) = sbrec_ssl_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

const struct sbrec_ssl *sbrec_ssl_get_for_uuid(const struct ovsdb_idl *, const struct uuid *);
const struct sbrec_ssl *sbrec_ssl_table_get_for_uuid(const struct sbrec_ssl_table *, const struct uuid *);
const struct sbrec_ssl *sbrec_ssl_first(const struct ovsdb_idl *);
const struct sbrec_ssl *sbrec_ssl_next(const struct sbrec_ssl *);
#define SBREC_SSL_FOR_EACH(ROW, IDL) \
        for ((ROW) = sbrec_ssl_first(IDL); \
             (ROW); \
             (ROW) = sbrec_ssl_next(ROW))
#define SBREC_SSL_FOR_EACH_SAFE(ROW, NEXT, IDL) \
        for ((ROW) = sbrec_ssl_first(IDL); \
             (ROW) ? ((NEXT) = sbrec_ssl_next(ROW), 1) : 0; \
             (ROW) = (NEXT))

unsigned int sbrec_ssl_get_seqno(const struct ovsdb_idl *);
unsigned int sbrec_ssl_row_get_seqno(const struct sbrec_ssl *row, enum ovsdb_idl_change change);
const struct sbrec_ssl *sbrec_ssl_track_get_first(const struct ovsdb_idl *);
const struct sbrec_ssl *sbrec_ssl_track_get_next(const struct sbrec_ssl *);
#define SBREC_SSL_FOR_EACH_TRACKED(ROW, IDL) \
        for ((ROW) = sbrec_ssl_track_get_first(IDL); \
             (ROW); \
             (ROW) = sbrec_ssl_track_get_next(ROW))

const struct sbrec_ssl *sbrec_ssl_table_track_get_first(const struct sbrec_ssl_table *);
#define SBREC_SSL_TABLE_FOR_EACH_TRACKED(ROW, TABLE) \
        for ((ROW) = sbrec_ssl_table_track_get_first(TABLE); \
             (ROW); \
             (ROW) = sbrec_ssl_track_get_next(ROW))


/* Returns true if 'row' was inserted since the last change tracking reset. */
static inline bool sbrec_ssl_is_new(const struct sbrec_ssl *row)
{
    return sbrec_ssl_row_get_seqno(row, OVSDB_IDL_CHANGE_MODIFY) == 0;
}

/* Returns true if 'row' was deleted since the last change tracking reset. */
static inline bool sbrec_ssl_is_deleted(const struct sbrec_ssl *row)
{
    return sbrec_ssl_row_get_seqno(row, OVSDB_IDL_CHANGE_DELETE) > 0;
}

void sbrec_ssl_index_destroy_row(const struct sbrec_ssl *);

struct sbrec_ssl *sbrec_ssl_index_find(struct ovsdb_idl_index *, const struct sbrec_ssl *);

int sbrec_ssl_index_compare(
    struct ovsdb_idl_index *, 
    const struct sbrec_ssl *, 
    const struct sbrec_ssl *);
struct ovsdb_idl_cursor sbrec_ssl_cursor_first(struct ovsdb_idl_index *);
struct ovsdb_idl_cursor sbrec_ssl_cursor_first_eq(
    struct ovsdb_idl_index *, const struct sbrec_ssl *);
struct ovsdb_idl_cursor sbrec_ssl_cursor_first_ge(
    struct ovsdb_idl_index *, const struct sbrec_ssl *);

struct sbrec_ssl *sbrec_ssl_cursor_data(struct ovsdb_idl_cursor *);

#define SBREC_SSL_FOR_EACH_RANGE(ROW, FROM, TO, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_ssl_cursor_first_ge(INDEX, FROM); \
             (cursor__.position \
              && ((ROW) = sbrec_ssl_cursor_data(&cursor__), \
                  !(TO) || sbrec_ssl_index_compare(INDEX, ROW, TO) <= 0)); \
             ovsdb_idl_cursor_next(&cursor__))
#define SBREC_SSL_FOR_EACH_EQUAL(ROW, KEY, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_ssl_cursor_first_eq(INDEX, KEY); \
             (cursor__.position \
              ? ((ROW) = sbrec_ssl_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next_eq(&cursor__), \
                 true) \
              : false); \
            )
#define SBREC_SSL_FOR_EACH_BYINDEX(ROW, INDEX) \
        for (struct ovsdb_idl_cursor cursor__ = sbrec_ssl_cursor_first(INDEX); \
             (cursor__.position \
              ? ((ROW) = sbrec_ssl_cursor_data(&cursor__), \
                 ovsdb_idl_cursor_next(&cursor__), \
                 true) \
              : false); \
            )

void sbrec_ssl_init(struct sbrec_ssl *);
void sbrec_ssl_delete(const struct sbrec_ssl *);
struct sbrec_ssl *sbrec_ssl_insert(struct ovsdb_idl_txn *);
bool sbrec_ssl_is_updated(const struct sbrec_ssl *, enum sbrec_ssl_column_id);

void sbrec_ssl_verify_bootstrap_ca_cert(const struct sbrec_ssl *);
void sbrec_ssl_verify_ca_cert(const struct sbrec_ssl *);
void sbrec_ssl_verify_certificate(const struct sbrec_ssl *);
void sbrec_ssl_verify_external_ids(const struct sbrec_ssl *);
void sbrec_ssl_verify_private_key(const struct sbrec_ssl *);
void sbrec_ssl_verify_ssl_ciphers(const struct sbrec_ssl *);
void sbrec_ssl_verify_ssl_protocols(const struct sbrec_ssl *);

const struct ovsdb_datum *sbrec_ssl_get_bootstrap_ca_cert(const struct sbrec_ssl *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_ssl_get_ca_cert(const struct sbrec_ssl *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_ssl_get_certificate(const struct sbrec_ssl *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_ssl_get_external_ids(const struct sbrec_ssl *, enum ovsdb_atomic_type key_type, enum ovsdb_atomic_type value_type);
const struct ovsdb_datum *sbrec_ssl_get_private_key(const struct sbrec_ssl *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_ssl_get_ssl_ciphers(const struct sbrec_ssl *, enum ovsdb_atomic_type key_type);
const struct ovsdb_datum *sbrec_ssl_get_ssl_protocols(const struct sbrec_ssl *, enum ovsdb_atomic_type key_type);

void sbrec_ssl_set_bootstrap_ca_cert(const struct sbrec_ssl *, bool bootstrap_ca_cert);
void sbrec_ssl_set_ca_cert(const struct sbrec_ssl *, const char *ca_cert);
void sbrec_ssl_set_certificate(const struct sbrec_ssl *, const char *certificate);
void sbrec_ssl_set_external_ids(const struct sbrec_ssl *, const struct smap *);
void sbrec_ssl_set_private_key(const struct sbrec_ssl *, const char *private_key);
void sbrec_ssl_set_ssl_ciphers(const struct sbrec_ssl *, const char *ssl_ciphers);
void sbrec_ssl_set_ssl_protocols(const struct sbrec_ssl *, const char *ssl_protocols);

void sbrec_ssl_add_clause_bootstrap_ca_cert(struct ovsdb_idl_condition *, enum ovsdb_function function, bool bootstrap_ca_cert);
void sbrec_ssl_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_ssl_add_clause_ca_cert(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *ca_cert);
void sbrec_ssl_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_ssl_add_clause_certificate(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *certificate);
void sbrec_ssl_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_ssl_update_external_ids_setkey(const struct sbrec_ssl *,  const char *, const char *);
void sbrec_ssl_update_external_ids_delkey(const struct sbrec_ssl *,  const char *);
void sbrec_ssl_add_clause_external_ids(struct ovsdb_idl_condition *, enum ovsdb_function function, const struct smap *);
void sbrec_ssl_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_ssl_add_clause_private_key(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *private_key);
void sbrec_ssl_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_ssl_add_clause_ssl_ciphers(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *ssl_ciphers);
void sbrec_ssl_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);
void sbrec_ssl_add_clause_ssl_protocols(struct ovsdb_idl_condition *, enum ovsdb_function function, const char *ssl_protocols);
void sbrec_ssl_set_condition(struct ovsdb_idl *, struct ovsdb_idl_condition *);

struct sbrec_ssl *sbrec_ssl_index_init_row(struct ovsdb_idl_index *);
void sbrec_ssl_index_set_bootstrap_ca_cert(const struct sbrec_ssl *,
bool bootstrap_ca_cert);
void sbrec_ssl_index_set_ca_cert(const struct sbrec_ssl *,
const char *ca_cert);
void sbrec_ssl_index_set_certificate(const struct sbrec_ssl *,
const char *certificate);
void sbrec_ssl_index_set_external_ids(const struct sbrec_ssl *,
const struct smap *);
void sbrec_ssl_index_set_private_key(const struct sbrec_ssl *,
const char *private_key);
void sbrec_ssl_index_set_ssl_ciphers(const struct sbrec_ssl *,
const char *ssl_ciphers);
void sbrec_ssl_index_set_ssl_protocols(const struct sbrec_ssl *,
const char *ssl_protocols);

enum sbrec_table_id {
    SBREC_TABLE_ADDRESS_SET,
    SBREC_TABLE_CHASSIS,
    SBREC_TABLE_CONNECTION,
    SBREC_TABLE_DHCP_OPTIONS,
    SBREC_TABLE_DHCPV6_OPTIONS,
    SBREC_TABLE_DNS,
    SBREC_TABLE_DATAPATH_BINDING,
    SBREC_TABLE_ENCAP,
    SBREC_TABLE_GATEWAY_CHASSIS,
    SBREC_TABLE_LOGICAL_FLOW,
    SBREC_TABLE_MAC_BINDING,
    SBREC_TABLE_METER,
    SBREC_TABLE_METER_BAND,
    SBREC_TABLE_MULTICAST_GROUP,
    SBREC_TABLE_PORT_BINDING,
    SBREC_TABLE_PORT_GROUP,
    SBREC_TABLE_RBAC_PERMISSION,
    SBREC_TABLE_RBAC_ROLE,
    SBREC_TABLE_SB_GLOBAL,
    SBREC_TABLE_SSL,
    SBREC_N_TABLES
};

#define sbrec_table_rbac_role (sbrec_table_classes[SBREC_TABLE_RBAC_ROLE])
#define sbrec_table_address_set (sbrec_table_classes[SBREC_TABLE_ADDRESS_SET])
#define sbrec_table_port_binding (sbrec_table_classes[SBREC_TABLE_PORT_BINDING])
#define sbrec_table_gateway_chassis (sbrec_table_classes[SBREC_TABLE_GATEWAY_CHASSIS])
#define sbrec_table_dns (sbrec_table_classes[SBREC_TABLE_DNS])
#define sbrec_table_meter_band (sbrec_table_classes[SBREC_TABLE_METER_BAND])
#define sbrec_table_datapath_binding (sbrec_table_classes[SBREC_TABLE_DATAPATH_BINDING])
#define sbrec_table_rbac_permission (sbrec_table_classes[SBREC_TABLE_RBAC_PERMISSION])
#define sbrec_table_sb_global (sbrec_table_classes[SBREC_TABLE_SB_GLOBAL])
#define sbrec_table_port_group (sbrec_table_classes[SBREC_TABLE_PORT_GROUP])
#define sbrec_table_logical_flow (sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW])
#define sbrec_table_multicast_group (sbrec_table_classes[SBREC_TABLE_MULTICAST_GROUP])
#define sbrec_table_connection (sbrec_table_classes[SBREC_TABLE_CONNECTION])
#define sbrec_table_chassis (sbrec_table_classes[SBREC_TABLE_CHASSIS])
#define sbrec_table_dhcpv6_options (sbrec_table_classes[SBREC_TABLE_DHCPV6_OPTIONS])
#define sbrec_table_meter (sbrec_table_classes[SBREC_TABLE_METER])
#define sbrec_table_encap (sbrec_table_classes[SBREC_TABLE_ENCAP])
#define sbrec_table_mac_binding (sbrec_table_classes[SBREC_TABLE_MAC_BINDING])
#define sbrec_table_ssl (sbrec_table_classes[SBREC_TABLE_SSL])
#define sbrec_table_dhcp_options (sbrec_table_classes[SBREC_TABLE_DHCP_OPTIONS])

extern struct ovsdb_idl_table_class sbrec_table_classes[SBREC_N_TABLES];

extern struct ovsdb_idl_class sbrec_idl_class;

const char * sbrec_get_db_version(void);

#ifdef  __cplusplus
}
#endif

#endif /* SBREC_IDL_HEADER */
    """)

#Salam
def print_ovn_sb_idlc():
    print("""
/* Generated automatically -- do not modify!    -*- buffer-read-only: t -*- */

#include <config.h>
#include "ovn/lib/ovn-sb-idl.h"
#include "ovn/lib/ovn-nb-idl.h" //Salam
#include <limits.h>
#include "ovs-thread.h"
#include "ovsdb-data.h"
#include "ovsdb-error.h"
#include "util.h"





static struct sbrec_address_set *
sbrec_address_set_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_address_set, header_) : NULL;
}

static struct sbrec_chassis *
sbrec_chassis_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_chassis, header_) : NULL;
}

static struct sbrec_connection *
sbrec_connection_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_connection, header_) : NULL;
}

static struct sbrec_dhcp_options *
sbrec_dhcp_options_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_dhcp_options, header_) : NULL;
}

static struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_dhcpv6_options, header_) : NULL;
}

static struct sbrec_dns *
sbrec_dns_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_dns, header_) : NULL;
}

static struct sbrec_datapath_binding *
sbrec_datapath_binding_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_datapath_binding, header_) : NULL;
}

static struct sbrec_encap *
sbrec_encap_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_encap, header_) : NULL;
}

static struct sbrec_gateway_chassis *
sbrec_gateway_chassis_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_gateway_chassis, header_) : NULL;
}

static struct sbrec_logical_flow *
sbrec_logical_flow_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_logical_flow, header_) : NULL;
}

static struct sbrec_mac_binding *
sbrec_mac_binding_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_mac_binding, header_) : NULL;
}

static struct sbrec_meter *
sbrec_meter_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_meter, header_) : NULL;
}

static struct sbrec_meter_band *
sbrec_meter_band_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_meter_band, header_) : NULL;
}

static struct sbrec_multicast_group *
sbrec_multicast_group_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_multicast_group, header_) : NULL;
}

static struct sbrec_port_binding *
sbrec_port_binding_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_port_binding, header_) : NULL;
}

static struct sbrec_port_group *
sbrec_port_group_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_port_group, header_) : NULL;
}

static struct sbrec_rbac_permission *
sbrec_rbac_permission_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_rbac_permission, header_) : NULL;
}

static struct sbrec_rbac_role *
sbrec_rbac_role_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_rbac_role, header_) : NULL;
}

static struct sbrec_sb_global *
sbrec_sb_global_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_sb_global, header_) : NULL;
}

static struct sbrec_ssl *
sbrec_ssl_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct sbrec_ssl, header_) : NULL;
}

/* Address_Set table. */

const struct sbrec_address_set_table *
sbrec_address_set_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_address_set_table *) idl;
}

const struct sbrec_address_set *
sbrec_address_set_table_first(const struct sbrec_address_set_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_address_set_first(idl);
}


const struct sbrec_address_set *
sbrec_address_set_table_track_get_first(const struct sbrec_address_set_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_address_set_track_get_first(idl);
}


static void
sbrec_address_set_parse_addresses(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_address_set *row = sbrec_address_set_cast(row_);
    row->addresses = NULL;
    row->n_addresses = 0;
    for (size_t i = 0; i < datum->n; i++) {
        if (!row->n_addresses) {
            row->addresses = xmalloc(datum->n * sizeof *row->addresses);
        }
        row->addresses[row->n_addresses] = datum->keys[i].string;
        row->n_addresses++;
    }
}

static void
sbrec_address_set_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_address_set *row = sbrec_address_set_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_address_set_unparse_addresses(struct ovsdb_idl_row *row_)
{
    struct sbrec_address_set *row = sbrec_address_set_cast(row_);
    free(row->addresses);
}

static void
sbrec_address_set_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_address_set_init__(struct ovsdb_idl_row *row)
{
    sbrec_address_set_init(sbrec_address_set_cast(row));
}

/* Clears the contents of 'row' in table "Address_Set". */
void
sbrec_address_set_init(struct sbrec_address_set *row)
{
    memset(row, 0, sizeof *row); 
    row->name = "";
}

/* Searches table "Address_Set" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_address_set *
sbrec_address_set_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_address_set_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_address_set, uuid));
}

/* Searches table "Address_Set" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_address_set *
sbrec_address_set_table_get_for_uuid(const struct sbrec_address_set_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_address_set_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Address_Set" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_address_set *
sbrec_address_set_first(const struct ovsdb_idl *idl)
{
    return sbrec_address_set_cast(ovsdb_idl_first_row(idl, &sbrec_table_address_set));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_address_set *
sbrec_address_set_next(const struct sbrec_address_set *row)
{
    return sbrec_address_set_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_address_set_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_address_set);
}

unsigned int sbrec_address_set_row_get_seqno(const struct sbrec_address_set *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_address_set *
sbrec_address_set_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_address_set_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_address_set));
}

const struct sbrec_address_set
*sbrec_address_set_track_get_next(const struct sbrec_address_set *row)
{
    return sbrec_address_set_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Address_Set".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_address_set_delete(const struct sbrec_address_set *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Address_Set" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_address_set *
sbrec_address_set_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_address_set_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_address_set, NULL));
}

bool
sbrec_address_set_is_updated(const struct sbrec_address_set *row, enum sbrec_address_set_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_address_set_columns[column]);
}

/* Causes the original contents of column "addresses" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "addresses" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "addresses" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "addresses" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_address_set_insert()).
 *
 *   - If "addresses" has already been modified (with
 *     sbrec_address_set_set_addresses()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_address_set_set_addresses() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_address_set_verify_addresses(const struct sbrec_address_set *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_address_set_col_addresses);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_address_set_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_address_set_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_address_set_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_address_set_verify_name(const struct sbrec_address_set *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_address_set_col_name);
}

/* Returns the "addresses" column's value from the "Address_Set" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes addresses's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "addresses" member in sbrec_address_set. */
const struct ovsdb_datum *
sbrec_address_set_get_addresses(const struct sbrec_address_set *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_address_set_col_addresses);
}

/* Returns the "name" column's value from the "Address_Set" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_address_set. */
const struct ovsdb_datum *
sbrec_address_set_get_name(const struct sbrec_address_set *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_address_set_col_name);
}

/* Sets the "addresses" column from the "Address_Set" table in 'row' to
 * the 'addresses' set with 'n_addresses' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_address_set_set_addresses(const struct sbrec_address_set *row, const char **addresses, size_t n_addresses)
{
    struct ovsdb_datum datum;

    datum.n = n_addresses;
    datum.keys = n_addresses ? xmalloc(n_addresses * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_addresses; i++) {
        datum.keys[i].string = xstrdup(addresses[i]);
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_address_set_col_addresses, &datum);
}

/* Sets the "name" column from the "Address_Set" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_address_set_set_name(const struct sbrec_address_set *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_address_set_col_name, &datum);
}

/* Adds the value 'new_value' to the "addresses" set column from the "Address_Set" table
 * in 'row'.
 *
 */
void
sbrec_address_set_update_addresses_addvalue(const struct sbrec_address_set *row, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_address_set_col_addresses,
                                    datum);
}

/* Deletes the value 'delete_value' from the "addresses" set column from the
 * "Address_Set" table in 'row'.
 *
 */
void
sbrec_address_set_update_addresses_delvalue(const struct sbrec_address_set *row, const char *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_value);

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_address_set_col_addresses,
                                    datum);
}

/* Sets the "addresses" column from the "Address_Set" table in 'row' to
 * the 'addresses' set with 'n_addresses' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_address_set_add_clause_addresses(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char **addresses, size_t n_addresses)
{
    struct ovsdb_datum datum;
    datum.n = n_addresses;
    datum.keys = n_addresses ? xmalloc(n_addresses * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_addresses; i++) {
        datum.keys[i].string = CONST_CAST(char *, addresses[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_address_set_col_addresses,
                          &datum);
    free(datum.keys);
}

/* Sets the "name" column from the "Address_Set" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_address_set_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_address_set_col_name,
                          &datum);
}

/* Destroy 'row' of kind "Address_Set". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_address_set_index_destroy_row(const struct sbrec_address_set *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Address_Set". */
struct sbrec_address_set *
sbrec_address_set_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_address_set);
    return ALIGNED_CAST(struct sbrec_address_set *, ovsdb_idl_index_init_row(index));
}

struct sbrec_address_set *
sbrec_address_set_index_find(struct ovsdb_idl_index *index, const struct sbrec_address_set *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_address_set);
    return sbrec_address_set_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_address_set_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_address_set *a, 
    const struct sbrec_address_set *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_address_set_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_address_set);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_address_set_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_address_set *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_address_set);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_address_set_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_address_set *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_address_set);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_address_set *
sbrec_address_set_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_address_set_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "addresses" column from the "Address_Set" table in 'row' to
 * the 'addresses' set with 'n_addresses' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_address_set_index_set_addresses(const struct sbrec_address_set *row, const char **addresses, size_t n_addresses)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_addresses;
    datum.keys = n_addresses ? xmalloc(n_addresses * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_addresses; i++) {
        datum.keys[i].string = xstrdup(addresses[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_address_set_columns[ SBREC_ADDRESS_SET_COL_ADDRESSES ], &datum, &sbrec_table_classes[SBREC_TABLE_ADDRESS_SET]);
}

/* Sets the "name" column from the "Address_Set" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_address_set_index_set_name(const struct sbrec_address_set *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_address_set_columns[ SBREC_ADDRESS_SET_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_ADDRESS_SET]);
}

struct ovsdb_idl_column sbrec_address_set_columns[SBREC_ADDRESS_SET_N_COLUMNS];

void
sbrec_address_set_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_address_set, condition);
}

struct ovsdb_idl_column sbrec_address_set_columns[SBREC_ADDRESS_SET_N_COLUMNS] = {
    [SBREC_ADDRESS_SET_COL_ADDRESSES] = {
         .name = "addresses",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_address_set_parse_addresses,
         .unparse = sbrec_address_set_unparse_addresses,
    },

    [SBREC_ADDRESS_SET_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_address_set_parse_name,
         .unparse = sbrec_address_set_unparse_name,
    },

};

/* Chassis table. */

const struct sbrec_chassis_table *
sbrec_chassis_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_chassis_table *) idl;
}

const struct sbrec_chassis *
sbrec_chassis_table_first(const struct sbrec_chassis_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_chassis_first(idl);
}


const struct sbrec_chassis *
sbrec_chassis_table_track_get_first(const struct sbrec_chassis_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_chassis_track_get_first(idl);
}


static void
sbrec_chassis_parse_encaps(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);
    row->encaps = NULL;
    row->n_encaps = 0;
    for (size_t i = 0; i < datum->n; i++) {
        struct sbrec_encap *keyRow = sbrec_encap_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_encap, &datum->keys[i].uuid));
        if (!keyRow) {
            continue;
        }
        if (!row->n_encaps) {
            row->encaps = xmalloc(datum->n * sizeof *row->encaps);
        }
        row->encaps[row->n_encaps] = keyRow;
        row->n_encaps++;
    }
}

static void
sbrec_chassis_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_chassis_parse_hostname(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);

    if (datum->n >= 1) {
        row->hostname = datum->keys[0].string;
    } else {
        row->hostname = "";
    }
}

static void
sbrec_chassis_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_chassis_parse_nb_cfg(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);

    if (datum->n >= 1) {
        row->nb_cfg = datum->keys[0].integer;
    } else {
        row->nb_cfg = 0;
    }
}

static void
sbrec_chassis_parse_vtep_logical_switches(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);
    row->vtep_logical_switches = NULL;
    row->n_vtep_logical_switches = 0;
    for (size_t i = 0; i < datum->n; i++) {
        if (!row->n_vtep_logical_switches) {
            row->vtep_logical_switches = xmalloc(datum->n * sizeof *row->vtep_logical_switches);
        }
        row->vtep_logical_switches[row->n_vtep_logical_switches] = datum->keys[i].string;
        row->n_vtep_logical_switches++;
    }
}

static void
sbrec_chassis_unparse_encaps(struct ovsdb_idl_row *row_)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);
    free(row->encaps);
}

static void
sbrec_chassis_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_chassis_unparse_hostname(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_chassis_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_chassis_unparse_nb_cfg(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_chassis_unparse_vtep_logical_switches(struct ovsdb_idl_row *row_)
{
    struct sbrec_chassis *row = sbrec_chassis_cast(row_);
    free(row->vtep_logical_switches);
}

static void
sbrec_chassis_init__(struct ovsdb_idl_row *row)
{
    sbrec_chassis_init(sbrec_chassis_cast(row));
}

/* Clears the contents of 'row' in table "Chassis". */
void
sbrec_chassis_init(struct sbrec_chassis *row)
{
    memset(row, 0, sizeof *row); 
    smap_init(&row->external_ids);
    row->hostname = "";
    row->name = "";
}

/* Searches table "Chassis" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_chassis *
sbrec_chassis_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_chassis_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_chassis, uuid));
}

/* Searches table "Chassis" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_chassis *
sbrec_chassis_table_get_for_uuid(const struct sbrec_chassis_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_chassis_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Chassis" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_chassis *
sbrec_chassis_first(const struct ovsdb_idl *idl)
{
    return sbrec_chassis_cast(ovsdb_idl_first_row(idl, &sbrec_table_chassis));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_chassis *
sbrec_chassis_next(const struct sbrec_chassis *row)
{
    return sbrec_chassis_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_chassis_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_chassis);
}

unsigned int sbrec_chassis_row_get_seqno(const struct sbrec_chassis *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_chassis *
sbrec_chassis_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_chassis_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_chassis));
}

const struct sbrec_chassis
*sbrec_chassis_track_get_next(const struct sbrec_chassis *row)
{
    return sbrec_chassis_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Chassis".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_chassis_delete(const struct sbrec_chassis *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Chassis" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_chassis *
sbrec_chassis_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_chassis_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_chassis, NULL));
}

bool
sbrec_chassis_is_updated(const struct sbrec_chassis *row, enum sbrec_chassis_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_chassis_columns[column]);
}

/* Causes the original contents of column "encaps" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "encaps" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "encaps" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "encaps" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_chassis_insert()).
 *
 *   - If "encaps" has already been modified (with
 *     sbrec_chassis_set_encaps()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_chassis_set_encaps() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_chassis_verify_encaps(const struct sbrec_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_chassis_col_encaps);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_chassis_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_chassis_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_chassis_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_chassis_verify_external_ids(const struct sbrec_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_chassis_col_external_ids);
}

/* Causes the original contents of column "hostname" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "hostname" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "hostname" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "hostname" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_chassis_insert()).
 *
 *   - If "hostname" has already been modified (with
 *     sbrec_chassis_set_hostname()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_chassis_set_hostname() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_chassis_verify_hostname(const struct sbrec_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_chassis_col_hostname);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_chassis_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_chassis_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_chassis_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_chassis_verify_name(const struct sbrec_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_chassis_col_name);
}

/* Causes the original contents of column "nb_cfg" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "nb_cfg" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "nb_cfg" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "nb_cfg" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_chassis_insert()).
 *
 *   - If "nb_cfg" has already been modified (with
 *     sbrec_chassis_set_nb_cfg()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_chassis_set_nb_cfg() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_chassis_verify_nb_cfg(const struct sbrec_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_chassis_col_nb_cfg);
}

/* Causes the original contents of column "vtep_logical_switches" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "vtep_logical_switches" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "vtep_logical_switches" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "vtep_logical_switches" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_chassis_insert()).
 *
 *   - If "vtep_logical_switches" has already been modified (with
 *     sbrec_chassis_set_vtep_logical_switches()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_chassis_set_vtep_logical_switches() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_chassis_verify_vtep_logical_switches(const struct sbrec_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_chassis_col_vtep_logical_switches);
}

/* Returns the "encaps" column's value from the "Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes encaps's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "encaps" member in sbrec_chassis. */
const struct ovsdb_datum *
sbrec_chassis_get_encaps(const struct sbrec_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_chassis_col_encaps);
}

/* Returns the "external_ids" column's value from the "Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_chassis. */
const struct ovsdb_datum *
sbrec_chassis_get_external_ids(const struct sbrec_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_chassis_col_external_ids);
}

/* Returns the "hostname" column's value from the "Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes hostname's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "hostname" member in sbrec_chassis. */
const struct ovsdb_datum *
sbrec_chassis_get_hostname(const struct sbrec_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_chassis_col_hostname);
}

/* Returns the "name" column's value from the "Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_chassis. */
const struct ovsdb_datum *
sbrec_chassis_get_name(const struct sbrec_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_chassis_col_name);
}

/* Returns the "nb_cfg" column's value from the "Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes nb_cfg's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "nb_cfg" member in sbrec_chassis. */
const struct ovsdb_datum *
sbrec_chassis_get_nb_cfg(const struct sbrec_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_chassis_col_nb_cfg);
}

/* Returns the "vtep_logical_switches" column's value from the "Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes vtep_logical_switches's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "vtep_logical_switches" member in sbrec_chassis. */
const struct ovsdb_datum *
sbrec_chassis_get_vtep_logical_switches(const struct sbrec_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_chassis_col_vtep_logical_switches);
}

/* Sets the "encaps" column from the "Chassis" table in 'row' to
 * the 'encaps' set with 'n_encaps' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_set_encaps(const struct sbrec_chassis *row, struct sbrec_encap **encaps, size_t n_encaps)
{
    struct ovsdb_datum datum;

    datum.n = n_encaps;
    datum.keys = n_encaps ? xmalloc(n_encaps * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_encaps; i++) {
        datum.keys[i].uuid = encaps[i]->header_.uuid;
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_chassis_col_encaps, &datum);
}

/* Sets the "external_ids" column's value from the "Chassis" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_chassis_set_external_ids(const struct sbrec_chassis *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_chassis_col_external_ids,
                        &datum);
}


/* Sets the "hostname" column from the "Chassis" table in 'row' to
 * 'hostname'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_set_hostname(const struct sbrec_chassis *row, const char *hostname)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, hostname);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_chassis_col_hostname, &datum);
}

/* Sets the "name" column from the "Chassis" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_set_name(const struct sbrec_chassis *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_chassis_col_name, &datum);
}

/* Sets the "nb_cfg" column from the "Chassis" table in 'row' to
 * 'nb_cfg'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_set_nb_cfg(const struct sbrec_chassis *row, int64_t nb_cfg)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = nb_cfg;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_chassis_col_nb_cfg, &datum);
}

/* Sets the "vtep_logical_switches" column from the "Chassis" table in 'row' to
 * the 'vtep_logical_switches' set with 'n_vtep_logical_switches' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_set_vtep_logical_switches(const struct sbrec_chassis *row, const char **vtep_logical_switches, size_t n_vtep_logical_switches)
{
    struct ovsdb_datum datum;

    datum.n = n_vtep_logical_switches;
    datum.keys = n_vtep_logical_switches ? xmalloc(n_vtep_logical_switches * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_vtep_logical_switches; i++) {
        datum.keys[i].string = xstrdup(vtep_logical_switches[i]);
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_chassis_col_vtep_logical_switches, &datum);
}

/* Adds the value 'new_value' to the "encaps" set column from the "Chassis" table
 * in 'row'.
 *
 */
void
sbrec_chassis_update_encaps_addvalue(const struct sbrec_chassis *row, const struct sbrec_encap *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_chassis_col_encaps,
                                    datum);
}

/* Deletes the value 'delete_value' from the "encaps" set column from the
 * "Chassis" table in 'row'.
 *
 */
void
sbrec_chassis_update_encaps_delvalue(const struct sbrec_chassis *row, const struct sbrec_encap *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_chassis_col_encaps,
                                    datum);
}

/* Sets an element of the "external_ids" map column from the "Chassis" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_chassis_update_external_ids_setkey(const struct sbrec_chassis *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_chassis_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "Chassis" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_chassis_update_external_ids_delkey(const struct sbrec_chassis *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_chassis_col_external_ids,
                                    datum);
}

/* Adds the value 'new_value' to the "vtep_logical_switches" set column from the "Chassis" table
 * in 'row'.
 *
 */
void
sbrec_chassis_update_vtep_logical_switches_addvalue(const struct sbrec_chassis *row, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_chassis_col_vtep_logical_switches,
                                    datum);
}

/* Deletes the value 'delete_value' from the "vtep_logical_switches" set column from the
 * "Chassis" table in 'row'.
 *
 */
void
sbrec_chassis_update_vtep_logical_switches_delvalue(const struct sbrec_chassis *row, const char *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_value);

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_chassis_col_vtep_logical_switches,
                                    datum);
}

/* Sets the "encaps" column from the "Chassis" table in 'row' to
 * the 'encaps' set with 'n_encaps' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_add_clause_encaps(struct ovsdb_idl_condition *cond, enum ovsdb_function function, struct uuid **encaps, size_t n_encaps)
{
    struct ovsdb_datum datum;
    datum.n = n_encaps;
    datum.keys = n_encaps ? xmalloc(n_encaps * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_encaps; i++) {
        datum.keys[i].uuid = *encaps[i];
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_chassis_col_encaps,
                          &datum);
    free(datum.keys);
}

/* Sets the "external_ids" column's value from the "Chassis" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_chassis_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_chassis_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_chassis_col_external_ids.type);
}


/* Sets the "hostname" column from the "Chassis" table in 'row' to
 * 'hostname'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_add_clause_hostname(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *hostname)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, hostname);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_chassis_col_hostname,
                          &datum);
}

/* Sets the "name" column from the "Chassis" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_chassis_col_name,
                          &datum);
}

/* Sets the "nb_cfg" column from the "Chassis" table in 'row' to
 * 'nb_cfg'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_add_clause_nb_cfg(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t nb_cfg)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = nb_cfg;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_chassis_col_nb_cfg,
                          &datum);
}

/* Sets the "vtep_logical_switches" column from the "Chassis" table in 'row' to
 * the 'vtep_logical_switches' set with 'n_vtep_logical_switches' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_add_clause_vtep_logical_switches(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char **vtep_logical_switches, size_t n_vtep_logical_switches)
{
    struct ovsdb_datum datum;
    datum.n = n_vtep_logical_switches;
    datum.keys = n_vtep_logical_switches ? xmalloc(n_vtep_logical_switches * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_vtep_logical_switches; i++) {
        datum.keys[i].string = CONST_CAST(char *, vtep_logical_switches[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_chassis_col_vtep_logical_switches,
                          &datum);
    free(datum.keys);
}

/* Destroy 'row' of kind "Chassis". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_chassis_index_destroy_row(const struct sbrec_chassis *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Chassis". */
struct sbrec_chassis *
sbrec_chassis_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_chassis);
    return ALIGNED_CAST(struct sbrec_chassis *, ovsdb_idl_index_init_row(index));
}

struct sbrec_chassis *
sbrec_chassis_index_find(struct ovsdb_idl_index *index, const struct sbrec_chassis *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_chassis);
    return sbrec_chassis_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_chassis_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_chassis *a, 
    const struct sbrec_chassis *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_chassis_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_chassis);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_chassis_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_chassis *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_chassis);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_chassis_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_chassis *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_chassis);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_chassis *
sbrec_chassis_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_chassis_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "encaps" column from the "Chassis" table in 'row' to
 * the 'encaps' set with 'n_encaps' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_index_set_encaps(const struct sbrec_chassis *row, struct sbrec_encap **encaps, size_t n_encaps)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_encaps;
    datum.keys = n_encaps ? xmalloc(n_encaps * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_encaps; i++) {
        datum.keys[i].uuid = encaps[i]->header_.uuid;
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_chassis_columns[ SBREC_CHASSIS_COL_ENCAPS ], &datum, &sbrec_table_classes[SBREC_TABLE_CHASSIS]);
}

/* Sets the "external_ids" column's value from the "Chassis" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_chassis_index_set_external_ids(const struct sbrec_chassis *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_chassis_columns[SBREC_CHASSIS_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_CHASSIS]);
}


/* Sets the "hostname" column from the "Chassis" table in 'row' to
 * 'hostname'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_index_set_hostname(const struct sbrec_chassis *row, const char *hostname)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, hostname);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_chassis_columns[ SBREC_CHASSIS_COL_HOSTNAME ], &datum, &sbrec_table_classes[SBREC_TABLE_CHASSIS]);
}

/* Sets the "name" column from the "Chassis" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_index_set_name(const struct sbrec_chassis *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_chassis_columns[ SBREC_CHASSIS_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_CHASSIS]);
}

/* Sets the "nb_cfg" column from the "Chassis" table in 'row' to
 * 'nb_cfg'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_index_set_nb_cfg(const struct sbrec_chassis *row, int64_t nb_cfg)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = nb_cfg;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_chassis_columns[ SBREC_CHASSIS_COL_NB_CFG ], &datum, &sbrec_table_classes[SBREC_TABLE_CHASSIS]);
}

/* Sets the "vtep_logical_switches" column from the "Chassis" table in 'row' to
 * the 'vtep_logical_switches' set with 'n_vtep_logical_switches' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_chassis_index_set_vtep_logical_switches(const struct sbrec_chassis *row, const char **vtep_logical_switches, size_t n_vtep_logical_switches)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_vtep_logical_switches;
    datum.keys = n_vtep_logical_switches ? xmalloc(n_vtep_logical_switches * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_vtep_logical_switches; i++) {
        datum.keys[i].string = xstrdup(vtep_logical_switches[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_chassis_columns[ SBREC_CHASSIS_COL_VTEP_LOGICAL_SWITCHES ], &datum, &sbrec_table_classes[SBREC_TABLE_CHASSIS]);
}

struct ovsdb_idl_column sbrec_chassis_columns[SBREC_CHASSIS_N_COLUMNS];

void
sbrec_chassis_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_chassis, condition);
}

struct ovsdb_idl_column sbrec_chassis_columns[SBREC_CHASSIS_N_COLUMNS] = {
    [SBREC_CHASSIS_COL_ENCAPS] = {
         .name = "encaps",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Encap", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_chassis_parse_encaps,
         .unparse = sbrec_chassis_unparse_encaps,
    },

    [SBREC_CHASSIS_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_chassis_parse_external_ids,
         .unparse = sbrec_chassis_unparse_external_ids,
    },

    [SBREC_CHASSIS_COL_HOSTNAME] = {
         .name = "hostname",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_chassis_parse_hostname,
         .unparse = sbrec_chassis_unparse_hostname,
    },

    [SBREC_CHASSIS_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_chassis_parse_name,
         .unparse = sbrec_chassis_unparse_name,
    },

    [SBREC_CHASSIS_COL_NB_CFG] = {
         .name = "nb_cfg",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_MIN, .max = INT64_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_chassis_parse_nb_cfg,
         .unparse = sbrec_chassis_unparse_nb_cfg,
    },

    [SBREC_CHASSIS_COL_VTEP_LOGICAL_SWITCHES] = {
         .name = "vtep_logical_switches",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_chassis_parse_vtep_logical_switches,
         .unparse = sbrec_chassis_unparse_vtep_logical_switches,
    },

};

/* Connection table. */

const struct sbrec_connection_table *
sbrec_connection_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_connection_table *) idl;
}

const struct sbrec_connection *
sbrec_connection_table_first(const struct sbrec_connection_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_connection_first(idl);
}


const struct sbrec_connection *
sbrec_connection_table_track_get_first(const struct sbrec_connection_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_connection_track_get_first(idl);
}


static void
sbrec_connection_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_connection_parse_inactivity_probe(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    size_t n = MIN(1, datum->n);
    row->inactivity_probe = NULL;
    row->n_inactivity_probe = 0;
    for (size_t i = 0; i < n; i++) {
        if (!row->n_inactivity_probe) {
            row->inactivity_probe = xmalloc(n * sizeof *row->inactivity_probe);
        }
        row->inactivity_probe[row->n_inactivity_probe] = datum->keys[i].integer;
        row->n_inactivity_probe++;
    }
}

static void
sbrec_connection_parse_is_connected(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);

    if (datum->n >= 1) {
        row->is_connected = datum->keys[0].boolean;
    } else {
        row->is_connected = false;
    }
}

static void
sbrec_connection_parse_max_backoff(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    size_t n = MIN(1, datum->n);
    row->max_backoff = NULL;
    row->n_max_backoff = 0;
    for (size_t i = 0; i < n; i++) {
        if (!row->n_max_backoff) {
            row->max_backoff = xmalloc(n * sizeof *row->max_backoff);
        }
        row->max_backoff[row->n_max_backoff] = datum->keys[i].integer;
        row->n_max_backoff++;
    }
}

static void
sbrec_connection_parse_other_config(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    smap_init(&row->other_config);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->other_config,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_connection_parse_read_only(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);

    if (datum->n >= 1) {
        row->read_only = datum->keys[0].boolean;
    } else {
        row->read_only = false;
    }
}

static void
sbrec_connection_parse_role(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);

    if (datum->n >= 1) {
        row->role = datum->keys[0].string;
    } else {
        row->role = "";
    }
}

static void
sbrec_connection_parse_status(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    smap_init(&row->status);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->status,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_connection_parse_target(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);

    if (datum->n >= 1) {
        row->target = datum->keys[0].string;
    } else {
        row->target = "";
    }
}

static void
sbrec_connection_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_connection_unparse_inactivity_probe(struct ovsdb_idl_row *row_)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    free(row->inactivity_probe);
}

static void
sbrec_connection_unparse_is_connected(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_connection_unparse_max_backoff(struct ovsdb_idl_row *row_)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    free(row->max_backoff);
}

static void
sbrec_connection_unparse_other_config(struct ovsdb_idl_row *row_)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    smap_destroy(&row->other_config);
}

static void
sbrec_connection_unparse_read_only(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_connection_unparse_role(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_connection_unparse_status(struct ovsdb_idl_row *row_)
{
    struct sbrec_connection *row = sbrec_connection_cast(row_);
    smap_destroy(&row->status);
}

static void
sbrec_connection_unparse_target(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_connection_init__(struct ovsdb_idl_row *row)
{
    sbrec_connection_init(sbrec_connection_cast(row));
}

/* Clears the contents of 'row' in table "Connection". */
void
sbrec_connection_init(struct sbrec_connection *row)
{
    memset(row, 0, sizeof *row); 
    smap_init(&row->external_ids);
    smap_init(&row->other_config);
    row->role = "";
    smap_init(&row->status);
    row->target = "";
}

/* Searches table "Connection" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_connection *
sbrec_connection_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_connection_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_connection, uuid));
}

/* Searches table "Connection" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_connection *
sbrec_connection_table_get_for_uuid(const struct sbrec_connection_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_connection_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Connection" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_connection *
sbrec_connection_first(const struct ovsdb_idl *idl)
{
    return sbrec_connection_cast(ovsdb_idl_first_row(idl, &sbrec_table_connection));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_connection *
sbrec_connection_next(const struct sbrec_connection *row)
{
    return sbrec_connection_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_connection_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_connection);
}

unsigned int sbrec_connection_row_get_seqno(const struct sbrec_connection *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_connection *
sbrec_connection_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_connection_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_connection));
}

const struct sbrec_connection
*sbrec_connection_track_get_next(const struct sbrec_connection *row)
{
    return sbrec_connection_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Connection".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_delete(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Connection" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_connection *
sbrec_connection_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_connection_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_connection, NULL));
}

bool
sbrec_connection_is_updated(const struct sbrec_connection *row, enum sbrec_connection_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_connection_columns[column]);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_connection_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_external_ids(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_external_ids);
}

/* Causes the original contents of column "inactivity_probe" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "inactivity_probe" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "inactivity_probe" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "inactivity_probe" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "inactivity_probe" has already been modified (with
 *     sbrec_connection_set_inactivity_probe()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_inactivity_probe() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_inactivity_probe(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_inactivity_probe);
}

/* Causes the original contents of column "is_connected" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "is_connected" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "is_connected" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "is_connected" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "is_connected" has already been modified (with
 *     sbrec_connection_set_is_connected()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_is_connected() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_is_connected(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_is_connected);
}

/* Causes the original contents of column "max_backoff" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "max_backoff" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "max_backoff" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "max_backoff" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "max_backoff" has already been modified (with
 *     sbrec_connection_set_max_backoff()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_max_backoff() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_max_backoff(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_max_backoff);
}

/* Causes the original contents of column "other_config" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "other_config" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "other_config" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "other_config" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "other_config" has already been modified (with
 *     sbrec_connection_set_other_config()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_other_config() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_other_config(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_other_config);
}

/* Causes the original contents of column "read_only" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "read_only" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "read_only" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "read_only" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "read_only" has already been modified (with
 *     sbrec_connection_set_read_only()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_read_only() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_read_only(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_read_only);
}

/* Causes the original contents of column "role" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "role" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "role" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "role" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "role" has already been modified (with
 *     sbrec_connection_set_role()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_role() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_role(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_role);
}

/* Causes the original contents of column "status" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "status" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "status" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "status" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "status" has already been modified (with
 *     sbrec_connection_set_status()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_status() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_status(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_status);
}

/* Causes the original contents of column "target" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "target" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "target" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "target" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_connection_insert()).
 *
 *   - If "target" has already been modified (with
 *     sbrec_connection_set_target()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_connection_set_target() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_connection_verify_target(const struct sbrec_connection *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_connection_col_target);
}

/* Returns the "external_ids" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_external_ids(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_external_ids);
}

/* Returns the "inactivity_probe" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes inactivity_probe's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "inactivity_probe" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_inactivity_probe(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_inactivity_probe);
}

/* Returns the "is_connected" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_BOOLEAN.
 * (This helps to avoid silent bugs if someone changes is_connected's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "is_connected" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_is_connected(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_BOOLEAN);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_is_connected);
}

/* Returns the "max_backoff" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes max_backoff's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "max_backoff" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_max_backoff(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_max_backoff);
}

/* Returns the "other_config" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes other_config's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "other_config" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_other_config(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_other_config);
}

/* Returns the "read_only" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_BOOLEAN.
 * (This helps to avoid silent bugs if someone changes read_only's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "read_only" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_read_only(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_BOOLEAN);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_read_only);
}

/* Returns the "role" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes role's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "role" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_role(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_role);
}

/* Returns the "status" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes status's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "status" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_status(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_status);
}

/* Returns the "target" column's value from the "Connection" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes target's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "target" member in sbrec_connection. */
const struct ovsdb_datum *
sbrec_connection_get_target(const struct sbrec_connection *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_connection_col_target);
}

/* Sets the "external_ids" column's value from the "Connection" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_connection_set_external_ids(const struct sbrec_connection *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_connection_col_external_ids,
                        &datum);
}


/* Sets the "inactivity_probe" column from the "Connection" table in 'row' to
 * the 'inactivity_probe' set with 'n_inactivity_probe' entries.
 *
 * 'n_inactivity_probe' may be 0 or 1; if it is 0, then 'inactivity_probe'
 * may be NULL.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_set_inactivity_probe(const struct sbrec_connection *row, const int64_t *inactivity_probe, size_t n_inactivity_probe)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (n_inactivity_probe) {
        datum.n = 1;
        datum.keys = &key;
        key.integer = *inactivity_probe;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_connection_col_inactivity_probe, &datum);
}

/* Sets the "is_connected" column from the "Connection" table in 'row' to
 * 'is_connected'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_set_is_connected(const struct sbrec_connection *row, bool is_connected)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = is_connected;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_connection_col_is_connected, &datum);
}

/* Sets the "max_backoff" column from the "Connection" table in 'row' to
 * the 'max_backoff' set with 'n_max_backoff' entries.
 *
 * 'n_max_backoff' may be 0 or 1; if it is 0, then 'max_backoff'
 * may be NULL.
 *
 * Argument constraints: at least 1,000
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_set_max_backoff(const struct sbrec_connection *row, const int64_t *max_backoff, size_t n_max_backoff)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (n_max_backoff) {
        datum.n = 1;
        datum.keys = &key;
        key.integer = *max_backoff;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_connection_col_max_backoff, &datum);
}

/* Sets the "other_config" column's value from the "Connection" table in 'row'
 * to 'other_config'.
 *
 * The caller retains ownership of 'other_config' and everything in it. */
void
sbrec_connection_set_other_config(const struct sbrec_connection *row, const struct smap *other_config)
{
    struct ovsdb_datum datum;

    if (other_config) {
        ovsdb_datum_from_smap(&datum, other_config);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_connection_col_other_config,
                        &datum);
}


/* Sets the "read_only" column from the "Connection" table in 'row' to
 * 'read_only'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_set_read_only(const struct sbrec_connection *row, bool read_only)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = read_only;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_connection_col_read_only, &datum);
}

/* Sets the "role" column from the "Connection" table in 'row' to
 * 'role'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_set_role(const struct sbrec_connection *row, const char *role)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, role);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_connection_col_role, &datum);
}

/* Sets the "status" column's value from the "Connection" table in 'row'
 * to 'status'.
 *
 * The caller retains ownership of 'status' and everything in it. */
void
sbrec_connection_set_status(const struct sbrec_connection *row, const struct smap *status)
{
    struct ovsdb_datum datum;

    if (status) {
        ovsdb_datum_from_smap(&datum, status);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_connection_col_status,
                        &datum);
}


/* Sets the "target" column from the "Connection" table in 'row' to
 * 'target'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_set_target(const struct sbrec_connection *row, const char *target)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, target);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_connection_col_target, &datum);
}

/* Sets an element of the "external_ids" map column from the "Connection" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_connection_update_external_ids_setkey(const struct sbrec_connection *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_connection_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "Connection" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_connection_update_external_ids_delkey(const struct sbrec_connection *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_connection_col_external_ids,
                                    datum);
}

/* Adds the value 'new_value' to the "inactivity_probe" set column from the "Connection" table
 * in 'row'.
 *
 */
void
sbrec_connection_update_inactivity_probe_addvalue(const struct sbrec_connection *row, int64_t new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].integer = new_value;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_connection_col_inactivity_probe,
                                    datum);
}

/* Deletes the value 'delete_value' from the "inactivity_probe" set column from the
 * "Connection" table in 'row'.
 *
 */
void
sbrec_connection_update_inactivity_probe_delvalue(const struct sbrec_connection *row, int64_t delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].integer = delete_value;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_connection_col_inactivity_probe,
                                    datum);
}

/* Adds the value 'new_value' to the "max_backoff" set column from the "Connection" table
 * in 'row'.
 *
 */
void
sbrec_connection_update_max_backoff_addvalue(const struct sbrec_connection *row, int64_t new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].integer = new_value;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_connection_col_max_backoff,
                                    datum);
}

/* Deletes the value 'delete_value' from the "max_backoff" set column from the
 * "Connection" table in 'row'.
 *
 */
void
sbrec_connection_update_max_backoff_delvalue(const struct sbrec_connection *row, int64_t delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].integer = delete_value;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_connection_col_max_backoff,
                                    datum);
}

/* Sets an element of the "other_config" map column from the "Connection" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_connection_update_other_config_setkey(const struct sbrec_connection *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_connection_col_other_config,
                                    datum);
}

/* Deletes an element of the "other_config" map column from the "Connection" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_connection_update_other_config_delkey(const struct sbrec_connection *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_connection_col_other_config,
                                    datum);
}

/* Sets an element of the "status" map column from the "Connection" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_connection_update_status_setkey(const struct sbrec_connection *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_connection_col_status,
                                    datum);
}

/* Deletes an element of the "status" map column from the "Connection" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_connection_update_status_delkey(const struct sbrec_connection *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_connection_col_status,
                                    datum);
}

/* Sets the "external_ids" column's value from the "Connection" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_connection_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_connection_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_connection_col_external_ids.type);
}


/* Sets the "inactivity_probe" column from the "Connection" table in 'row' to
 * the 'inactivity_probe' set with 'n_inactivity_probe' entries.
 *
 * 'n_inactivity_probe' may be 0 or 1; if it is 0, then 'inactivity_probe'
 * may be NULL.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_add_clause_inactivity_probe(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const int64_t *inactivity_probe, size_t n_inactivity_probe)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (n_inactivity_probe) {
        datum.n = 1;
        datum.keys = &key;
        key.integer = *inactivity_probe;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_connection_col_inactivity_probe,
                          &datum);
}

/* Sets the "is_connected" column from the "Connection" table in 'row' to
 * 'is_connected'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_add_clause_is_connected(struct ovsdb_idl_condition *cond, enum ovsdb_function function, bool is_connected)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = is_connected;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_connection_col_is_connected,
                          &datum);
}

/* Sets the "max_backoff" column from the "Connection" table in 'row' to
 * the 'max_backoff' set with 'n_max_backoff' entries.
 *
 * 'n_max_backoff' may be 0 or 1; if it is 0, then 'max_backoff'
 * may be NULL.
 *
 * Argument constraints: at least 1,000
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_add_clause_max_backoff(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const int64_t *max_backoff, size_t n_max_backoff)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (n_max_backoff) {
        datum.n = 1;
        datum.keys = &key;
        key.integer = *max_backoff;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_connection_col_max_backoff,
                          &datum);
}

/* Sets the "other_config" column's value from the "Connection" table in 'row'
 * to 'other_config'.
 *
 * The caller retains ownership of 'other_config' and everything in it. */
void
sbrec_connection_add_clause_other_config(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *other_config)
{
    struct ovsdb_datum datum;

    if (other_config) {
        ovsdb_datum_from_smap(&datum, other_config);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_connection_col_other_config,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_connection_col_other_config.type);
}


/* Sets the "read_only" column from the "Connection" table in 'row' to
 * 'read_only'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_add_clause_read_only(struct ovsdb_idl_condition *cond, enum ovsdb_function function, bool read_only)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = read_only;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_connection_col_read_only,
                          &datum);
}

/* Sets the "role" column from the "Connection" table in 'row' to
 * 'role'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_add_clause_role(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *role)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, role);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_connection_col_role,
                          &datum);
}

/* Sets the "status" column's value from the "Connection" table in 'row'
 * to 'status'.
 *
 * The caller retains ownership of 'status' and everything in it. */
void
sbrec_connection_add_clause_status(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *status)
{
    struct ovsdb_datum datum;

    if (status) {
        ovsdb_datum_from_smap(&datum, status);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_connection_col_status,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_connection_col_status.type);
}


/* Sets the "target" column from the "Connection" table in 'row' to
 * 'target'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_add_clause_target(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *target)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, target);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_connection_col_target,
                          &datum);
}

/* Destroy 'row' of kind "Connection". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_connection_index_destroy_row(const struct sbrec_connection *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Connection". */
struct sbrec_connection *
sbrec_connection_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_connection);
    return ALIGNED_CAST(struct sbrec_connection *, ovsdb_idl_index_init_row(index));
}

struct sbrec_connection *
sbrec_connection_index_find(struct ovsdb_idl_index *index, const struct sbrec_connection *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_connection);
    return sbrec_connection_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_connection_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_connection *a, 
    const struct sbrec_connection *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_connection_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_connection);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_connection_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_connection *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_connection);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_connection_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_connection *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_connection);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_connection *
sbrec_connection_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_connection_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "external_ids" column's value from the "Connection" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_connection_index_set_external_ids(const struct sbrec_connection *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_connection_columns[SBREC_CONNECTION_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}


/* Sets the "inactivity_probe" column from the "Connection" table in 'row' to
 * the 'inactivity_probe' set with 'n_inactivity_probe' entries.
 *
 * 'n_inactivity_probe' may be 0 or 1; if it is 0, then 'inactivity_probe'
 * may be NULL.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_index_set_inactivity_probe(const struct sbrec_connection *row, const int64_t *inactivity_probe, size_t n_inactivity_probe)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    if (n_inactivity_probe) {
        datum.n = 1;
        datum.keys = key;
        key->integer = *inactivity_probe;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_connection_columns[ SBREC_CONNECTION_COL_INACTIVITY_PROBE ], &datum, &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}

/* Sets the "is_connected" column from the "Connection" table in 'row' to
 * 'is_connected'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_index_set_is_connected(const struct sbrec_connection *row, bool is_connected)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->boolean = is_connected;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_connection_columns[ SBREC_CONNECTION_COL_IS_CONNECTED ], &datum, &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}

/* Sets the "max_backoff" column from the "Connection" table in 'row' to
 * the 'max_backoff' set with 'n_max_backoff' entries.
 *
 * 'n_max_backoff' may be 0 or 1; if it is 0, then 'max_backoff'
 * may be NULL.
 *
 * Argument constraints: at least 1,000
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_index_set_max_backoff(const struct sbrec_connection *row, const int64_t *max_backoff, size_t n_max_backoff)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    if (n_max_backoff) {
        datum.n = 1;
        datum.keys = key;
        key->integer = *max_backoff;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_connection_columns[ SBREC_CONNECTION_COL_MAX_BACKOFF ], &datum, &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}

/* Sets the "other_config" column's value from the "Connection" table in 'row'
 * to 'other_config'.
 *
 * The caller retains ownership of 'other_config' and everything in it. */
void
sbrec_connection_index_set_other_config(const struct sbrec_connection *row, const struct smap *other_config)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (other_config) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(other_config);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, other_config) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_connection_columns[SBREC_CONNECTION_COL_OTHER_CONFIG],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}


/* Sets the "read_only" column from the "Connection" table in 'row' to
 * 'read_only'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_index_set_read_only(const struct sbrec_connection *row, bool read_only)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->boolean = read_only;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_connection_columns[ SBREC_CONNECTION_COL_READ_ONLY ], &datum, &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}

/* Sets the "role" column from the "Connection" table in 'row' to
 * 'role'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_index_set_role(const struct sbrec_connection *row, const char *role)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, role);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_connection_columns[ SBREC_CONNECTION_COL_ROLE ], &datum, &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}

/* Sets the "status" column's value from the "Connection" table in 'row'
 * to 'status'.
 *
 * The caller retains ownership of 'status' and everything in it. */
void
sbrec_connection_index_set_status(const struct sbrec_connection *row, const struct smap *status)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (status) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(status);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, status) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_connection_columns[SBREC_CONNECTION_COL_STATUS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}


/* Sets the "target" column from the "Connection" table in 'row' to
 * 'target'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_connection_index_set_target(const struct sbrec_connection *row, const char *target)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, target);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_connection_columns[ SBREC_CONNECTION_COL_TARGET ], &datum, &sbrec_table_classes[SBREC_TABLE_CONNECTION]);
}

struct ovsdb_idl_column sbrec_connection_columns[SBREC_CONNECTION_N_COLUMNS];

void
sbrec_connection_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_connection, condition);
}

struct ovsdb_idl_column sbrec_connection_columns[SBREC_CONNECTION_N_COLUMNS] = {
    [SBREC_CONNECTION_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_external_ids,
         .unparse = sbrec_connection_unparse_external_ids,
    },

    [SBREC_CONNECTION_COL_INACTIVITY_PROBE] = {
         .name = "inactivity_probe",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_MIN, .max = INT64_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_inactivity_probe,
         .unparse = sbrec_connection_unparse_inactivity_probe,
    },

    [SBREC_CONNECTION_COL_IS_CONNECTED] = {
         .name = "is_connected",
         .type = {
            .key = {
               .type = OVSDB_TYPE_BOOLEAN,
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_is_connected,
         .unparse = sbrec_connection_unparse_is_connected,
    },

    [SBREC_CONNECTION_COL_MAX_BACKOFF] = {
         .name = "max_backoff",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(1000), .max = INT64_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_max_backoff,
         .unparse = sbrec_connection_unparse_max_backoff,
    },

    [SBREC_CONNECTION_COL_OTHER_CONFIG] = {
         .name = "other_config",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_other_config,
         .unparse = sbrec_connection_unparse_other_config,
    },

    [SBREC_CONNECTION_COL_READ_ONLY] = {
         .name = "read_only",
         .type = {
            .key = {
               .type = OVSDB_TYPE_BOOLEAN,
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_read_only,
         .unparse = sbrec_connection_unparse_read_only,
    },

    [SBREC_CONNECTION_COL_ROLE] = {
         .name = "role",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_role,
         .unparse = sbrec_connection_unparse_role,
    },

    [SBREC_CONNECTION_COL_STATUS] = {
         .name = "status",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_status,
         .unparse = sbrec_connection_unparse_status,
    },

    [SBREC_CONNECTION_COL_TARGET] = {
         .name = "target",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_connection_parse_target,
         .unparse = sbrec_connection_unparse_target,
    },

};

/* DHCP_Options table. */

const struct sbrec_dhcp_options_table *
sbrec_dhcp_options_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_dhcp_options_table *) idl;
}

const struct sbrec_dhcp_options *
sbrec_dhcp_options_table_first(const struct sbrec_dhcp_options_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_dhcp_options_first(idl);
}


const struct sbrec_dhcp_options *
sbrec_dhcp_options_table_track_get_first(const struct sbrec_dhcp_options_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_dhcp_options_track_get_first(idl);
}


static void
sbrec_dhcp_options_parse_code(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dhcp_options *row = sbrec_dhcp_options_cast(row_);

    if (datum->n >= 1) {
        row->code = datum->keys[0].integer;
    } else {
        row->code = 0;
    }
}

static void
sbrec_dhcp_options_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dhcp_options *row = sbrec_dhcp_options_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_dhcp_options_parse_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dhcp_options *row = sbrec_dhcp_options_cast(row_);

    if (datum->n >= 1) {
        row->type = datum->keys[0].string;
    } else {
        row->type = "";
    }
}

static void
sbrec_dhcp_options_unparse_code(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_dhcp_options_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_dhcp_options_unparse_type(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_dhcp_options_init__(struct ovsdb_idl_row *row)
{
    sbrec_dhcp_options_init(sbrec_dhcp_options_cast(row));
}

/* Clears the contents of 'row' in table "DHCP_Options". */
void
sbrec_dhcp_options_init(struct sbrec_dhcp_options *row)
{
    memset(row, 0, sizeof *row); 
    row->name = "";
    row->type = "";
}

/* Searches table "DHCP_Options" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_dhcp_options *
sbrec_dhcp_options_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_dhcp_options_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_dhcp_options, uuid));
}

/* Searches table "DHCP_Options" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_dhcp_options *
sbrec_dhcp_options_table_get_for_uuid(const struct sbrec_dhcp_options_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_dhcp_options_get_for_uuid(idl, uuid);
}

/* Returns a row in table "DHCP_Options" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_dhcp_options *
sbrec_dhcp_options_first(const struct ovsdb_idl *idl)
{
    return sbrec_dhcp_options_cast(ovsdb_idl_first_row(idl, &sbrec_table_dhcp_options));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_dhcp_options *
sbrec_dhcp_options_next(const struct sbrec_dhcp_options *row)
{
    return sbrec_dhcp_options_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_dhcp_options_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_dhcp_options);
}

unsigned int sbrec_dhcp_options_row_get_seqno(const struct sbrec_dhcp_options *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_dhcp_options *
sbrec_dhcp_options_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_dhcp_options_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_dhcp_options));
}

const struct sbrec_dhcp_options
*sbrec_dhcp_options_track_get_next(const struct sbrec_dhcp_options *row)
{
    return sbrec_dhcp_options_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "DHCP_Options".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dhcp_options_delete(const struct sbrec_dhcp_options *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "DHCP_Options" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_dhcp_options *
sbrec_dhcp_options_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_dhcp_options_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_dhcp_options, NULL));
}

bool
sbrec_dhcp_options_is_updated(const struct sbrec_dhcp_options *row, enum sbrec_dhcp_options_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_dhcp_options_columns[column]);
}

/* Causes the original contents of column "code" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "code" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "code" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "code" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dhcp_options_insert()).
 *
 *   - If "code" has already been modified (with
 *     sbrec_dhcp_options_set_code()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dhcp_options_set_code() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dhcp_options_verify_code(const struct sbrec_dhcp_options *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dhcp_options_col_code);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dhcp_options_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_dhcp_options_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dhcp_options_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dhcp_options_verify_name(const struct sbrec_dhcp_options *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dhcp_options_col_name);
}

/* Causes the original contents of column "type" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "type" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "type" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "type" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dhcp_options_insert()).
 *
 *   - If "type" has already been modified (with
 *     sbrec_dhcp_options_set_type()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dhcp_options_set_type() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dhcp_options_verify_type(const struct sbrec_dhcp_options *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dhcp_options_col_type);
}

/* Returns the "code" column's value from the "DHCP_Options" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes code's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "code" member in sbrec_dhcp_options. */
const struct ovsdb_datum *
sbrec_dhcp_options_get_code(const struct sbrec_dhcp_options *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_dhcp_options_col_code);
}

/* Returns the "name" column's value from the "DHCP_Options" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_dhcp_options. */
const struct ovsdb_datum *
sbrec_dhcp_options_get_name(const struct sbrec_dhcp_options *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_dhcp_options_col_name);
}

/* Returns the "type" column's value from the "DHCP_Options" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes type's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "type" member in sbrec_dhcp_options. */
const struct ovsdb_datum *
sbrec_dhcp_options_get_type(const struct sbrec_dhcp_options *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_dhcp_options_col_type);
}

/* Sets the "code" column from the "DHCP_Options" table in 'row' to
 * 'code'.
 *
 * Argument constraints: in range 0 to 254
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_set_code(const struct sbrec_dhcp_options *row, int64_t code)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = code;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_dhcp_options_col_code, &datum);
}

/* Sets the "name" column from the "DHCP_Options" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_set_name(const struct sbrec_dhcp_options *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_dhcp_options_col_name, &datum);
}

/* Sets the "type" column from the "DHCP_Options" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "bool", "ipv4", "static_routes", "str", "uint16", "uint32", or "uint8"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_set_type(const struct sbrec_dhcp_options *row, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_dhcp_options_col_type, &datum);
}

/* Sets the "code" column from the "DHCP_Options" table in 'row' to
 * 'code'.
 *
 * Argument constraints: in range 0 to 254
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_add_clause_code(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t code)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = code;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_dhcp_options_col_code,
                          &datum);
}

/* Sets the "name" column from the "DHCP_Options" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_dhcp_options_col_name,
                          &datum);
}

/* Sets the "type" column from the "DHCP_Options" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "bool", "ipv4", "static_routes", "str", "uint16", "uint32", or "uint8"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_add_clause_type(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_dhcp_options_col_type,
                          &datum);
}

/* Destroy 'row' of kind "DHCP_Options". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_dhcp_options_index_destroy_row(const struct sbrec_dhcp_options *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "DHCP_Options". */
struct sbrec_dhcp_options *
sbrec_dhcp_options_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcp_options);
    return ALIGNED_CAST(struct sbrec_dhcp_options *, ovsdb_idl_index_init_row(index));
}

struct sbrec_dhcp_options *
sbrec_dhcp_options_index_find(struct ovsdb_idl_index *index, const struct sbrec_dhcp_options *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcp_options);
    return sbrec_dhcp_options_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_dhcp_options_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_dhcp_options *a, 
    const struct sbrec_dhcp_options *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_dhcp_options_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcp_options);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_dhcp_options_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_dhcp_options *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcp_options);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_dhcp_options_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_dhcp_options *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcp_options);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_dhcp_options *
sbrec_dhcp_options_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_dhcp_options_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "code" column from the "DHCP_Options" table in 'row' to
 * 'code'.
 *
 * Argument constraints: in range 0 to 254
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_index_set_code(const struct sbrec_dhcp_options *row, int64_t code)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = code;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_dhcp_options_columns[ SBREC_DHCP_OPTIONS_COL_CODE ], &datum, &sbrec_table_classes[SBREC_TABLE_DHCP_OPTIONS]);
}

/* Sets the "name" column from the "DHCP_Options" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_index_set_name(const struct sbrec_dhcp_options *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_dhcp_options_columns[ SBREC_DHCP_OPTIONS_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_DHCP_OPTIONS]);
}

/* Sets the "type" column from the "DHCP_Options" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "bool", "ipv4", "static_routes", "str", "uint16", "uint32", or "uint8"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcp_options_index_set_type(const struct sbrec_dhcp_options *row, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_dhcp_options_columns[ SBREC_DHCP_OPTIONS_COL_TYPE ], &datum, &sbrec_table_classes[SBREC_TABLE_DHCP_OPTIONS]);
}

struct ovsdb_idl_column sbrec_dhcp_options_columns[SBREC_DHCP_OPTIONS_N_COLUMNS];

void
sbrec_dhcp_options_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_dhcp_options, condition);
}
static union ovsdb_atom DHCP_Options_col_type_key_enum_keys[7] = {
    { .string = "bool" },
    { .string = "ipv4" },
    { .string = "static_routes" },
    { .string = "str" },
    { .string = "uint16" },
    { .string = "uint32" },
    { .string = "uint8" },
};
static struct ovsdb_datum DHCP_Options_col_type_key_enum = {
    .n = 7,
    .keys = DHCP_Options_col_type_key_enum_keys,
};

struct ovsdb_idl_column sbrec_dhcp_options_columns[SBREC_DHCP_OPTIONS_N_COLUMNS] = {
    [SBREC_DHCP_OPTIONS_COL_CODE] = {
         .name = "code",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(0), .max = INT64_C(254) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dhcp_options_parse_code,
         .unparse = sbrec_dhcp_options_unparse_code,
    },

    [SBREC_DHCP_OPTIONS_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dhcp_options_parse_name,
         .unparse = sbrec_dhcp_options_unparse_name,
    },

    [SBREC_DHCP_OPTIONS_COL_TYPE] = {
         .name = "type",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .enum_ = &DHCP_Options_col_type_key_enum,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dhcp_options_parse_type,
         .unparse = sbrec_dhcp_options_unparse_type,
    },

};

/* DHCPv6_Options table. */

const struct sbrec_dhcpv6_options_table *
sbrec_dhcpv6_options_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_dhcpv6_options_table *) idl;
}

const struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_table_first(const struct sbrec_dhcpv6_options_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_dhcpv6_options_first(idl);
}


const struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_table_track_get_first(const struct sbrec_dhcpv6_options_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_dhcpv6_options_track_get_first(idl);
}


static void
sbrec_dhcpv6_options_parse_code(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dhcpv6_options *row = sbrec_dhcpv6_options_cast(row_);

    if (datum->n >= 1) {
        row->code = datum->keys[0].integer;
    } else {
        row->code = 0;
    }
}

static void
sbrec_dhcpv6_options_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dhcpv6_options *row = sbrec_dhcpv6_options_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_dhcpv6_options_parse_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dhcpv6_options *row = sbrec_dhcpv6_options_cast(row_);

    if (datum->n >= 1) {
        row->type = datum->keys[0].string;
    } else {
        row->type = "";
    }
}

static void
sbrec_dhcpv6_options_unparse_code(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_dhcpv6_options_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_dhcpv6_options_unparse_type(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_dhcpv6_options_init__(struct ovsdb_idl_row *row)
{
    sbrec_dhcpv6_options_init(sbrec_dhcpv6_options_cast(row));
}

/* Clears the contents of 'row' in table "DHCPv6_Options". */
void
sbrec_dhcpv6_options_init(struct sbrec_dhcpv6_options *row)
{
    memset(row, 0, sizeof *row); 
    row->name = "";
    row->type = "";
}

/* Searches table "DHCPv6_Options" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_dhcpv6_options_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_dhcpv6_options, uuid));
}

/* Searches table "DHCPv6_Options" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_table_get_for_uuid(const struct sbrec_dhcpv6_options_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_dhcpv6_options_get_for_uuid(idl, uuid);
}

/* Returns a row in table "DHCPv6_Options" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_first(const struct ovsdb_idl *idl)
{
    return sbrec_dhcpv6_options_cast(ovsdb_idl_first_row(idl, &sbrec_table_dhcpv6_options));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_next(const struct sbrec_dhcpv6_options *row)
{
    return sbrec_dhcpv6_options_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_dhcpv6_options_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_dhcpv6_options);
}

unsigned int sbrec_dhcpv6_options_row_get_seqno(const struct sbrec_dhcpv6_options *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_dhcpv6_options_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_dhcpv6_options));
}

const struct sbrec_dhcpv6_options
*sbrec_dhcpv6_options_track_get_next(const struct sbrec_dhcpv6_options *row)
{
    return sbrec_dhcpv6_options_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "DHCPv6_Options".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dhcpv6_options_delete(const struct sbrec_dhcpv6_options *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "DHCPv6_Options" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_dhcpv6_options_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_dhcpv6_options, NULL));
}

bool
sbrec_dhcpv6_options_is_updated(const struct sbrec_dhcpv6_options *row, enum sbrec_dhcpv6_options_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_dhcpv6_options_columns[column]);
}

/* Causes the original contents of column "code" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "code" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "code" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "code" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dhcpv6_options_insert()).
 *
 *   - If "code" has already been modified (with
 *     sbrec_dhcpv6_options_set_code()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dhcpv6_options_set_code() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dhcpv6_options_verify_code(const struct sbrec_dhcpv6_options *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dhcpv6_options_col_code);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dhcpv6_options_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_dhcpv6_options_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dhcpv6_options_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dhcpv6_options_verify_name(const struct sbrec_dhcpv6_options *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dhcpv6_options_col_name);
}

/* Causes the original contents of column "type" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "type" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "type" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "type" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dhcpv6_options_insert()).
 *
 *   - If "type" has already been modified (with
 *     sbrec_dhcpv6_options_set_type()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dhcpv6_options_set_type() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dhcpv6_options_verify_type(const struct sbrec_dhcpv6_options *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dhcpv6_options_col_type);
}

/* Returns the "code" column's value from the "DHCPv6_Options" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes code's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "code" member in sbrec_dhcpv6_options. */
const struct ovsdb_datum *
sbrec_dhcpv6_options_get_code(const struct sbrec_dhcpv6_options *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_dhcpv6_options_col_code);
}

/* Returns the "name" column's value from the "DHCPv6_Options" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_dhcpv6_options. */
const struct ovsdb_datum *
sbrec_dhcpv6_options_get_name(const struct sbrec_dhcpv6_options *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_dhcpv6_options_col_name);
}

/* Returns the "type" column's value from the "DHCPv6_Options" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes type's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "type" member in sbrec_dhcpv6_options. */
const struct ovsdb_datum *
sbrec_dhcpv6_options_get_type(const struct sbrec_dhcpv6_options *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_dhcpv6_options_col_type);
}

/* Sets the "code" column from the "DHCPv6_Options" table in 'row' to
 * 'code'.
 *
 * Argument constraints: in range 0 to 254
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_set_code(const struct sbrec_dhcpv6_options *row, int64_t code)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = code;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_dhcpv6_options_col_code, &datum);
}

/* Sets the "name" column from the "DHCPv6_Options" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_set_name(const struct sbrec_dhcpv6_options *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_dhcpv6_options_col_name, &datum);
}

/* Sets the "type" column from the "DHCPv6_Options" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "ipv6", "mac", or "str"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_set_type(const struct sbrec_dhcpv6_options *row, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_dhcpv6_options_col_type, &datum);
}

/* Sets the "code" column from the "DHCPv6_Options" table in 'row' to
 * 'code'.
 *
 * Argument constraints: in range 0 to 254
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_add_clause_code(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t code)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = code;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_dhcpv6_options_col_code,
                          &datum);
}

/* Sets the "name" column from the "DHCPv6_Options" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_dhcpv6_options_col_name,
                          &datum);
}

/* Sets the "type" column from the "DHCPv6_Options" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "ipv6", "mac", or "str"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_add_clause_type(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_dhcpv6_options_col_type,
                          &datum);
}

/* Destroy 'row' of kind "DHCPv6_Options". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_dhcpv6_options_index_destroy_row(const struct sbrec_dhcpv6_options *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "DHCPv6_Options". */
struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcpv6_options);
    return ALIGNED_CAST(struct sbrec_dhcpv6_options *, ovsdb_idl_index_init_row(index));
}

struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_index_find(struct ovsdb_idl_index *index, const struct sbrec_dhcpv6_options *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcpv6_options);
    return sbrec_dhcpv6_options_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_dhcpv6_options_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_dhcpv6_options *a, 
    const struct sbrec_dhcpv6_options *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_dhcpv6_options_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcpv6_options);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_dhcpv6_options_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_dhcpv6_options *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcpv6_options);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_dhcpv6_options_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_dhcpv6_options *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dhcpv6_options);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_dhcpv6_options *
sbrec_dhcpv6_options_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_dhcpv6_options_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "code" column from the "DHCPv6_Options" table in 'row' to
 * 'code'.
 *
 * Argument constraints: in range 0 to 254
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_index_set_code(const struct sbrec_dhcpv6_options *row, int64_t code)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = code;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_dhcpv6_options_columns[ SBREC_DHCPV6_OPTIONS_COL_CODE ], &datum, &sbrec_table_classes[SBREC_TABLE_DHCPV6_OPTIONS]);
}

/* Sets the "name" column from the "DHCPv6_Options" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_index_set_name(const struct sbrec_dhcpv6_options *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_dhcpv6_options_columns[ SBREC_DHCPV6_OPTIONS_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_DHCPV6_OPTIONS]);
}

/* Sets the "type" column from the "DHCPv6_Options" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "ipv6", "mac", or "str"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dhcpv6_options_index_set_type(const struct sbrec_dhcpv6_options *row, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_dhcpv6_options_columns[ SBREC_DHCPV6_OPTIONS_COL_TYPE ], &datum, &sbrec_table_classes[SBREC_TABLE_DHCPV6_OPTIONS]);
}

struct ovsdb_idl_column sbrec_dhcpv6_options_columns[SBREC_DHCPV6_OPTIONS_N_COLUMNS];

void
sbrec_dhcpv6_options_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_dhcpv6_options, condition);
}
static union ovsdb_atom DHCPv6_Options_col_type_key_enum_keys[3] = {
    { .string = "ipv6" },
    { .string = "mac" },
    { .string = "str" },
};
static struct ovsdb_datum DHCPv6_Options_col_type_key_enum = {
    .n = 3,
    .keys = DHCPv6_Options_col_type_key_enum_keys,
};

struct ovsdb_idl_column sbrec_dhcpv6_options_columns[SBREC_DHCPV6_OPTIONS_N_COLUMNS] = {
    [SBREC_DHCPV6_OPTIONS_COL_CODE] = {
         .name = "code",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(0), .max = INT64_C(254) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dhcpv6_options_parse_code,
         .unparse = sbrec_dhcpv6_options_unparse_code,
    },

    [SBREC_DHCPV6_OPTIONS_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dhcpv6_options_parse_name,
         .unparse = sbrec_dhcpv6_options_unparse_name,
    },

    [SBREC_DHCPV6_OPTIONS_COL_TYPE] = {
         .name = "type",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .enum_ = &DHCPv6_Options_col_type_key_enum,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dhcpv6_options_parse_type,
         .unparse = sbrec_dhcpv6_options_unparse_type,
    },

};

/* DNS table. */

const struct sbrec_dns_table *
sbrec_dns_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_dns_table *) idl;
}

const struct sbrec_dns *
sbrec_dns_table_first(const struct sbrec_dns_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_dns_first(idl);
}


const struct sbrec_dns *
sbrec_dns_table_track_get_first(const struct sbrec_dns_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_dns_track_get_first(idl);
}


static void
sbrec_dns_parse_datapaths(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dns *row = sbrec_dns_cast(row_);
    row->datapaths = NULL;
    row->n_datapaths = 0;
    for (size_t i = 0; i < datum->n; i++) {
        struct sbrec_datapath_binding *keyRow = sbrec_datapath_binding_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_datapath_binding, &datum->keys[i].uuid));
        if (!keyRow) {
            continue;
        }
        if (!row->n_datapaths) {
            row->datapaths = xmalloc(datum->n * sizeof *row->datapaths);
        }
        row->datapaths[row->n_datapaths] = keyRow;
        row->n_datapaths++;
    }
}

static void
sbrec_dns_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dns *row = sbrec_dns_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_dns_parse_records(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_dns *row = sbrec_dns_cast(row_);
    smap_init(&row->records);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->records,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_dns_unparse_datapaths(struct ovsdb_idl_row *row_)
{
    struct sbrec_dns *row = sbrec_dns_cast(row_);
    free(row->datapaths);
}

static void
sbrec_dns_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_dns *row = sbrec_dns_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_dns_unparse_records(struct ovsdb_idl_row *row_)
{
    struct sbrec_dns *row = sbrec_dns_cast(row_);
    smap_destroy(&row->records);
}

static void
sbrec_dns_init__(struct ovsdb_idl_row *row)
{
    sbrec_dns_init(sbrec_dns_cast(row));
}

/* Clears the contents of 'row' in table "DNS". */
void
sbrec_dns_init(struct sbrec_dns *row)
{
    memset(row, 0, sizeof *row); 
    smap_init(&row->external_ids);
    smap_init(&row->records);
}

/* Searches table "DNS" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_dns *
sbrec_dns_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_dns_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_dns, uuid));
}

/* Searches table "DNS" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_dns *
sbrec_dns_table_get_for_uuid(const struct sbrec_dns_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_dns_get_for_uuid(idl, uuid);
}

/* Returns a row in table "DNS" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_dns *
sbrec_dns_first(const struct ovsdb_idl *idl)
{
    return sbrec_dns_cast(ovsdb_idl_first_row(idl, &sbrec_table_dns));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_dns *
sbrec_dns_next(const struct sbrec_dns *row)
{
    return sbrec_dns_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_dns_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_dns);
}

unsigned int sbrec_dns_row_get_seqno(const struct sbrec_dns *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_dns *
sbrec_dns_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_dns_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_dns));
}

const struct sbrec_dns
*sbrec_dns_track_get_next(const struct sbrec_dns *row)
{
    return sbrec_dns_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "DNS".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dns_delete(const struct sbrec_dns *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "DNS" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_dns *
sbrec_dns_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_dns_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_dns, NULL));
}

bool
sbrec_dns_is_updated(const struct sbrec_dns *row, enum sbrec_dns_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_dns_columns[column]);
}

/* Causes the original contents of column "datapaths" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "datapaths" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "datapaths" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "datapaths" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dns_insert()).
 *
 *   - If "datapaths" has already been modified (with
 *     sbrec_dns_set_datapaths()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dns_set_datapaths() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dns_verify_datapaths(const struct sbrec_dns *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dns_col_datapaths);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dns_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_dns_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dns_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dns_verify_external_ids(const struct sbrec_dns *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dns_col_external_ids);
}

/* Causes the original contents of column "records" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "records" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "records" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "records" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_dns_insert()).
 *
 *   - If "records" has already been modified (with
 *     sbrec_dns_set_records()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_dns_set_records() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_dns_verify_records(const struct sbrec_dns *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_dns_col_records);
}

/* Returns the "datapaths" column's value from the "DNS" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes datapaths's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "datapaths" member in sbrec_dns. */
const struct ovsdb_datum *
sbrec_dns_get_datapaths(const struct sbrec_dns *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_dns_col_datapaths);
}

/* Returns the "external_ids" column's value from the "DNS" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_dns. */
const struct ovsdb_datum *
sbrec_dns_get_external_ids(const struct sbrec_dns *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_dns_col_external_ids);
}

/* Returns the "records" column's value from the "DNS" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes records's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "records" member in sbrec_dns. */
const struct ovsdb_datum *
sbrec_dns_get_records(const struct sbrec_dns *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_dns_col_records);
}

/* Sets the "datapaths" column from the "DNS" table in 'row' to
 * the 'datapaths' set with 'n_datapaths' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dns_set_datapaths(const struct sbrec_dns *row, struct sbrec_datapath_binding **datapaths, size_t n_datapaths)
{
    struct ovsdb_datum datum;

    datum.n = n_datapaths;
    datum.keys = n_datapaths ? xmalloc(n_datapaths * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_datapaths; i++) {
        datum.keys[i].uuid = datapaths[i]->header_.uuid;
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_dns_col_datapaths, &datum);
}

/* Sets the "external_ids" column's value from the "DNS" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_dns_set_external_ids(const struct sbrec_dns *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_dns_col_external_ids,
                        &datum);
}


/* Sets the "records" column's value from the "DNS" table in 'row'
 * to 'records'.
 *
 * The caller retains ownership of 'records' and everything in it. */
void
sbrec_dns_set_records(const struct sbrec_dns *row, const struct smap *records)
{
    struct ovsdb_datum datum;

    if (records) {
        ovsdb_datum_from_smap(&datum, records);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_dns_col_records,
                        &datum);
}


/* Adds the value 'new_value' to the "datapaths" set column from the "DNS" table
 * in 'row'.
 *
 */
void
sbrec_dns_update_datapaths_addvalue(const struct sbrec_dns *row, const struct sbrec_datapath_binding *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_dns_col_datapaths,
                                    datum);
}

/* Deletes the value 'delete_value' from the "datapaths" set column from the
 * "DNS" table in 'row'.
 *
 */
void
sbrec_dns_update_datapaths_delvalue(const struct sbrec_dns *row, const struct sbrec_datapath_binding *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_dns_col_datapaths,
                                    datum);
}

/* Sets an element of the "external_ids" map column from the "DNS" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_dns_update_external_ids_setkey(const struct sbrec_dns *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_dns_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "DNS" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_dns_update_external_ids_delkey(const struct sbrec_dns *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_dns_col_external_ids,
                                    datum);
}

/* Sets an element of the "records" map column from the "DNS" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_dns_update_records_setkey(const struct sbrec_dns *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_dns_col_records,
                                    datum);
}

/* Deletes an element of the "records" map column from the "DNS" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_dns_update_records_delkey(const struct sbrec_dns *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_dns_col_records,
                                    datum);
}

/* Sets the "datapaths" column from the "DNS" table in 'row' to
 * the 'datapaths' set with 'n_datapaths' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dns_add_clause_datapaths(struct ovsdb_idl_condition *cond, enum ovsdb_function function, struct uuid **datapaths, size_t n_datapaths)
{
    struct ovsdb_datum datum;
    datum.n = n_datapaths;
    datum.keys = n_datapaths ? xmalloc(n_datapaths * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_datapaths; i++) {
        datum.keys[i].uuid = *datapaths[i];
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_dns_col_datapaths,
                          &datum);
    free(datum.keys);
}

/* Sets the "external_ids" column's value from the "DNS" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_dns_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_dns_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_dns_col_external_ids.type);
}


/* Sets the "records" column's value from the "DNS" table in 'row'
 * to 'records'.
 *
 * The caller retains ownership of 'records' and everything in it. */
void
sbrec_dns_add_clause_records(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *records)
{
    struct ovsdb_datum datum;

    if (records) {
        ovsdb_datum_from_smap(&datum, records);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_dns_col_records,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_dns_col_records.type);
}


/* Destroy 'row' of kind "DNS". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_dns_index_destroy_row(const struct sbrec_dns *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "DNS". */
struct sbrec_dns *
sbrec_dns_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_dns);
    return ALIGNED_CAST(struct sbrec_dns *, ovsdb_idl_index_init_row(index));
}

struct sbrec_dns *
sbrec_dns_index_find(struct ovsdb_idl_index *index, const struct sbrec_dns *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dns);
    return sbrec_dns_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_dns_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_dns *a, 
    const struct sbrec_dns *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_dns_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_dns);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_dns_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_dns *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dns);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_dns_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_dns *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_dns);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_dns *
sbrec_dns_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_dns_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "datapaths" column from the "DNS" table in 'row' to
 * the 'datapaths' set with 'n_datapaths' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_dns_index_set_datapaths(const struct sbrec_dns *row, struct sbrec_datapath_binding **datapaths, size_t n_datapaths)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_datapaths;
    datum.keys = n_datapaths ? xmalloc(n_datapaths * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_datapaths; i++) {
        datum.keys[i].uuid = datapaths[i]->header_.uuid;
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_dns_columns[ SBREC_DNS_COL_DATAPATHS ], &datum, &sbrec_table_classes[SBREC_TABLE_DNS]);
}

/* Sets the "external_ids" column's value from the "DNS" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_dns_index_set_external_ids(const struct sbrec_dns *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_dns_columns[SBREC_DNS_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_DNS]);
}


/* Sets the "records" column's value from the "DNS" table in 'row'
 * to 'records'.
 *
 * The caller retains ownership of 'records' and everything in it. */
void
sbrec_dns_index_set_records(const struct sbrec_dns *row, const struct smap *records)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (records) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(records);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, records) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_dns_columns[SBREC_DNS_COL_RECORDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_DNS]);
}


struct ovsdb_idl_column sbrec_dns_columns[SBREC_DNS_N_COLUMNS];

void
sbrec_dns_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_dns, condition);
}

struct ovsdb_idl_column sbrec_dns_columns[SBREC_DNS_N_COLUMNS] = {
    [SBREC_DNS_COL_DATAPATHS] = {
         .name = "datapaths",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Datapath_Binding", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dns_parse_datapaths,
         .unparse = sbrec_dns_unparse_datapaths,
    },

    [SBREC_DNS_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dns_parse_external_ids,
         .unparse = sbrec_dns_unparse_external_ids,
    },

    [SBREC_DNS_COL_RECORDS] = {
         .name = "records",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_dns_parse_records,
         .unparse = sbrec_dns_unparse_records,
    },

};

/* Datapath_Binding table. */

const struct sbrec_datapath_binding_table *
sbrec_datapath_binding_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_datapath_binding_table *) idl;
}

const struct sbrec_datapath_binding *
sbrec_datapath_binding_table_first(const struct sbrec_datapath_binding_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_datapath_binding_first(idl);
}


const struct sbrec_datapath_binding *
sbrec_datapath_binding_table_track_get_first(const struct sbrec_datapath_binding_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_datapath_binding_track_get_first(idl);
}


static void
sbrec_datapath_binding_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_datapath_binding *row = sbrec_datapath_binding_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_datapath_binding_parse_tunnel_key(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_datapath_binding *row = sbrec_datapath_binding_cast(row_);

    if (datum->n >= 1) {
        row->tunnel_key = datum->keys[0].integer;
    } else {
        row->tunnel_key = 0;
    }
}

static void
sbrec_datapath_binding_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_datapath_binding *row = sbrec_datapath_binding_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_datapath_binding_unparse_tunnel_key(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_datapath_binding_init__(struct ovsdb_idl_row *row)
{
    sbrec_datapath_binding_init(sbrec_datapath_binding_cast(row));
}

/* Clears the contents of 'row' in table "Datapath_Binding". */
void
sbrec_datapath_binding_init(struct sbrec_datapath_binding *row)
{
    memset(row, 0, sizeof *row); 
    smap_init(&row->external_ids);
}

/* Searches table "Datapath_Binding" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_datapath_binding *
sbrec_datapath_binding_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_datapath_binding_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_datapath_binding, uuid));
}

/* Searches table "Datapath_Binding" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_datapath_binding *
sbrec_datapath_binding_table_get_for_uuid(const struct sbrec_datapath_binding_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_datapath_binding_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Datapath_Binding" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_datapath_binding *
sbrec_datapath_binding_first(const struct ovsdb_idl *idl)
{
    return sbrec_datapath_binding_cast(ovsdb_idl_first_row(idl, &sbrec_table_datapath_binding));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_datapath_binding *
sbrec_datapath_binding_next(const struct sbrec_datapath_binding *row)
{
    return sbrec_datapath_binding_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_datapath_binding_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_datapath_binding);
}

unsigned int sbrec_datapath_binding_row_get_seqno(const struct sbrec_datapath_binding *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_datapath_binding *
sbrec_datapath_binding_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_datapath_binding_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_datapath_binding));
}

const struct sbrec_datapath_binding
*sbrec_datapath_binding_track_get_next(const struct sbrec_datapath_binding *row)
{
    return sbrec_datapath_binding_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Datapath_Binding".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_datapath_binding_delete(const struct sbrec_datapath_binding *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Datapath_Binding" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_datapath_binding *
sbrec_datapath_binding_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_datapath_binding_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_datapath_binding, NULL));
}

bool
sbrec_datapath_binding_is_updated(const struct sbrec_datapath_binding *row, enum sbrec_datapath_binding_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_datapath_binding_columns[column]);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_datapath_binding_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_datapath_binding_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_datapath_binding_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_datapath_binding_verify_external_ids(const struct sbrec_datapath_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_datapath_binding_col_external_ids);
}

/* Causes the original contents of column "tunnel_key" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "tunnel_key" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "tunnel_key" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "tunnel_key" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_datapath_binding_insert()).
 *
 *   - If "tunnel_key" has already been modified (with
 *     sbrec_datapath_binding_set_tunnel_key()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_datapath_binding_set_tunnel_key() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_datapath_binding_verify_tunnel_key(const struct sbrec_datapath_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_datapath_binding_col_tunnel_key);
}

/* Returns the "external_ids" column's value from the "Datapath_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_datapath_binding. */
const struct ovsdb_datum *
sbrec_datapath_binding_get_external_ids(const struct sbrec_datapath_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_datapath_binding_col_external_ids);
}

/* Returns the "tunnel_key" column's value from the "Datapath_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes tunnel_key's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "tunnel_key" member in sbrec_datapath_binding. */
const struct ovsdb_datum *
sbrec_datapath_binding_get_tunnel_key(const struct sbrec_datapath_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_datapath_binding_col_tunnel_key);
}

/* Sets the "external_ids" column's value from the "Datapath_Binding" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_datapath_binding_set_external_ids(const struct sbrec_datapath_binding *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_datapath_binding_col_external_ids,
                        &datum);
}


/* Sets the "tunnel_key" column from the "Datapath_Binding" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 1 to 16,777,215
 *
 * The caller retains ownership of the arguments. */
void
sbrec_datapath_binding_set_tunnel_key(const struct sbrec_datapath_binding *row, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_datapath_binding_col_tunnel_key, &datum);
}

/* Sets an element of the "external_ids" map column from the "Datapath_Binding" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_datapath_binding_update_external_ids_setkey(const struct sbrec_datapath_binding *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_datapath_binding_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "Datapath_Binding" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_datapath_binding_update_external_ids_delkey(const struct sbrec_datapath_binding *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_datapath_binding_col_external_ids,
                                    datum);
}

/* Sets the "external_ids" column's value from the "Datapath_Binding" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_datapath_binding_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_datapath_binding_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_datapath_binding_col_external_ids.type);
}


/* Sets the "tunnel_key" column from the "Datapath_Binding" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 1 to 16,777,215
 *
 * The caller retains ownership of the arguments. */
void
sbrec_datapath_binding_add_clause_tunnel_key(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_datapath_binding_col_tunnel_key,
                          &datum);
}

/* Destroy 'row' of kind "Datapath_Binding". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_datapath_binding_index_destroy_row(const struct sbrec_datapath_binding *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Datapath_Binding". */
struct sbrec_datapath_binding *
sbrec_datapath_binding_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_datapath_binding);
    return ALIGNED_CAST(struct sbrec_datapath_binding *, ovsdb_idl_index_init_row(index));
}

struct sbrec_datapath_binding *
sbrec_datapath_binding_index_find(struct ovsdb_idl_index *index, const struct sbrec_datapath_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_datapath_binding);
    return sbrec_datapath_binding_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_datapath_binding_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_datapath_binding *a, 
    const struct sbrec_datapath_binding *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_datapath_binding_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_datapath_binding);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_datapath_binding_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_datapath_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_datapath_binding);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_datapath_binding_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_datapath_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_datapath_binding);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_datapath_binding *
sbrec_datapath_binding_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_datapath_binding_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "external_ids" column's value from the "Datapath_Binding" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_datapath_binding_index_set_external_ids(const struct sbrec_datapath_binding *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_datapath_binding_columns[SBREC_DATAPATH_BINDING_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_DATAPATH_BINDING]);
}


/* Sets the "tunnel_key" column from the "Datapath_Binding" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 1 to 16,777,215
 *
 * The caller retains ownership of the arguments. */
void
sbrec_datapath_binding_index_set_tunnel_key(const struct sbrec_datapath_binding *row, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_datapath_binding_columns[ SBREC_DATAPATH_BINDING_COL_TUNNEL_KEY ], &datum, &sbrec_table_classes[SBREC_TABLE_DATAPATH_BINDING]);
}

struct ovsdb_idl_column sbrec_datapath_binding_columns[SBREC_DATAPATH_BINDING_N_COLUMNS];

void
sbrec_datapath_binding_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_datapath_binding, condition);
}

struct ovsdb_idl_column sbrec_datapath_binding_columns[SBREC_DATAPATH_BINDING_N_COLUMNS] = {
    [SBREC_DATAPATH_BINDING_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_datapath_binding_parse_external_ids,
         .unparse = sbrec_datapath_binding_unparse_external_ids,
    },

    [SBREC_DATAPATH_BINDING_COL_TUNNEL_KEY] = {
         .name = "tunnel_key",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(1), .max = INT64_C(16777215) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_datapath_binding_parse_tunnel_key,
         .unparse = sbrec_datapath_binding_unparse_tunnel_key,
    },

};

/* Encap table. */

const struct sbrec_encap_table *
sbrec_encap_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_encap_table *) idl;
}

const struct sbrec_encap *
sbrec_encap_table_first(const struct sbrec_encap_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_encap_first(idl);
}


const struct sbrec_encap *
sbrec_encap_table_track_get_first(const struct sbrec_encap_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_encap_track_get_first(idl);
}


static void
sbrec_encap_parse_chassis_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_encap *row = sbrec_encap_cast(row_);

    if (datum->n >= 1) {
        row->chassis_name = datum->keys[0].string;
    } else {
        row->chassis_name = "";
    }
}

static void
sbrec_encap_parse_ip(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_encap *row = sbrec_encap_cast(row_);

    if (datum->n >= 1) {
        row->ip = datum->keys[0].string;
    } else {
        row->ip = "";
    }
}

static void
sbrec_encap_parse_options(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_encap *row = sbrec_encap_cast(row_);
    smap_init(&row->options);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->options,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_encap_parse_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_encap *row = sbrec_encap_cast(row_);

    if (datum->n >= 1) {
        row->type = datum->keys[0].string;
    } else {
        row->type = "";
    }
}

static void
sbrec_encap_unparse_chassis_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_encap_unparse_ip(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_encap_unparse_options(struct ovsdb_idl_row *row_)
{
    struct sbrec_encap *row = sbrec_encap_cast(row_);
    smap_destroy(&row->options);
}

static void
sbrec_encap_unparse_type(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_encap_init__(struct ovsdb_idl_row *row)
{
    sbrec_encap_init(sbrec_encap_cast(row));
}

/* Clears the contents of 'row' in table "Encap". */
void
sbrec_encap_init(struct sbrec_encap *row)
{
    memset(row, 0, sizeof *row); 
    row->chassis_name = "";
    row->ip = "";
    smap_init(&row->options);
    row->type = "";
}

/* Searches table "Encap" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_encap *
sbrec_encap_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_encap_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_encap, uuid));
}

/* Searches table "Encap" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_encap *
sbrec_encap_table_get_for_uuid(const struct sbrec_encap_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_encap_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Encap" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_encap *
sbrec_encap_first(const struct ovsdb_idl *idl)
{
    return sbrec_encap_cast(ovsdb_idl_first_row(idl, &sbrec_table_encap));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_encap *
sbrec_encap_next(const struct sbrec_encap *row)
{
    return sbrec_encap_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_encap_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_encap);
}

unsigned int sbrec_encap_row_get_seqno(const struct sbrec_encap *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_encap *
sbrec_encap_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_encap_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_encap));
}

const struct sbrec_encap
*sbrec_encap_track_get_next(const struct sbrec_encap *row)
{
    return sbrec_encap_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Encap".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_encap_delete(const struct sbrec_encap *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Encap" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_encap *
sbrec_encap_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_encap_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_encap, NULL));
}

bool
sbrec_encap_is_updated(const struct sbrec_encap *row, enum sbrec_encap_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_encap_columns[column]);
}

/* Causes the original contents of column "chassis_name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "chassis_name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "chassis_name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "chassis_name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_encap_insert()).
 *
 *   - If "chassis_name" has already been modified (with
 *     sbrec_encap_set_chassis_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_encap_set_chassis_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_encap_verify_chassis_name(const struct sbrec_encap *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_encap_col_chassis_name);
}

/* Causes the original contents of column "ip" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ip" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ip" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ip" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_encap_insert()).
 *
 *   - If "ip" has already been modified (with
 *     sbrec_encap_set_ip()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_encap_set_ip() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_encap_verify_ip(const struct sbrec_encap *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_encap_col_ip);
}

/* Causes the original contents of column "options" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "options" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "options" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "options" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_encap_insert()).
 *
 *   - If "options" has already been modified (with
 *     sbrec_encap_set_options()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_encap_set_options() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_encap_verify_options(const struct sbrec_encap *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_encap_col_options);
}

/* Causes the original contents of column "type" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "type" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "type" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "type" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_encap_insert()).
 *
 *   - If "type" has already been modified (with
 *     sbrec_encap_set_type()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_encap_set_type() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_encap_verify_type(const struct sbrec_encap *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_encap_col_type);
}

/* Returns the "chassis_name" column's value from the "Encap" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes chassis_name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "chassis_name" member in sbrec_encap. */
const struct ovsdb_datum *
sbrec_encap_get_chassis_name(const struct sbrec_encap *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_encap_col_chassis_name);
}

/* Returns the "ip" column's value from the "Encap" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes ip's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ip" member in sbrec_encap. */
const struct ovsdb_datum *
sbrec_encap_get_ip(const struct sbrec_encap *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_encap_col_ip);
}

/* Returns the "options" column's value from the "Encap" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes options's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "options" member in sbrec_encap. */
const struct ovsdb_datum *
sbrec_encap_get_options(const struct sbrec_encap *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_encap_col_options);
}

/* Returns the "type" column's value from the "Encap" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes type's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "type" member in sbrec_encap. */
const struct ovsdb_datum *
sbrec_encap_get_type(const struct sbrec_encap *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_encap_col_type);
}

/* Sets the "chassis_name" column from the "Encap" table in 'row' to
 * 'chassis_name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_set_chassis_name(const struct sbrec_encap *row, const char *chassis_name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, chassis_name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_encap_col_chassis_name, &datum);
}

/* Sets the "ip" column from the "Encap" table in 'row' to
 * 'ip'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_set_ip(const struct sbrec_encap *row, const char *ip)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ip);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_encap_col_ip, &datum);
}

/* Sets the "options" column's value from the "Encap" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_encap_set_options(const struct sbrec_encap *row, const struct smap *options)
{
    struct ovsdb_datum datum;

    if (options) {
        ovsdb_datum_from_smap(&datum, options);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_encap_col_options,
                        &datum);
}


/* Sets the "type" column from the "Encap" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "geneve", "stt", or "vxlan"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_set_type(const struct sbrec_encap *row, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_encap_col_type, &datum);
}

/* Sets an element of the "options" map column from the "Encap" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_encap_update_options_setkey(const struct sbrec_encap *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_encap_col_options,
                                    datum);
}

/* Deletes an element of the "options" map column from the "Encap" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_encap_update_options_delkey(const struct sbrec_encap *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_encap_col_options,
                                    datum);
}

/* Sets the "chassis_name" column from the "Encap" table in 'row' to
 * 'chassis_name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_add_clause_chassis_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *chassis_name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, chassis_name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_encap_col_chassis_name,
                          &datum);
}

/* Sets the "ip" column from the "Encap" table in 'row' to
 * 'ip'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_add_clause_ip(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *ip)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ip);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_encap_col_ip,
                          &datum);
}

/* Sets the "options" column's value from the "Encap" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_encap_add_clause_options(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *options)
{
    struct ovsdb_datum datum;

    if (options) {
        ovsdb_datum_from_smap(&datum, options);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_encap_col_options,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_encap_col_options.type);
}


/* Sets the "type" column from the "Encap" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "geneve", "stt", or "vxlan"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_add_clause_type(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_encap_col_type,
                          &datum);
}

/* Destroy 'row' of kind "Encap". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_encap_index_destroy_row(const struct sbrec_encap *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Encap". */
struct sbrec_encap *
sbrec_encap_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_encap);
    return ALIGNED_CAST(struct sbrec_encap *, ovsdb_idl_index_init_row(index));
}

struct sbrec_encap *
sbrec_encap_index_find(struct ovsdb_idl_index *index, const struct sbrec_encap *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_encap);
    return sbrec_encap_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_encap_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_encap *a, 
    const struct sbrec_encap *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_encap_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_encap);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_encap_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_encap *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_encap);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_encap_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_encap *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_encap);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_encap *
sbrec_encap_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_encap_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "chassis_name" column from the "Encap" table in 'row' to
 * 'chassis_name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_index_set_chassis_name(const struct sbrec_encap *row, const char *chassis_name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, chassis_name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_encap_columns[ SBREC_ENCAP_COL_CHASSIS_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_ENCAP]);
}

/* Sets the "ip" column from the "Encap" table in 'row' to
 * 'ip'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_index_set_ip(const struct sbrec_encap *row, const char *ip)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, ip);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_encap_columns[ SBREC_ENCAP_COL_IP ], &datum, &sbrec_table_classes[SBREC_TABLE_ENCAP]);
}

/* Sets the "options" column's value from the "Encap" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_encap_index_set_options(const struct sbrec_encap *row, const struct smap *options)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (options) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(options);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, options) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_encap_columns[SBREC_ENCAP_COL_OPTIONS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_ENCAP]);
}


/* Sets the "type" column from the "Encap" table in 'row' to
 * 'type'.
 *
 * Argument constraints: one of "geneve", "stt", or "vxlan"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_encap_index_set_type(const struct sbrec_encap *row, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_encap_columns[ SBREC_ENCAP_COL_TYPE ], &datum, &sbrec_table_classes[SBREC_TABLE_ENCAP]);
}

struct ovsdb_idl_column sbrec_encap_columns[SBREC_ENCAP_N_COLUMNS];

void
sbrec_encap_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_encap, condition);
}
static union ovsdb_atom Encap_col_type_key_enum_keys[3] = {
    { .string = "geneve" },
    { .string = "stt" },
    { .string = "vxlan" },
};
static struct ovsdb_datum Encap_col_type_key_enum = {
    .n = 3,
    .keys = Encap_col_type_key_enum_keys,
};

struct ovsdb_idl_column sbrec_encap_columns[SBREC_ENCAP_N_COLUMNS] = {
    [SBREC_ENCAP_COL_CHASSIS_NAME] = {
         .name = "chassis_name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_encap_parse_chassis_name,
         .unparse = sbrec_encap_unparse_chassis_name,
    },

    [SBREC_ENCAP_COL_IP] = {
         .name = "ip",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_encap_parse_ip,
         .unparse = sbrec_encap_unparse_ip,
    },

    [SBREC_ENCAP_COL_OPTIONS] = {
         .name = "options",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_encap_parse_options,
         .unparse = sbrec_encap_unparse_options,
    },

    [SBREC_ENCAP_COL_TYPE] = {
         .name = "type",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .enum_ = &Encap_col_type_key_enum,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_encap_parse_type,
         .unparse = sbrec_encap_unparse_type,
    },

};

/* Gateway_Chassis table. */

const struct sbrec_gateway_chassis_table *
sbrec_gateway_chassis_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_gateway_chassis_table *) idl;
}

const struct sbrec_gateway_chassis *
sbrec_gateway_chassis_table_first(const struct sbrec_gateway_chassis_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_gateway_chassis_first(idl);
}


const struct sbrec_gateway_chassis *
sbrec_gateway_chassis_table_track_get_first(const struct sbrec_gateway_chassis_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_gateway_chassis_track_get_first(idl);
}


static void
sbrec_gateway_chassis_parse_chassis(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_gateway_chassis *row = sbrec_gateway_chassis_cast(row_);

    if (datum->n >= 1) {
        row->chassis = sbrec_chassis_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_chassis, &datum->keys[0].uuid));
    } else {
        row->chassis = NULL;
    }
}

static void
sbrec_gateway_chassis_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_gateway_chassis *row = sbrec_gateway_chassis_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_gateway_chassis_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_gateway_chassis *row = sbrec_gateway_chassis_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_gateway_chassis_parse_options(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_gateway_chassis *row = sbrec_gateway_chassis_cast(row_);
    smap_init(&row->options);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->options,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_gateway_chassis_parse_priority(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_gateway_chassis *row = sbrec_gateway_chassis_cast(row_);

    if (datum->n >= 1) {
        row->priority = datum->keys[0].integer;
    } else {
        row->priority = 0;
    }
}

static void
sbrec_gateway_chassis_unparse_chassis(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_gateway_chassis_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_gateway_chassis *row = sbrec_gateway_chassis_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_gateway_chassis_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_gateway_chassis_unparse_options(struct ovsdb_idl_row *row_)
{
    struct sbrec_gateway_chassis *row = sbrec_gateway_chassis_cast(row_);
    smap_destroy(&row->options);
}

static void
sbrec_gateway_chassis_unparse_priority(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_gateway_chassis_init__(struct ovsdb_idl_row *row)
{
    sbrec_gateway_chassis_init(sbrec_gateway_chassis_cast(row));
}

/* Clears the contents of 'row' in table "Gateway_Chassis". */
void
sbrec_gateway_chassis_init(struct sbrec_gateway_chassis *row)
{
    memset(row, 0, sizeof *row); 
    smap_init(&row->external_ids);
    row->name = "";
    smap_init(&row->options);
}

/* Searches table "Gateway_Chassis" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_gateway_chassis *
sbrec_gateway_chassis_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_gateway_chassis_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_gateway_chassis, uuid));
}

/* Searches table "Gateway_Chassis" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_gateway_chassis *
sbrec_gateway_chassis_table_get_for_uuid(const struct sbrec_gateway_chassis_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_gateway_chassis_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Gateway_Chassis" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_gateway_chassis *
sbrec_gateway_chassis_first(const struct ovsdb_idl *idl)
{
    return sbrec_gateway_chassis_cast(ovsdb_idl_first_row(idl, &sbrec_table_gateway_chassis));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_gateway_chassis *
sbrec_gateway_chassis_next(const struct sbrec_gateway_chassis *row)
{
    return sbrec_gateway_chassis_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_gateway_chassis_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_gateway_chassis);
}

unsigned int sbrec_gateway_chassis_row_get_seqno(const struct sbrec_gateway_chassis *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_gateway_chassis *
sbrec_gateway_chassis_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_gateway_chassis_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_gateway_chassis));
}

const struct sbrec_gateway_chassis
*sbrec_gateway_chassis_track_get_next(const struct sbrec_gateway_chassis *row)
{
    return sbrec_gateway_chassis_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Gateway_Chassis".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_gateway_chassis_delete(const struct sbrec_gateway_chassis *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Gateway_Chassis" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_gateway_chassis *
sbrec_gateway_chassis_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_gateway_chassis_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_gateway_chassis, NULL));
}

bool
sbrec_gateway_chassis_is_updated(const struct sbrec_gateway_chassis *row, enum sbrec_gateway_chassis_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_gateway_chassis_columns[column]);
}

/* Causes the original contents of column "chassis" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "chassis" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "chassis" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "chassis" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_gateway_chassis_insert()).
 *
 *   - If "chassis" has already been modified (with
 *     sbrec_gateway_chassis_set_chassis()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_gateway_chassis_set_chassis() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_gateway_chassis_verify_chassis(const struct sbrec_gateway_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_gateway_chassis_col_chassis);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_gateway_chassis_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_gateway_chassis_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_gateway_chassis_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_gateway_chassis_verify_external_ids(const struct sbrec_gateway_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_gateway_chassis_col_external_ids);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_gateway_chassis_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_gateway_chassis_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_gateway_chassis_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_gateway_chassis_verify_name(const struct sbrec_gateway_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_gateway_chassis_col_name);
}

/* Causes the original contents of column "options" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "options" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "options" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "options" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_gateway_chassis_insert()).
 *
 *   - If "options" has already been modified (with
 *     sbrec_gateway_chassis_set_options()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_gateway_chassis_set_options() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_gateway_chassis_verify_options(const struct sbrec_gateway_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_gateway_chassis_col_options);
}

/* Causes the original contents of column "priority" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "priority" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "priority" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "priority" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_gateway_chassis_insert()).
 *
 *   - If "priority" has already been modified (with
 *     sbrec_gateway_chassis_set_priority()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_gateway_chassis_set_priority() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_gateway_chassis_verify_priority(const struct sbrec_gateway_chassis *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_gateway_chassis_col_priority);
}

/* Returns the "chassis" column's value from the "Gateway_Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes chassis's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "chassis" member in sbrec_gateway_chassis. */
const struct ovsdb_datum *
sbrec_gateway_chassis_get_chassis(const struct sbrec_gateway_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_gateway_chassis_col_chassis);
}

/* Returns the "external_ids" column's value from the "Gateway_Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_gateway_chassis. */
const struct ovsdb_datum *
sbrec_gateway_chassis_get_external_ids(const struct sbrec_gateway_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_gateway_chassis_col_external_ids);
}

/* Returns the "name" column's value from the "Gateway_Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_gateway_chassis. */
const struct ovsdb_datum *
sbrec_gateway_chassis_get_name(const struct sbrec_gateway_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_gateway_chassis_col_name);
}

/* Returns the "options" column's value from the "Gateway_Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes options's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "options" member in sbrec_gateway_chassis. */
const struct ovsdb_datum *
sbrec_gateway_chassis_get_options(const struct sbrec_gateway_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_gateway_chassis_col_options);
}

/* Returns the "priority" column's value from the "Gateway_Chassis" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes priority's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "priority" member in sbrec_gateway_chassis. */
const struct ovsdb_datum *
sbrec_gateway_chassis_get_priority(const struct sbrec_gateway_chassis *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_gateway_chassis_col_priority);
}

/* Sets the "chassis" column from the "Gateway_Chassis" table in 'row' to
 * the 'chassis' set.
 *
 * If "chassis" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_set_chassis(const struct sbrec_gateway_chassis *row, const struct sbrec_chassis *chassis)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (chassis) {
        datum.n = 1;
        datum.keys = &key;
        key.uuid = chassis->header_.uuid;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_gateway_chassis_col_chassis, &datum);
}

/* Sets the "external_ids" column's value from the "Gateway_Chassis" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_gateway_chassis_set_external_ids(const struct sbrec_gateway_chassis *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_gateway_chassis_col_external_ids,
                        &datum);
}


/* Sets the "name" column from the "Gateway_Chassis" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_set_name(const struct sbrec_gateway_chassis *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_gateway_chassis_col_name, &datum);
}

/* Sets the "options" column's value from the "Gateway_Chassis" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_gateway_chassis_set_options(const struct sbrec_gateway_chassis *row, const struct smap *options)
{
    struct ovsdb_datum datum;

    if (options) {
        ovsdb_datum_from_smap(&datum, options);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_gateway_chassis_col_options,
                        &datum);
}


/* Sets the "priority" column from the "Gateway_Chassis" table in 'row' to
 * 'priority'.
 *
 * Argument constraints: in range 0 to 32,767
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_set_priority(const struct sbrec_gateway_chassis *row, int64_t priority)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = priority;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_gateway_chassis_col_priority, &datum);
}

/* Adds the value 'new_value' to the "chassis" set column from the "Gateway_Chassis" table
 * in 'row'.
 *
 */
void
sbrec_gateway_chassis_update_chassis_addvalue(const struct sbrec_gateway_chassis *row, const struct sbrec_chassis *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_gateway_chassis_col_chassis,
                                    datum);
}

/* Deletes the value 'delete_value' from the "chassis" set column from the
 * "Gateway_Chassis" table in 'row'.
 *
 */
void
sbrec_gateway_chassis_update_chassis_delvalue(const struct sbrec_gateway_chassis *row, const struct sbrec_chassis *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_gateway_chassis_col_chassis,
                                    datum);
}

/* Sets an element of the "external_ids" map column from the "Gateway_Chassis" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_gateway_chassis_update_external_ids_setkey(const struct sbrec_gateway_chassis *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_gateway_chassis_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "Gateway_Chassis" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_gateway_chassis_update_external_ids_delkey(const struct sbrec_gateway_chassis *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_gateway_chassis_col_external_ids,
                                    datum);
}

/* Sets an element of the "options" map column from the "Gateway_Chassis" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_gateway_chassis_update_options_setkey(const struct sbrec_gateway_chassis *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_gateway_chassis_col_options,
                                    datum);
}

/* Deletes an element of the "options" map column from the "Gateway_Chassis" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_gateway_chassis_update_options_delkey(const struct sbrec_gateway_chassis *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_gateway_chassis_col_options,
                                    datum);
}

/* Sets the "chassis" column from the "Gateway_Chassis" table in 'row' to
 * the 'chassis' set.
 *
 * If "chassis" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_add_clause_chassis(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct uuid *chassis)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (chassis) {
        datum.n = 1;
        datum.keys = &key;
        key.uuid = *chassis;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_gateway_chassis_col_chassis,
                          &datum);
}

/* Sets the "external_ids" column's value from the "Gateway_Chassis" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_gateway_chassis_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_gateway_chassis_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_gateway_chassis_col_external_ids.type);
}


/* Sets the "name" column from the "Gateway_Chassis" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_gateway_chassis_col_name,
                          &datum);
}

/* Sets the "options" column's value from the "Gateway_Chassis" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_gateway_chassis_add_clause_options(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *options)
{
    struct ovsdb_datum datum;

    if (options) {
        ovsdb_datum_from_smap(&datum, options);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_gateway_chassis_col_options,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_gateway_chassis_col_options.type);
}


/* Sets the "priority" column from the "Gateway_Chassis" table in 'row' to
 * 'priority'.
 *
 * Argument constraints: in range 0 to 32,767
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_add_clause_priority(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t priority)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = priority;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_gateway_chassis_col_priority,
                          &datum);
}

/* Destroy 'row' of kind "Gateway_Chassis". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_gateway_chassis_index_destroy_row(const struct sbrec_gateway_chassis *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Gateway_Chassis". */
struct sbrec_gateway_chassis *
sbrec_gateway_chassis_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_gateway_chassis);
    return ALIGNED_CAST(struct sbrec_gateway_chassis *, ovsdb_idl_index_init_row(index));
}

struct sbrec_gateway_chassis *
sbrec_gateway_chassis_index_find(struct ovsdb_idl_index *index, const struct sbrec_gateway_chassis *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_gateway_chassis);
    return sbrec_gateway_chassis_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_gateway_chassis_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_gateway_chassis *a, 
    const struct sbrec_gateway_chassis *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_gateway_chassis_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_gateway_chassis);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_gateway_chassis_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_gateway_chassis *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_gateway_chassis);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_gateway_chassis_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_gateway_chassis *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_gateway_chassis);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_gateway_chassis *
sbrec_gateway_chassis_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_gateway_chassis_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "chassis" column from the "Gateway_Chassis" table in 'row' to
 * the 'chassis' set.
 *
 * If "chassis" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_index_set_chassis(const struct sbrec_gateway_chassis *row, const struct sbrec_chassis *chassis)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof (union ovsdb_atom));

    if (chassis) {
        datum.n = 1;
        datum.keys = key;
        key->uuid = chassis->header_.uuid;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_gateway_chassis_columns[ SBREC_GATEWAY_CHASSIS_COL_CHASSIS ], &datum, &sbrec_table_classes[SBREC_TABLE_GATEWAY_CHASSIS]);
}

/* Sets the "external_ids" column's value from the "Gateway_Chassis" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_gateway_chassis_index_set_external_ids(const struct sbrec_gateway_chassis *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_GATEWAY_CHASSIS]);
}


/* Sets the "name" column from the "Gateway_Chassis" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_index_set_name(const struct sbrec_gateway_chassis *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_gateway_chassis_columns[ SBREC_GATEWAY_CHASSIS_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_GATEWAY_CHASSIS]);
}

/* Sets the "options" column's value from the "Gateway_Chassis" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_gateway_chassis_index_set_options(const struct sbrec_gateway_chassis *row, const struct smap *options)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (options) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(options);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, options) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_COL_OPTIONS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_GATEWAY_CHASSIS]);
}


/* Sets the "priority" column from the "Gateway_Chassis" table in 'row' to
 * 'priority'.
 *
 * Argument constraints: in range 0 to 32,767
 *
 * The caller retains ownership of the arguments. */
void
sbrec_gateway_chassis_index_set_priority(const struct sbrec_gateway_chassis *row, int64_t priority)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = priority;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_gateway_chassis_columns[ SBREC_GATEWAY_CHASSIS_COL_PRIORITY ], &datum, &sbrec_table_classes[SBREC_TABLE_GATEWAY_CHASSIS]);
}

struct ovsdb_idl_column sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_N_COLUMNS];

void
sbrec_gateway_chassis_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_gateway_chassis, condition);
}

struct ovsdb_idl_column sbrec_gateway_chassis_columns[SBREC_GATEWAY_CHASSIS_N_COLUMNS] = {
    [SBREC_GATEWAY_CHASSIS_COL_CHASSIS] = {
         .name = "chassis",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Chassis", .refType = OVSDB_REF_WEAK },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_gateway_chassis_parse_chassis,
         .unparse = sbrec_gateway_chassis_unparse_chassis,
    },

    [SBREC_GATEWAY_CHASSIS_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_gateway_chassis_parse_external_ids,
         .unparse = sbrec_gateway_chassis_unparse_external_ids,
    },

    [SBREC_GATEWAY_CHASSIS_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_gateway_chassis_parse_name,
         .unparse = sbrec_gateway_chassis_unparse_name,
    },

    [SBREC_GATEWAY_CHASSIS_COL_OPTIONS] = {
         .name = "options",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_gateway_chassis_parse_options,
         .unparse = sbrec_gateway_chassis_unparse_options,
    },

    [SBREC_GATEWAY_CHASSIS_COL_PRIORITY] = {
         .name = "priority",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(0), .max = INT64_C(32767) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_gateway_chassis_parse_priority,
         .unparse = sbrec_gateway_chassis_unparse_priority,
    },

};

/* Logical_Flow table. */

const struct sbrec_logical_flow_table *
sbrec_logical_flow_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_logical_flow_table *) idl;
}

const struct sbrec_logical_flow *
sbrec_logical_flow_table_first(const struct sbrec_logical_flow_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_logical_flow_first(idl);
}


const struct sbrec_logical_flow *
sbrec_logical_flow_table_track_get_first(const struct sbrec_logical_flow_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_logical_flow_track_get_first(idl);
}


static void
sbrec_logical_flow_parse_actions(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);

    if (datum->n >= 1) {
        row->actions = datum->keys[0].string;
    } else {
        row->actions = "";
    }
}

static void
sbrec_logical_flow_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

//Salam
static struct nbrec_sb_datapath_binding *
nbrec_sb_datapath_binding_cast(const struct ovsdb_idl_row *row)
{
    return row ? CONTAINER_OF(row, struct nbrec_sb_datapath_binding, header_) : NULL;
}

static void
sbrec_logical_flow_parse_logical_datapath(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);

    if (datum->n >= 1) {
        row->logical_datapath = nbrec_sb_datapath_binding_cast(ovsdb_idl_get_row_arc_from_nb(row_, &nbrec_table_sb_datapath_binding, &datum->keys[0].uuid)); //Salam
    } else {
        row->logical_datapath = NULL;
    }
}

static void
sbrec_logical_flow_parse_match(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);

    if (datum->n >= 1) {
        row->match = datum->keys[0].string;
    } else {
        row->match = "";
    }
}

static void
sbrec_logical_flow_parse_pipeline(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);

    if (datum->n >= 1) {
        row->pipeline = datum->keys[0].string;
    } else {
        row->pipeline = "";
    }
}

static void
sbrec_logical_flow_parse_priority(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);

    if (datum->n >= 1) {
        row->priority = datum->keys[0].integer;
    } else {
        row->priority = 0;
    }
}

static void
sbrec_logical_flow_parse_table_id(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);

    if (datum->n >= 1) {
        row->table_id = datum->keys[0].integer;
    } else {
        row->table_id = 0;
    }
}

static void
sbrec_logical_flow_parse_hash(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum OVS_UNUSED)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);
row->hash = sbrec_logical_flow_hash(row);
}

static void
sbrec_logical_flow_unparse_actions(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_logical_flow_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_logical_flow *row = sbrec_logical_flow_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_logical_flow_unparse_logical_datapath(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_logical_flow_unparse_match(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_logical_flow_unparse_pipeline(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_logical_flow_unparse_priority(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_logical_flow_unparse_table_id(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_logical_flow_unparse_hash(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_logical_flow_init__(struct ovsdb_idl_row *row)
{
    sbrec_logical_flow_init(sbrec_logical_flow_cast(row));
}

/* Clears the contents of 'row' in table "Logical_Flow". */
void
sbrec_logical_flow_init(struct sbrec_logical_flow *row)
{
    memset(row, 0, sizeof *row); 
    row->actions = "";
    smap_init(&row->external_ids);
    row->match = "";
    row->pipeline = "";
}

/* Searches table "Logical_Flow" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_logical_flow *
sbrec_logical_flow_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_logical_flow_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_logical_flow, uuid));
}

/* Searches table "Logical_Flow" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_logical_flow *
sbrec_logical_flow_table_get_for_uuid(const struct sbrec_logical_flow_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_logical_flow_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Logical_Flow" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_logical_flow *
sbrec_logical_flow_first(const struct ovsdb_idl *idl)
{
    return sbrec_logical_flow_cast(ovsdb_idl_first_row(idl, &sbrec_table_logical_flow));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_logical_flow *
sbrec_logical_flow_next(const struct sbrec_logical_flow *row)
{
    return sbrec_logical_flow_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_logical_flow_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_logical_flow);
}

unsigned int sbrec_logical_flow_row_get_seqno(const struct sbrec_logical_flow *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_logical_flow *
sbrec_logical_flow_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_logical_flow_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_logical_flow));
}

const struct sbrec_logical_flow
*sbrec_logical_flow_track_get_next(const struct sbrec_logical_flow *row)
{
    return sbrec_logical_flow_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Logical_Flow".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_logical_flow_delete(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Logical_Flow" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_logical_flow *
sbrec_logical_flow_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_logical_flow_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_logical_flow, NULL));
}

bool
sbrec_logical_flow_is_updated(const struct sbrec_logical_flow *row, enum sbrec_logical_flow_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_logical_flow_columns[column]);
}

/* Causes the original contents of column "actions" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "actions" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "actions" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "actions" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_logical_flow_insert()).
 *
 *   - If "actions" has already been modified (with
 *     sbrec_logical_flow_set_actions()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_logical_flow_set_actions() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_logical_flow_verify_actions(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_logical_flow_col_actions);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_logical_flow_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_logical_flow_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_logical_flow_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_logical_flow_verify_external_ids(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_logical_flow_col_external_ids);
}

/* Causes the original contents of column "logical_datapath" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "logical_datapath" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "logical_datapath" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "logical_datapath" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_logical_flow_insert()).
 *
 *   - If "logical_datapath" has already been modified (with
 *     sbrec_logical_flow_set_logical_datapath()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_logical_flow_set_logical_datapath() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_logical_flow_verify_logical_datapath(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_logical_flow_col_logical_datapath);
}

/* Causes the original contents of column "match" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "match" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "match" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "match" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_logical_flow_insert()).
 *
 *   - If "match" has already been modified (with
 *     sbrec_logical_flow_set_match()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_logical_flow_set_match() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_logical_flow_verify_match(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_logical_flow_col_match);
}

/* Causes the original contents of column "pipeline" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "pipeline" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "pipeline" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "pipeline" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_logical_flow_insert()).
 *
 *   - If "pipeline" has already been modified (with
 *     sbrec_logical_flow_set_pipeline()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_logical_flow_set_pipeline() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_logical_flow_verify_pipeline(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_logical_flow_col_pipeline);
}

/* Causes the original contents of column "priority" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "priority" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "priority" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "priority" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_logical_flow_insert()).
 *
 *   - If "priority" has already been modified (with
 *     sbrec_logical_flow_set_priority()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_logical_flow_set_priority() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_logical_flow_verify_priority(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_logical_flow_col_priority);
}

/* Causes the original contents of column "table_id" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "table_id" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "table_id" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "table_id" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_logical_flow_insert()).
 *
 *   - If "table_id" has already been modified (with
 *     sbrec_logical_flow_set_table_id()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_logical_flow_set_table_id() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_logical_flow_verify_table_id(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_logical_flow_col_table_id);
}

/* Returns the "actions" column's value from the "Logical_Flow" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes actions's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "actions" member in sbrec_logical_flow. */
const struct ovsdb_datum *
sbrec_logical_flow_get_actions(const struct sbrec_logical_flow *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_logical_flow_col_actions);
}

/* Returns the "external_ids" column's value from the "Logical_Flow" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_logical_flow. */
const struct ovsdb_datum *
sbrec_logical_flow_get_external_ids(const struct sbrec_logical_flow *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_logical_flow_col_external_ids);
}

/* Returns the "logical_datapath" column's value from the "Logical_Flow" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes logical_datapath's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "logical_datapath" member in sbrec_logical_flow. */
const struct ovsdb_datum *
sbrec_logical_flow_get_logical_datapath(const struct sbrec_logical_flow *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_logical_flow_col_logical_datapath);
}

/* Returns the "match" column's value from the "Logical_Flow" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes match's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "match" member in sbrec_logical_flow. */
const struct ovsdb_datum *
sbrec_logical_flow_get_match(const struct sbrec_logical_flow *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_logical_flow_col_match);
}

/* Returns the "pipeline" column's value from the "Logical_Flow" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes pipeline's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "pipeline" member in sbrec_logical_flow. */
const struct ovsdb_datum *
sbrec_logical_flow_get_pipeline(const struct sbrec_logical_flow *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_logical_flow_col_pipeline);
}

/* Returns the "priority" column's value from the "Logical_Flow" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes priority's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "priority" member in sbrec_logical_flow. */
const struct ovsdb_datum *
sbrec_logical_flow_get_priority(const struct sbrec_logical_flow *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_logical_flow_col_priority);
}

/* Returns the "table_id" column's value from the "Logical_Flow" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes table_id's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "table_id" member in sbrec_logical_flow. */
const struct ovsdb_datum *
sbrec_logical_flow_get_table_id(const struct sbrec_logical_flow *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_logical_flow_col_table_id);
}

/* Sets the "actions" column from the "Logical_Flow" table in 'row' to
 * 'actions'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_set_actions(const struct sbrec_logical_flow *row, const char *actions)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, actions);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_logical_flow_col_actions, &datum);
}

/* Sets the "external_ids" column's value from the "Logical_Flow" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_logical_flow_set_external_ids(const struct sbrec_logical_flow *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_logical_flow_col_external_ids,
                        &datum);
}


/* Sets the "logical_datapath" column from the "Logical_Flow" table in 'row' to
 * 'logical_datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_set_logical_datapath(const struct sbrec_logical_flow *row, const struct nbrec_sb_datapath_binding *logical_datapath) //Salam
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.uuid = logical_datapath->header_.uuid;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_logical_flow_col_logical_datapath, &datum);
}

/* Sets the "match" column from the "Logical_Flow" table in 'row' to
 * 'match'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_set_match(const struct sbrec_logical_flow *row, const char *match)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, match);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_logical_flow_col_match, &datum);
}

/* Sets the "pipeline" column from the "Logical_Flow" table in 'row' to
 * 'pipeline'.
 *
 * Argument constraints: either "egress" or "ingress"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_set_pipeline(const struct sbrec_logical_flow *row, const char *pipeline)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, pipeline);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_logical_flow_col_pipeline, &datum);
}

/* Sets the "priority" column from the "Logical_Flow" table in 'row' to
 * 'priority'.
 *
 * Argument constraints: in range 0 to 65,535
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_set_priority(const struct sbrec_logical_flow *row, int64_t priority)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = priority;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_logical_flow_col_priority, &datum);
}

/* Sets the "table_id" column from the "Logical_Flow" table in 'row' to
 * 'table_id'.
 *
 * Argument constraints: in range 0 to 23
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_set_table_id(const struct sbrec_logical_flow *row, int64_t table_id)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = table_id;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_logical_flow_col_table_id, &datum);
}

/* Sets an element of the "external_ids" map column from the "Logical_Flow" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_logical_flow_update_external_ids_setkey(const struct sbrec_logical_flow *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_logical_flow_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "Logical_Flow" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_logical_flow_update_external_ids_delkey(const struct sbrec_logical_flow *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_logical_flow_col_external_ids,
                                    datum);
}

/* Sets the "actions" column from the "Logical_Flow" table in 'row' to
 * 'actions'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_add_clause_actions(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *actions)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, actions);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_logical_flow_col_actions,
                          &datum);
}

/* Sets the "external_ids" column's value from the "Logical_Flow" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_logical_flow_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_logical_flow_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_logical_flow_col_external_ids.type);
}


/* Sets the "logical_datapath" column from the "Logical_Flow" table in 'row' to
 * 'logical_datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_add_clause_logical_datapath(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct uuid *logical_datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.uuid = *logical_datapath;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_logical_flow_col_logical_datapath,
                          &datum);
}

/* Sets the "match" column from the "Logical_Flow" table in 'row' to
 * 'match'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_add_clause_match(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *match)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, match);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_logical_flow_col_match,
                          &datum);
}

/* Sets the "pipeline" column from the "Logical_Flow" table in 'row' to
 * 'pipeline'.
 *
 * Argument constraints: either "egress" or "ingress"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_add_clause_pipeline(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *pipeline)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, pipeline);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_logical_flow_col_pipeline,
                          &datum);
}

/* Sets the "priority" column from the "Logical_Flow" table in 'row' to
 * 'priority'.
 *
 * Argument constraints: in range 0 to 65,535
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_add_clause_priority(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t priority)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = priority;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_logical_flow_col_priority,
                          &datum);
}

/* Sets the "table_id" column from the "Logical_Flow" table in 'row' to
 * 'table_id'.
 *
 * Argument constraints: in range 0 to 23
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_add_clause_table_id(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t table_id)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = table_id;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_logical_flow_col_table_id,
                          &datum);
}

/* Destroy 'row' of kind "Logical_Flow". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_logical_flow_index_destroy_row(const struct sbrec_logical_flow *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Logical_Flow". */
struct sbrec_logical_flow *
sbrec_logical_flow_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_logical_flow);
    return ALIGNED_CAST(struct sbrec_logical_flow *, ovsdb_idl_index_init_row(index));
}

struct sbrec_logical_flow *
sbrec_logical_flow_index_find(struct ovsdb_idl_index *index, const struct sbrec_logical_flow *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_logical_flow);
    return sbrec_logical_flow_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_logical_flow_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_logical_flow *a, 
    const struct sbrec_logical_flow *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_logical_flow_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_logical_flow);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_logical_flow_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_logical_flow *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_logical_flow);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_logical_flow_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_logical_flow *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_logical_flow);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_logical_flow *
sbrec_logical_flow_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_logical_flow_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "actions" column from the "Logical_Flow" table in 'row' to
 * 'actions'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_index_set_actions(const struct sbrec_logical_flow *row, const char *actions)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, actions);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_logical_flow_columns[ SBREC_LOGICAL_FLOW_COL_ACTIONS ], &datum, &sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW]);
}

/* Sets the "external_ids" column's value from the "Logical_Flow" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_logical_flow_index_set_external_ids(const struct sbrec_logical_flow *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW]);
}


/* Sets the "hash" column from the "Logical_Flow" table in 'row' to
 * 'hash'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_index_set_hash(const struct sbrec_logical_flow *row, int64_t hash)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = hash;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_logical_flow_columns[ SBREC_LOGICAL_FLOW_COL_HASH ], &datum, &sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW]);
}

/* Sets the "logical_datapath" column from the "Logical_Flow" table in 'row' to
 * 'logical_datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_index_set_logical_datapath(const struct sbrec_logical_flow *row, const struct nbrec_sb_datapath_binding *logical_datapath) //Salam
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->uuid = logical_datapath->header_.uuid;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_logical_flow_columns[ SBREC_LOGICAL_FLOW_COL_LOGICAL_DATAPATH ], &datum, &sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW]);
}

/* Sets the "match" column from the "Logical_Flow" table in 'row' to
 * 'match'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_index_set_match(const struct sbrec_logical_flow *row, const char *match)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, match);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_logical_flow_columns[ SBREC_LOGICAL_FLOW_COL_MATCH ], &datum, &sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW]);
}

/* Sets the "pipeline" column from the "Logical_Flow" table in 'row' to
 * 'pipeline'.
 *
 * Argument constraints: either "egress" or "ingress"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_index_set_pipeline(const struct sbrec_logical_flow *row, const char *pipeline)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, pipeline);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_logical_flow_columns[ SBREC_LOGICAL_FLOW_COL_PIPELINE ], &datum, &sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW]);
}

/* Sets the "priority" column from the "Logical_Flow" table in 'row' to
 * 'priority'.
 *
 * Argument constraints: in range 0 to 65,535
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_index_set_priority(const struct sbrec_logical_flow *row, int64_t priority)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = priority;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_logical_flow_columns[ SBREC_LOGICAL_FLOW_COL_PRIORITY ], &datum, &sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW]);
}

/* Sets the "table_id" column from the "Logical_Flow" table in 'row' to
 * 'table_id'.
 *
 * Argument constraints: in range 0 to 23
 *
 * The caller retains ownership of the arguments. */
void
sbrec_logical_flow_index_set_table_id(const struct sbrec_logical_flow *row, int64_t table_id)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = table_id;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_logical_flow_columns[ SBREC_LOGICAL_FLOW_COL_TABLE_ID ], &datum, &sbrec_table_classes[SBREC_TABLE_LOGICAL_FLOW]);
}

struct ovsdb_idl_column sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_N_COLUMNS];

void
sbrec_logical_flow_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_logical_flow, condition);
}
static union ovsdb_atom Logical_Flow_col_pipeline_key_enum_keys[2] = {
    { .string = "egress" },
    { .string = "ingress" },
};
static struct ovsdb_datum Logical_Flow_col_pipeline_key_enum = {
    .n = 2,
    .keys = Logical_Flow_col_pipeline_key_enum_keys,
};

struct ovsdb_idl_column sbrec_logical_flow_columns[SBREC_LOGICAL_FLOW_N_COLUMNS] = {
    [SBREC_LOGICAL_FLOW_COL_ACTIONS] = {
         .name = "actions",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_logical_flow_parse_actions,
         .unparse = sbrec_logical_flow_unparse_actions,
    },

    [SBREC_LOGICAL_FLOW_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_logical_flow_parse_external_ids,
         .unparse = sbrec_logical_flow_unparse_external_ids,
    },

    [SBREC_LOGICAL_FLOW_COL_LOGICAL_DATAPATH] = {
         .name = "logical_datapath",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Datapath_Binding", .refType = OVSDB_REF_STRONG }, //Salam
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_logical_flow_parse_logical_datapath,
         .unparse = sbrec_logical_flow_unparse_logical_datapath,
    },

    [SBREC_LOGICAL_FLOW_COL_MATCH] = {
         .name = "match",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_logical_flow_parse_match,
         .unparse = sbrec_logical_flow_unparse_match,
    },

    [SBREC_LOGICAL_FLOW_COL_PIPELINE] = {
         .name = "pipeline",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .enum_ = &Logical_Flow_col_pipeline_key_enum,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_logical_flow_parse_pipeline,
         .unparse = sbrec_logical_flow_unparse_pipeline,
    },

    [SBREC_LOGICAL_FLOW_COL_PRIORITY] = {
         .name = "priority",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(0), .max = INT64_C(65535) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_logical_flow_parse_priority,
         .unparse = sbrec_logical_flow_unparse_priority,
    },

    [SBREC_LOGICAL_FLOW_COL_TABLE_ID] = {
         .name = "table_id",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(0), .max = INT64_C(23) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_logical_flow_parse_table_id,
         .unparse = sbrec_logical_flow_unparse_table_id,
    },

    [SBREC_LOGICAL_FLOW_COL_HASH] = {
         .name = "hash",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_MIN, .max = INT64_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = true,
         .parse = sbrec_logical_flow_parse_hash,
         .unparse = sbrec_logical_flow_unparse_hash,
    },

};

/* MAC_Binding table. */

const struct sbrec_mac_binding_table *
sbrec_mac_binding_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_mac_binding_table *) idl;
}

const struct sbrec_mac_binding *
sbrec_mac_binding_table_first(const struct sbrec_mac_binding_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_mac_binding_first(idl);
}


const struct sbrec_mac_binding *
sbrec_mac_binding_table_track_get_first(const struct sbrec_mac_binding_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_mac_binding_track_get_first(idl);
}


static void
sbrec_mac_binding_parse_datapath(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_mac_binding *row = sbrec_mac_binding_cast(row_);

    if (datum->n >= 1) {
        row->datapath = sbrec_datapath_binding_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_datapath_binding, &datum->keys[0].uuid));
    } else {
        row->datapath = NULL;
    }
}

static void
sbrec_mac_binding_parse_ip(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_mac_binding *row = sbrec_mac_binding_cast(row_);

    if (datum->n >= 1) {
        row->ip = datum->keys[0].string;
    } else {
        row->ip = "";
    }
}

static void
sbrec_mac_binding_parse_logical_port(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_mac_binding *row = sbrec_mac_binding_cast(row_);

    if (datum->n >= 1) {
        row->logical_port = datum->keys[0].string;
    } else {
        row->logical_port = "";
    }
}

static void
sbrec_mac_binding_parse_mac(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_mac_binding *row = sbrec_mac_binding_cast(row_);

    if (datum->n >= 1) {
        row->mac = datum->keys[0].string;
    } else {
        row->mac = "";
    }
}

static void
sbrec_mac_binding_unparse_datapath(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_mac_binding_unparse_ip(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_mac_binding_unparse_logical_port(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_mac_binding_unparse_mac(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_mac_binding_init__(struct ovsdb_idl_row *row)
{
    sbrec_mac_binding_init(sbrec_mac_binding_cast(row));
}

/* Clears the contents of 'row' in table "MAC_Binding". */
void
sbrec_mac_binding_init(struct sbrec_mac_binding *row)
{
    memset(row, 0, sizeof *row); 
    row->ip = "";
    row->logical_port = "";
    row->mac = "";
}

/* Searches table "MAC_Binding" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_mac_binding *
sbrec_mac_binding_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_mac_binding_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_mac_binding, uuid));
}

/* Searches table "MAC_Binding" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_mac_binding *
sbrec_mac_binding_table_get_for_uuid(const struct sbrec_mac_binding_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_mac_binding_get_for_uuid(idl, uuid);
}

/* Returns a row in table "MAC_Binding" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_mac_binding *
sbrec_mac_binding_first(const struct ovsdb_idl *idl)
{
    return sbrec_mac_binding_cast(ovsdb_idl_first_row(idl, &sbrec_table_mac_binding));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_mac_binding *
sbrec_mac_binding_next(const struct sbrec_mac_binding *row)
{
    return sbrec_mac_binding_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_mac_binding_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_mac_binding);
}

unsigned int sbrec_mac_binding_row_get_seqno(const struct sbrec_mac_binding *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_mac_binding *
sbrec_mac_binding_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_mac_binding_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_mac_binding));
}

const struct sbrec_mac_binding
*sbrec_mac_binding_track_get_next(const struct sbrec_mac_binding *row)
{
    return sbrec_mac_binding_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "MAC_Binding".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_mac_binding_delete(const struct sbrec_mac_binding *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "MAC_Binding" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_mac_binding *
sbrec_mac_binding_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_mac_binding_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_mac_binding, NULL));
}

bool
sbrec_mac_binding_is_updated(const struct sbrec_mac_binding *row, enum sbrec_mac_binding_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_mac_binding_columns[column]);
}

/* Causes the original contents of column "datapath" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "datapath" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "datapath" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "datapath" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_mac_binding_insert()).
 *
 *   - If "datapath" has already been modified (with
 *     sbrec_mac_binding_set_datapath()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_mac_binding_set_datapath() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_mac_binding_verify_datapath(const struct sbrec_mac_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_mac_binding_col_datapath);
}

/* Causes the original contents of column "ip" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ip" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ip" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ip" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_mac_binding_insert()).
 *
 *   - If "ip" has already been modified (with
 *     sbrec_mac_binding_set_ip()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_mac_binding_set_ip() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_mac_binding_verify_ip(const struct sbrec_mac_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_mac_binding_col_ip);
}

/* Causes the original contents of column "logical_port" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "logical_port" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "logical_port" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "logical_port" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_mac_binding_insert()).
 *
 *   - If "logical_port" has already been modified (with
 *     sbrec_mac_binding_set_logical_port()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_mac_binding_set_logical_port() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_mac_binding_verify_logical_port(const struct sbrec_mac_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_mac_binding_col_logical_port);
}

/* Causes the original contents of column "mac" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "mac" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "mac" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "mac" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_mac_binding_insert()).
 *
 *   - If "mac" has already been modified (with
 *     sbrec_mac_binding_set_mac()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_mac_binding_set_mac() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_mac_binding_verify_mac(const struct sbrec_mac_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_mac_binding_col_mac);
}

/* Returns the "datapath" column's value from the "MAC_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes datapath's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "datapath" member in sbrec_mac_binding. */
const struct ovsdb_datum *
sbrec_mac_binding_get_datapath(const struct sbrec_mac_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_mac_binding_col_datapath);
}

/* Returns the "ip" column's value from the "MAC_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes ip's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ip" member in sbrec_mac_binding. */
const struct ovsdb_datum *
sbrec_mac_binding_get_ip(const struct sbrec_mac_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_mac_binding_col_ip);
}

/* Returns the "logical_port" column's value from the "MAC_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes logical_port's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "logical_port" member in sbrec_mac_binding. */
const struct ovsdb_datum *
sbrec_mac_binding_get_logical_port(const struct sbrec_mac_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_mac_binding_col_logical_port);
}

/* Returns the "mac" column's value from the "MAC_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes mac's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "mac" member in sbrec_mac_binding. */
const struct ovsdb_datum *
sbrec_mac_binding_get_mac(const struct sbrec_mac_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_mac_binding_col_mac);
}

/* Sets the "datapath" column from the "MAC_Binding" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_set_datapath(const struct sbrec_mac_binding *row, const struct sbrec_datapath_binding *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.uuid = datapath->header_.uuid;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_mac_binding_col_datapath, &datum);
}

/* Sets the "ip" column from the "MAC_Binding" table in 'row' to
 * 'ip'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_set_ip(const struct sbrec_mac_binding *row, const char *ip)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ip);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_mac_binding_col_ip, &datum);
}

/* Sets the "logical_port" column from the "MAC_Binding" table in 'row' to
 * 'logical_port'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_set_logical_port(const struct sbrec_mac_binding *row, const char *logical_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, logical_port);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_mac_binding_col_logical_port, &datum);
}

/* Sets the "mac" column from the "MAC_Binding" table in 'row' to
 * 'mac'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_set_mac(const struct sbrec_mac_binding *row, const char *mac)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, mac);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_mac_binding_col_mac, &datum);
}

/* Sets the "datapath" column from the "MAC_Binding" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_add_clause_datapath(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct uuid *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.uuid = *datapath;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_mac_binding_col_datapath,
                          &datum);
}

/* Sets the "ip" column from the "MAC_Binding" table in 'row' to
 * 'ip'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_add_clause_ip(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *ip)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ip);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_mac_binding_col_ip,
                          &datum);
}

/* Sets the "logical_port" column from the "MAC_Binding" table in 'row' to
 * 'logical_port'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_add_clause_logical_port(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *logical_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, logical_port);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_mac_binding_col_logical_port,
                          &datum);
}

/* Sets the "mac" column from the "MAC_Binding" table in 'row' to
 * 'mac'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_add_clause_mac(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *mac)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, mac);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_mac_binding_col_mac,
                          &datum);
}

/* Destroy 'row' of kind "MAC_Binding". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_mac_binding_index_destroy_row(const struct sbrec_mac_binding *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "MAC_Binding". */
struct sbrec_mac_binding *
sbrec_mac_binding_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_mac_binding);
    return ALIGNED_CAST(struct sbrec_mac_binding *, ovsdb_idl_index_init_row(index));
}

struct sbrec_mac_binding *
sbrec_mac_binding_index_find(struct ovsdb_idl_index *index, const struct sbrec_mac_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_mac_binding);
    return sbrec_mac_binding_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_mac_binding_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_mac_binding *a, 
    const struct sbrec_mac_binding *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_mac_binding_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_mac_binding);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_mac_binding_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_mac_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_mac_binding);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_mac_binding_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_mac_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_mac_binding);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_mac_binding *
sbrec_mac_binding_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_mac_binding_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "datapath" column from the "MAC_Binding" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_index_set_datapath(const struct sbrec_mac_binding *row, const struct sbrec_datapath_binding *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->uuid = datapath->header_.uuid;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_mac_binding_columns[ SBREC_MAC_BINDING_COL_DATAPATH ], &datum, &sbrec_table_classes[SBREC_TABLE_MAC_BINDING]);
}

/* Sets the "ip" column from the "MAC_Binding" table in 'row' to
 * 'ip'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_index_set_ip(const struct sbrec_mac_binding *row, const char *ip)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, ip);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_mac_binding_columns[ SBREC_MAC_BINDING_COL_IP ], &datum, &sbrec_table_classes[SBREC_TABLE_MAC_BINDING]);
}

/* Sets the "logical_port" column from the "MAC_Binding" table in 'row' to
 * 'logical_port'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_index_set_logical_port(const struct sbrec_mac_binding *row, const char *logical_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, logical_port);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_mac_binding_columns[ SBREC_MAC_BINDING_COL_LOGICAL_PORT ], &datum, &sbrec_table_classes[SBREC_TABLE_MAC_BINDING]);
}

/* Sets the "mac" column from the "MAC_Binding" table in 'row' to
 * 'mac'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_mac_binding_index_set_mac(const struct sbrec_mac_binding *row, const char *mac)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, mac);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_mac_binding_columns[ SBREC_MAC_BINDING_COL_MAC ], &datum, &sbrec_table_classes[SBREC_TABLE_MAC_BINDING]);
}

struct ovsdb_idl_column sbrec_mac_binding_columns[SBREC_MAC_BINDING_N_COLUMNS];

void
sbrec_mac_binding_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_mac_binding, condition);
}

struct ovsdb_idl_column sbrec_mac_binding_columns[SBREC_MAC_BINDING_N_COLUMNS] = {
    [SBREC_MAC_BINDING_COL_DATAPATH] = {
         .name = "datapath",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Datapath_Binding", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_mac_binding_parse_datapath,
         .unparse = sbrec_mac_binding_unparse_datapath,
    },

    [SBREC_MAC_BINDING_COL_IP] = {
         .name = "ip",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_mac_binding_parse_ip,
         .unparse = sbrec_mac_binding_unparse_ip,
    },

    [SBREC_MAC_BINDING_COL_LOGICAL_PORT] = {
         .name = "logical_port",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_mac_binding_parse_logical_port,
         .unparse = sbrec_mac_binding_unparse_logical_port,
    },

    [SBREC_MAC_BINDING_COL_MAC] = {
         .name = "mac",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_mac_binding_parse_mac,
         .unparse = sbrec_mac_binding_unparse_mac,
    },

};

/* Meter table. */

const struct sbrec_meter_table *
sbrec_meter_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_meter_table *) idl;
}

const struct sbrec_meter *
sbrec_meter_table_first(const struct sbrec_meter_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_meter_first(idl);
}


const struct sbrec_meter *
sbrec_meter_table_track_get_first(const struct sbrec_meter_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_meter_track_get_first(idl);
}


static void
sbrec_meter_parse_bands(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_meter *row = sbrec_meter_cast(row_);
    row->bands = NULL;
    row->n_bands = 0;
    for (size_t i = 0; i < datum->n; i++) {
        struct sbrec_meter_band *keyRow = sbrec_meter_band_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_meter_band, &datum->keys[i].uuid));
        if (!keyRow) {
            continue;
        }
        if (!row->n_bands) {
            row->bands = xmalloc(datum->n * sizeof *row->bands);
        }
        row->bands[row->n_bands] = keyRow;
        row->n_bands++;
    }
}

static void
sbrec_meter_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_meter *row = sbrec_meter_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_meter_parse_unit(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_meter *row = sbrec_meter_cast(row_);

    if (datum->n >= 1) {
        row->unit = datum->keys[0].string;
    } else {
        row->unit = "";
    }
}

static void
sbrec_meter_unparse_bands(struct ovsdb_idl_row *row_)
{
    struct sbrec_meter *row = sbrec_meter_cast(row_);
    free(row->bands);
}

static void
sbrec_meter_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_meter_unparse_unit(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_meter_init__(struct ovsdb_idl_row *row)
{
    sbrec_meter_init(sbrec_meter_cast(row));
}

/* Clears the contents of 'row' in table "Meter". */
void
sbrec_meter_init(struct sbrec_meter *row)
{
    memset(row, 0, sizeof *row); 
    row->name = "";
    row->unit = "";
}

/* Searches table "Meter" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_meter *
sbrec_meter_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_meter_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_meter, uuid));
}

/* Searches table "Meter" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_meter *
sbrec_meter_table_get_for_uuid(const struct sbrec_meter_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_meter_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Meter" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_meter *
sbrec_meter_first(const struct ovsdb_idl *idl)
{
    return sbrec_meter_cast(ovsdb_idl_first_row(idl, &sbrec_table_meter));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_meter *
sbrec_meter_next(const struct sbrec_meter *row)
{
    return sbrec_meter_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_meter_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_meter);
}

unsigned int sbrec_meter_row_get_seqno(const struct sbrec_meter *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_meter *
sbrec_meter_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_meter_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_meter));
}

const struct sbrec_meter
*sbrec_meter_track_get_next(const struct sbrec_meter *row)
{
    return sbrec_meter_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Meter".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_meter_delete(const struct sbrec_meter *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Meter" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_meter *
sbrec_meter_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_meter_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_meter, NULL));
}

bool
sbrec_meter_is_updated(const struct sbrec_meter *row, enum sbrec_meter_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_meter_columns[column]);
}

/* Causes the original contents of column "bands" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "bands" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "bands" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "bands" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_meter_insert()).
 *
 *   - If "bands" has already been modified (with
 *     sbrec_meter_set_bands()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_meter_set_bands() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_meter_verify_bands(const struct sbrec_meter *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_meter_col_bands);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_meter_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_meter_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_meter_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_meter_verify_name(const struct sbrec_meter *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_meter_col_name);
}

/* Causes the original contents of column "unit" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "unit" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "unit" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "unit" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_meter_insert()).
 *
 *   - If "unit" has already been modified (with
 *     sbrec_meter_set_unit()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_meter_set_unit() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_meter_verify_unit(const struct sbrec_meter *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_meter_col_unit);
}

/* Returns the "bands" column's value from the "Meter" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes bands's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "bands" member in sbrec_meter. */
const struct ovsdb_datum *
sbrec_meter_get_bands(const struct sbrec_meter *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_meter_col_bands);
}

/* Returns the "name" column's value from the "Meter" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_meter. */
const struct ovsdb_datum *
sbrec_meter_get_name(const struct sbrec_meter *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_meter_col_name);
}

/* Returns the "unit" column's value from the "Meter" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes unit's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "unit" member in sbrec_meter. */
const struct ovsdb_datum *
sbrec_meter_get_unit(const struct sbrec_meter *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_meter_col_unit);
}

/* Sets the "bands" column from the "Meter" table in 'row' to
 * the 'bands' set with 'n_bands' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_set_bands(const struct sbrec_meter *row, struct sbrec_meter_band **bands, size_t n_bands)
{
    struct ovsdb_datum datum;

    datum.n = n_bands;
    datum.keys = n_bands ? xmalloc(n_bands * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_bands; i++) {
        datum.keys[i].uuid = bands[i]->header_.uuid;
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_meter_col_bands, &datum);
}

/* Sets the "name" column from the "Meter" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_set_name(const struct sbrec_meter *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_meter_col_name, &datum);
}

/* Sets the "unit" column from the "Meter" table in 'row' to
 * 'unit'.
 *
 * Argument constraints: either "kbps" or "pktps"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_set_unit(const struct sbrec_meter *row, const char *unit)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, unit);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_meter_col_unit, &datum);
}

/* Adds the value 'new_value' to the "bands" set column from the "Meter" table
 * in 'row'.
 *
 */
void
sbrec_meter_update_bands_addvalue(const struct sbrec_meter *row, const struct sbrec_meter_band *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_meter_col_bands,
                                    datum);
}

/* Deletes the value 'delete_value' from the "bands" set column from the
 * "Meter" table in 'row'.
 *
 */
void
sbrec_meter_update_bands_delvalue(const struct sbrec_meter *row, const struct sbrec_meter_band *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_meter_col_bands,
                                    datum);
}

/* Sets the "bands" column from the "Meter" table in 'row' to
 * the 'bands' set with 'n_bands' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_add_clause_bands(struct ovsdb_idl_condition *cond, enum ovsdb_function function, struct uuid **bands, size_t n_bands)
{
    struct ovsdb_datum datum;
    datum.n = n_bands;
    datum.keys = n_bands ? xmalloc(n_bands * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_bands; i++) {
        datum.keys[i].uuid = *bands[i];
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_meter_col_bands,
                          &datum);
    free(datum.keys);
}

/* Sets the "name" column from the "Meter" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_meter_col_name,
                          &datum);
}

/* Sets the "unit" column from the "Meter" table in 'row' to
 * 'unit'.
 *
 * Argument constraints: either "kbps" or "pktps"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_add_clause_unit(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *unit)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, unit);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_meter_col_unit,
                          &datum);
}

/* Destroy 'row' of kind "Meter". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_meter_index_destroy_row(const struct sbrec_meter *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Meter". */
struct sbrec_meter *
sbrec_meter_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter);
    return ALIGNED_CAST(struct sbrec_meter *, ovsdb_idl_index_init_row(index));
}

struct sbrec_meter *
sbrec_meter_index_find(struct ovsdb_idl_index *index, const struct sbrec_meter *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter);
    return sbrec_meter_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_meter_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_meter *a, 
    const struct sbrec_meter *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_meter_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_meter_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_meter *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_meter_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_meter *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_meter *
sbrec_meter_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_meter_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "bands" column from the "Meter" table in 'row' to
 * the 'bands' set with 'n_bands' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_index_set_bands(const struct sbrec_meter *row, struct sbrec_meter_band **bands, size_t n_bands)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_bands;
    datum.keys = n_bands ? xmalloc(n_bands * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_bands; i++) {
        datum.keys[i].uuid = bands[i]->header_.uuid;
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_meter_columns[ SBREC_METER_COL_BANDS ], &datum, &sbrec_table_classes[SBREC_TABLE_METER]);
}

/* Sets the "name" column from the "Meter" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_index_set_name(const struct sbrec_meter *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_meter_columns[ SBREC_METER_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_METER]);
}

/* Sets the "unit" column from the "Meter" table in 'row' to
 * 'unit'.
 *
 * Argument constraints: either "kbps" or "pktps"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_index_set_unit(const struct sbrec_meter *row, const char *unit)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, unit);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_meter_columns[ SBREC_METER_COL_UNIT ], &datum, &sbrec_table_classes[SBREC_TABLE_METER]);
}

struct ovsdb_idl_column sbrec_meter_columns[SBREC_METER_N_COLUMNS];

void
sbrec_meter_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_meter, condition);
}
static union ovsdb_atom Meter_col_unit_key_enum_keys[2] = {
    { .string = "kbps" },
    { .string = "pktps" },
};
static struct ovsdb_datum Meter_col_unit_key_enum = {
    .n = 2,
    .keys = Meter_col_unit_key_enum_keys,
};

struct ovsdb_idl_column sbrec_meter_columns[SBREC_METER_N_COLUMNS] = {
    [SBREC_METER_COL_BANDS] = {
         .name = "bands",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Meter_Band", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_meter_parse_bands,
         .unparse = sbrec_meter_unparse_bands,
    },

    [SBREC_METER_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_meter_parse_name,
         .unparse = sbrec_meter_unparse_name,
    },

    [SBREC_METER_COL_UNIT] = {
         .name = "unit",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .enum_ = &Meter_col_unit_key_enum,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_meter_parse_unit,
         .unparse = sbrec_meter_unparse_unit,
    },

};

/* Meter_Band table. */

const struct sbrec_meter_band_table *
sbrec_meter_band_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_meter_band_table *) idl;
}

const struct sbrec_meter_band *
sbrec_meter_band_table_first(const struct sbrec_meter_band_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_meter_band_first(idl);
}


const struct sbrec_meter_band *
sbrec_meter_band_table_track_get_first(const struct sbrec_meter_band_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_meter_band_track_get_first(idl);
}


static void
sbrec_meter_band_parse_action(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_meter_band *row = sbrec_meter_band_cast(row_);

    if (datum->n >= 1) {
        row->action = datum->keys[0].string;
    } else {
        row->action = "";
    }
}

static void
sbrec_meter_band_parse_burst_size(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_meter_band *row = sbrec_meter_band_cast(row_);

    if (datum->n >= 1) {
        row->burst_size = datum->keys[0].integer;
    } else {
        row->burst_size = 0;
    }
}

static void
sbrec_meter_band_parse_rate(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_meter_band *row = sbrec_meter_band_cast(row_);

    if (datum->n >= 1) {
        row->rate = datum->keys[0].integer;
    } else {
        row->rate = 0;
    }
}

static void
sbrec_meter_band_unparse_action(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_meter_band_unparse_burst_size(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_meter_band_unparse_rate(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_meter_band_init__(struct ovsdb_idl_row *row)
{
    sbrec_meter_band_init(sbrec_meter_band_cast(row));
}

/* Clears the contents of 'row' in table "Meter_Band". */
void
sbrec_meter_band_init(struct sbrec_meter_band *row)
{
    memset(row, 0, sizeof *row); 
    row->action = "";
}

/* Searches table "Meter_Band" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_meter_band *
sbrec_meter_band_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_meter_band_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_meter_band, uuid));
}

/* Searches table "Meter_Band" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_meter_band *
sbrec_meter_band_table_get_for_uuid(const struct sbrec_meter_band_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_meter_band_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Meter_Band" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_meter_band *
sbrec_meter_band_first(const struct ovsdb_idl *idl)
{
    return sbrec_meter_band_cast(ovsdb_idl_first_row(idl, &sbrec_table_meter_band));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_meter_band *
sbrec_meter_band_next(const struct sbrec_meter_band *row)
{
    return sbrec_meter_band_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_meter_band_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_meter_band);
}

unsigned int sbrec_meter_band_row_get_seqno(const struct sbrec_meter_band *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_meter_band *
sbrec_meter_band_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_meter_band_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_meter_band));
}

const struct sbrec_meter_band
*sbrec_meter_band_track_get_next(const struct sbrec_meter_band *row)
{
    return sbrec_meter_band_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Meter_Band".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_meter_band_delete(const struct sbrec_meter_band *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Meter_Band" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_meter_band *
sbrec_meter_band_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_meter_band_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_meter_band, NULL));
}

bool
sbrec_meter_band_is_updated(const struct sbrec_meter_band *row, enum sbrec_meter_band_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_meter_band_columns[column]);
}

/* Causes the original contents of column "action" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "action" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "action" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "action" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_meter_band_insert()).
 *
 *   - If "action" has already been modified (with
 *     sbrec_meter_band_set_action()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_meter_band_set_action() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_meter_band_verify_action(const struct sbrec_meter_band *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_meter_band_col_action);
}

/* Causes the original contents of column "burst_size" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "burst_size" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "burst_size" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "burst_size" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_meter_band_insert()).
 *
 *   - If "burst_size" has already been modified (with
 *     sbrec_meter_band_set_burst_size()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_meter_band_set_burst_size() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_meter_band_verify_burst_size(const struct sbrec_meter_band *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_meter_band_col_burst_size);
}

/* Causes the original contents of column "rate" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "rate" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "rate" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "rate" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_meter_band_insert()).
 *
 *   - If "rate" has already been modified (with
 *     sbrec_meter_band_set_rate()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_meter_band_set_rate() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_meter_band_verify_rate(const struct sbrec_meter_band *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_meter_band_col_rate);
}

/* Returns the "action" column's value from the "Meter_Band" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes action's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "action" member in sbrec_meter_band. */
const struct ovsdb_datum *
sbrec_meter_band_get_action(const struct sbrec_meter_band *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_meter_band_col_action);
}

/* Returns the "burst_size" column's value from the "Meter_Band" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes burst_size's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "burst_size" member in sbrec_meter_band. */
const struct ovsdb_datum *
sbrec_meter_band_get_burst_size(const struct sbrec_meter_band *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_meter_band_col_burst_size);
}

/* Returns the "rate" column's value from the "Meter_Band" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes rate's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "rate" member in sbrec_meter_band. */
const struct ovsdb_datum *
sbrec_meter_band_get_rate(const struct sbrec_meter_band *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_meter_band_col_rate);
}

/* Sets the "action" column from the "Meter_Band" table in 'row' to
 * 'action'.
 *
 * Argument constraints: must be "drop"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_set_action(const struct sbrec_meter_band *row, const char *action)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, action);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_meter_band_col_action, &datum);
}

/* Sets the "burst_size" column from the "Meter_Band" table in 'row' to
 * 'burst_size'.
 *
 * Argument constraints: in range 0 to 4,294,967,295
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_set_burst_size(const struct sbrec_meter_band *row, int64_t burst_size)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = burst_size;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_meter_band_col_burst_size, &datum);
}

/* Sets the "rate" column from the "Meter_Band" table in 'row' to
 * 'rate'.
 *
 * Argument constraints: in range 1 to 4,294,967,295
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_set_rate(const struct sbrec_meter_band *row, int64_t rate)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = rate;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_meter_band_col_rate, &datum);
}

/* Sets the "action" column from the "Meter_Band" table in 'row' to
 * 'action'.
 *
 * Argument constraints: must be "drop"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_add_clause_action(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *action)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, action);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_meter_band_col_action,
                          &datum);
}

/* Sets the "burst_size" column from the "Meter_Band" table in 'row' to
 * 'burst_size'.
 *
 * Argument constraints: in range 0 to 4,294,967,295
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_add_clause_burst_size(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t burst_size)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = burst_size;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_meter_band_col_burst_size,
                          &datum);
}

/* Sets the "rate" column from the "Meter_Band" table in 'row' to
 * 'rate'.
 *
 * Argument constraints: in range 1 to 4,294,967,295
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_add_clause_rate(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t rate)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = rate;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_meter_band_col_rate,
                          &datum);
}

/* Destroy 'row' of kind "Meter_Band". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_meter_band_index_destroy_row(const struct sbrec_meter_band *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Meter_Band". */
struct sbrec_meter_band *
sbrec_meter_band_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter_band);
    return ALIGNED_CAST(struct sbrec_meter_band *, ovsdb_idl_index_init_row(index));
}

struct sbrec_meter_band *
sbrec_meter_band_index_find(struct ovsdb_idl_index *index, const struct sbrec_meter_band *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter_band);
    return sbrec_meter_band_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_meter_band_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_meter_band *a, 
    const struct sbrec_meter_band *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_meter_band_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter_band);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_meter_band_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_meter_band *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter_band);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_meter_band_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_meter_band *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_meter_band);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_meter_band *
sbrec_meter_band_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_meter_band_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "action" column from the "Meter_Band" table in 'row' to
 * 'action'.
 *
 * Argument constraints: must be "drop"
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_index_set_action(const struct sbrec_meter_band *row, const char *action)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, action);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_meter_band_columns[ SBREC_METER_BAND_COL_ACTION ], &datum, &sbrec_table_classes[SBREC_TABLE_METER_BAND]);
}

/* Sets the "burst_size" column from the "Meter_Band" table in 'row' to
 * 'burst_size'.
 *
 * Argument constraints: in range 0 to 4,294,967,295
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_index_set_burst_size(const struct sbrec_meter_band *row, int64_t burst_size)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = burst_size;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_meter_band_columns[ SBREC_METER_BAND_COL_BURST_SIZE ], &datum, &sbrec_table_classes[SBREC_TABLE_METER_BAND]);
}

/* Sets the "rate" column from the "Meter_Band" table in 'row' to
 * 'rate'.
 *
 * Argument constraints: in range 1 to 4,294,967,295
 *
 * The caller retains ownership of the arguments. */
void
sbrec_meter_band_index_set_rate(const struct sbrec_meter_band *row, int64_t rate)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = rate;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_meter_band_columns[ SBREC_METER_BAND_COL_RATE ], &datum, &sbrec_table_classes[SBREC_TABLE_METER_BAND]);
}

struct ovsdb_idl_column sbrec_meter_band_columns[SBREC_METER_BAND_N_COLUMNS];

void
sbrec_meter_band_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_meter_band, condition);
}
static union ovsdb_atom Meter_Band_col_action_key_enum_keys[1] = {
    { .string = "drop" },
};
static struct ovsdb_datum Meter_Band_col_action_key_enum = {
    .n = 1,
    .keys = Meter_Band_col_action_key_enum_keys,
};

struct ovsdb_idl_column sbrec_meter_band_columns[SBREC_METER_BAND_N_COLUMNS] = {
    [SBREC_METER_BAND_COL_ACTION] = {
         .name = "action",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .enum_ = &Meter_Band_col_action_key_enum,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_meter_band_parse_action,
         .unparse = sbrec_meter_band_unparse_action,
    },

    [SBREC_METER_BAND_COL_BURST_SIZE] = {
         .name = "burst_size",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(0), .max = INT64_C(4294967295) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_meter_band_parse_burst_size,
         .unparse = sbrec_meter_band_unparse_burst_size,
    },

    [SBREC_METER_BAND_COL_RATE] = {
         .name = "rate",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(1), .max = INT64_C(4294967295) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_meter_band_parse_rate,
         .unparse = sbrec_meter_band_unparse_rate,
    },

};

/* Multicast_Group table. */

const struct sbrec_multicast_group_table *
sbrec_multicast_group_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_multicast_group_table *) idl;
}

const struct sbrec_multicast_group *
sbrec_multicast_group_table_first(const struct sbrec_multicast_group_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_multicast_group_first(idl);
}


const struct sbrec_multicast_group *
sbrec_multicast_group_table_track_get_first(const struct sbrec_multicast_group_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_multicast_group_track_get_first(idl);
}


static void
sbrec_multicast_group_parse_datapath(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_multicast_group *row = sbrec_multicast_group_cast(row_);

    if (datum->n >= 1) {
        row->datapath = sbrec_datapath_binding_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_datapath_binding, &datum->keys[0].uuid));
    } else {
        row->datapath = NULL;
    }
}

static void
sbrec_multicast_group_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_multicast_group *row = sbrec_multicast_group_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_multicast_group_parse_ports(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_multicast_group *row = sbrec_multicast_group_cast(row_);
    row->ports = NULL;
    row->n_ports = 0;
    for (size_t i = 0; i < datum->n; i++) {
        struct sbrec_port_binding *keyRow = sbrec_port_binding_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_port_binding, &datum->keys[i].uuid));
        if (!keyRow) {
            continue;
        }
        if (!row->n_ports) {
            row->ports = xmalloc(datum->n * sizeof *row->ports);
        }
        row->ports[row->n_ports] = keyRow;
        row->n_ports++;
    }
}

static void
sbrec_multicast_group_parse_tunnel_key(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_multicast_group *row = sbrec_multicast_group_cast(row_);

    if (datum->n >= 1) {
        row->tunnel_key = datum->keys[0].integer;
    } else {
        row->tunnel_key = 0;
    }
}

static void
sbrec_multicast_group_unparse_datapath(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_multicast_group_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_multicast_group_unparse_ports(struct ovsdb_idl_row *row_)
{
    struct sbrec_multicast_group *row = sbrec_multicast_group_cast(row_);
    free(row->ports);
}

static void
sbrec_multicast_group_unparse_tunnel_key(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_multicast_group_init__(struct ovsdb_idl_row *row)
{
    sbrec_multicast_group_init(sbrec_multicast_group_cast(row));
}

/* Clears the contents of 'row' in table "Multicast_Group". */
void
sbrec_multicast_group_init(struct sbrec_multicast_group *row)
{
    memset(row, 0, sizeof *row); 
    row->name = "";
}

/* Searches table "Multicast_Group" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_multicast_group *
sbrec_multicast_group_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_multicast_group_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_multicast_group, uuid));
}

/* Searches table "Multicast_Group" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_multicast_group *
sbrec_multicast_group_table_get_for_uuid(const struct sbrec_multicast_group_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_multicast_group_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Multicast_Group" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_multicast_group *
sbrec_multicast_group_first(const struct ovsdb_idl *idl)
{
    return sbrec_multicast_group_cast(ovsdb_idl_first_row(idl, &sbrec_table_multicast_group));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_multicast_group *
sbrec_multicast_group_next(const struct sbrec_multicast_group *row)
{
    return sbrec_multicast_group_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_multicast_group_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_multicast_group);
}

unsigned int sbrec_multicast_group_row_get_seqno(const struct sbrec_multicast_group *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_multicast_group *
sbrec_multicast_group_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_multicast_group_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_multicast_group));
}

const struct sbrec_multicast_group
*sbrec_multicast_group_track_get_next(const struct sbrec_multicast_group *row)
{
    return sbrec_multicast_group_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Multicast_Group".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_multicast_group_delete(const struct sbrec_multicast_group *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Multicast_Group" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_multicast_group *
sbrec_multicast_group_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_multicast_group_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_multicast_group, NULL));
}

bool
sbrec_multicast_group_is_updated(const struct sbrec_multicast_group *row, enum sbrec_multicast_group_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_multicast_group_columns[column]);
}

/* Causes the original contents of column "datapath" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "datapath" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "datapath" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "datapath" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_multicast_group_insert()).
 *
 *   - If "datapath" has already been modified (with
 *     sbrec_multicast_group_set_datapath()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_multicast_group_set_datapath() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_multicast_group_verify_datapath(const struct sbrec_multicast_group *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_multicast_group_col_datapath);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_multicast_group_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_multicast_group_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_multicast_group_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_multicast_group_verify_name(const struct sbrec_multicast_group *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_multicast_group_col_name);
}

/* Causes the original contents of column "ports" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ports" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ports" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ports" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_multicast_group_insert()).
 *
 *   - If "ports" has already been modified (with
 *     sbrec_multicast_group_set_ports()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_multicast_group_set_ports() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_multicast_group_verify_ports(const struct sbrec_multicast_group *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_multicast_group_col_ports);
}

/* Causes the original contents of column "tunnel_key" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "tunnel_key" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "tunnel_key" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "tunnel_key" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_multicast_group_insert()).
 *
 *   - If "tunnel_key" has already been modified (with
 *     sbrec_multicast_group_set_tunnel_key()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_multicast_group_set_tunnel_key() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_multicast_group_verify_tunnel_key(const struct sbrec_multicast_group *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_multicast_group_col_tunnel_key);
}

/* Returns the "datapath" column's value from the "Multicast_Group" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes datapath's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "datapath" member in sbrec_multicast_group. */
const struct ovsdb_datum *
sbrec_multicast_group_get_datapath(const struct sbrec_multicast_group *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_multicast_group_col_datapath);
}

/* Returns the "name" column's value from the "Multicast_Group" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_multicast_group. */
const struct ovsdb_datum *
sbrec_multicast_group_get_name(const struct sbrec_multicast_group *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_multicast_group_col_name);
}

/* Returns the "ports" column's value from the "Multicast_Group" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes ports's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ports" member in sbrec_multicast_group. */
const struct ovsdb_datum *
sbrec_multicast_group_get_ports(const struct sbrec_multicast_group *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_multicast_group_col_ports);
}

/* Returns the "tunnel_key" column's value from the "Multicast_Group" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes tunnel_key's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "tunnel_key" member in sbrec_multicast_group. */
const struct ovsdb_datum *
sbrec_multicast_group_get_tunnel_key(const struct sbrec_multicast_group *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_multicast_group_col_tunnel_key);
}

/* Sets the "datapath" column from the "Multicast_Group" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_set_datapath(const struct sbrec_multicast_group *row, const struct sbrec_datapath_binding *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.uuid = datapath->header_.uuid;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_multicast_group_col_datapath, &datum);
}

/* Sets the "name" column from the "Multicast_Group" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_set_name(const struct sbrec_multicast_group *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_multicast_group_col_name, &datum);
}

/* Sets the "ports" column from the "Multicast_Group" table in 'row' to
 * the 'ports' set with 'n_ports' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_set_ports(const struct sbrec_multicast_group *row, struct sbrec_port_binding **ports, size_t n_ports)
{
    struct ovsdb_datum datum;

    datum.n = n_ports;
    datum.keys = n_ports ? xmalloc(n_ports * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_ports; i++) {
        datum.keys[i].uuid = ports[i]->header_.uuid;
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_multicast_group_col_ports, &datum);
}

/* Sets the "tunnel_key" column from the "Multicast_Group" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 32,768 to 65,535
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_set_tunnel_key(const struct sbrec_multicast_group *row, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_multicast_group_col_tunnel_key, &datum);
}

/* Adds the value 'new_value' to the "ports" set column from the "Multicast_Group" table
 * in 'row'.
 *
 */
void
sbrec_multicast_group_update_ports_addvalue(const struct sbrec_multicast_group *row, const struct sbrec_port_binding *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_multicast_group_col_ports,
                                    datum);
}

/* Deletes the value 'delete_value' from the "ports" set column from the
 * "Multicast_Group" table in 'row'.
 *
 */
void
sbrec_multicast_group_update_ports_delvalue(const struct sbrec_multicast_group *row, const struct sbrec_port_binding *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_multicast_group_col_ports,
                                    datum);
}

/* Sets the "datapath" column from the "Multicast_Group" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_add_clause_datapath(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct uuid *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.uuid = *datapath;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_multicast_group_col_datapath,
                          &datum);
}

/* Sets the "name" column from the "Multicast_Group" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_multicast_group_col_name,
                          &datum);
}

/* Sets the "ports" column from the "Multicast_Group" table in 'row' to
 * the 'ports' set with 'n_ports' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_add_clause_ports(struct ovsdb_idl_condition *cond, enum ovsdb_function function, struct uuid **ports, size_t n_ports)
{
    struct ovsdb_datum datum;
    datum.n = n_ports;
    datum.keys = n_ports ? xmalloc(n_ports * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_ports; i++) {
        datum.keys[i].uuid = *ports[i];
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_multicast_group_col_ports,
                          &datum);
    free(datum.keys);
}

/* Sets the "tunnel_key" column from the "Multicast_Group" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 32,768 to 65,535
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_add_clause_tunnel_key(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_multicast_group_col_tunnel_key,
                          &datum);
}

/* Destroy 'row' of kind "Multicast_Group". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_multicast_group_index_destroy_row(const struct sbrec_multicast_group *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Multicast_Group". */
struct sbrec_multicast_group *
sbrec_multicast_group_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_multicast_group);
    return ALIGNED_CAST(struct sbrec_multicast_group *, ovsdb_idl_index_init_row(index));
}

struct sbrec_multicast_group *
sbrec_multicast_group_index_find(struct ovsdb_idl_index *index, const struct sbrec_multicast_group *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_multicast_group);
    return sbrec_multicast_group_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_multicast_group_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_multicast_group *a, 
    const struct sbrec_multicast_group *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_multicast_group_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_multicast_group);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_multicast_group_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_multicast_group *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_multicast_group);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_multicast_group_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_multicast_group *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_multicast_group);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_multicast_group *
sbrec_multicast_group_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_multicast_group_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "datapath" column from the "Multicast_Group" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_index_set_datapath(const struct sbrec_multicast_group *row, const struct sbrec_datapath_binding *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->uuid = datapath->header_.uuid;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_multicast_group_columns[ SBREC_MULTICAST_GROUP_COL_DATAPATH ], &datum, &sbrec_table_classes[SBREC_TABLE_MULTICAST_GROUP]);
}

/* Sets the "name" column from the "Multicast_Group" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_index_set_name(const struct sbrec_multicast_group *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_multicast_group_columns[ SBREC_MULTICAST_GROUP_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_MULTICAST_GROUP]);
}

/* Sets the "ports" column from the "Multicast_Group" table in 'row' to
 * the 'ports' set with 'n_ports' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_index_set_ports(const struct sbrec_multicast_group *row, struct sbrec_port_binding **ports, size_t n_ports)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_ports;
    datum.keys = n_ports ? xmalloc(n_ports * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_ports; i++) {
        datum.keys[i].uuid = ports[i]->header_.uuid;
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_multicast_group_columns[ SBREC_MULTICAST_GROUP_COL_PORTS ], &datum, &sbrec_table_classes[SBREC_TABLE_MULTICAST_GROUP]);
}

/* Sets the "tunnel_key" column from the "Multicast_Group" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 32,768 to 65,535
 *
 * The caller retains ownership of the arguments. */
void
sbrec_multicast_group_index_set_tunnel_key(const struct sbrec_multicast_group *row, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_multicast_group_columns[ SBREC_MULTICAST_GROUP_COL_TUNNEL_KEY ], &datum, &sbrec_table_classes[SBREC_TABLE_MULTICAST_GROUP]);
}

struct ovsdb_idl_column sbrec_multicast_group_columns[SBREC_MULTICAST_GROUP_N_COLUMNS];

void
sbrec_multicast_group_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_multicast_group, condition);
}

struct ovsdb_idl_column sbrec_multicast_group_columns[SBREC_MULTICAST_GROUP_N_COLUMNS] = {
    [SBREC_MULTICAST_GROUP_COL_DATAPATH] = {
         .name = "datapath",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Datapath_Binding", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_multicast_group_parse_datapath,
         .unparse = sbrec_multicast_group_unparse_datapath,
    },

    [SBREC_MULTICAST_GROUP_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_multicast_group_parse_name,
         .unparse = sbrec_multicast_group_unparse_name,
    },

    [SBREC_MULTICAST_GROUP_COL_PORTS] = {
         .name = "ports",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Port_Binding", .refType = OVSDB_REF_WEAK },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_multicast_group_parse_ports,
         .unparse = sbrec_multicast_group_unparse_ports,
    },

    [SBREC_MULTICAST_GROUP_COL_TUNNEL_KEY] = {
         .name = "tunnel_key",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(32768), .max = INT64_C(65535) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_multicast_group_parse_tunnel_key,
         .unparse = sbrec_multicast_group_unparse_tunnel_key,
    },

};

/* Port_Binding table. */

const struct sbrec_port_binding_table *
sbrec_port_binding_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_port_binding_table *) idl;
}

const struct sbrec_port_binding *
sbrec_port_binding_table_first(const struct sbrec_port_binding_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_port_binding_first(idl);
}


const struct sbrec_port_binding *
sbrec_port_binding_table_track_get_first(const struct sbrec_port_binding_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_port_binding_track_get_first(idl);
}


static void
sbrec_port_binding_parse_chassis(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);

    if (datum->n >= 1) {
        row->chassis = sbrec_chassis_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_chassis, &datum->keys[0].uuid));
    } else {
        row->chassis = NULL;
    }
}

static void
sbrec_port_binding_parse_datapath(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);

    if (datum->n >= 1) {
        row->datapath = sbrec_datapath_binding_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_datapath_binding, &datum->keys[0].uuid));
    } else {
        row->datapath = NULL;
    }
}

static void
sbrec_port_binding_parse_encap(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);

    if (datum->n >= 1) {
        row->encap = sbrec_encap_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_encap, &datum->keys[0].uuid));
    } else {
        row->encap = NULL;
    }
}

static void
sbrec_port_binding_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_port_binding_parse_gateway_chassis(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    row->gateway_chassis = NULL;
    row->n_gateway_chassis = 0;
    for (size_t i = 0; i < datum->n; i++) {
        struct sbrec_gateway_chassis *keyRow = sbrec_gateway_chassis_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_gateway_chassis, &datum->keys[i].uuid));
        if (!keyRow) {
            continue;
        }
        if (!row->n_gateway_chassis) {
            row->gateway_chassis = xmalloc(datum->n * sizeof *row->gateway_chassis);
        }
        row->gateway_chassis[row->n_gateway_chassis] = keyRow;
        row->n_gateway_chassis++;
    }
}

static void
sbrec_port_binding_parse_logical_port(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);

    if (datum->n >= 1) {
        row->logical_port = datum->keys[0].string;
    } else {
        row->logical_port = "";
    }
}

static void
sbrec_port_binding_parse_mac(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    row->mac = NULL;
    row->n_mac = 0;
    for (size_t i = 0; i < datum->n; i++) {
        if (!row->n_mac) {
            row->mac = xmalloc(datum->n * sizeof *row->mac);
        }
        row->mac[row->n_mac] = datum->keys[i].string;
        row->n_mac++;
    }
}

static void
sbrec_port_binding_parse_nat_addresses(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    row->nat_addresses = NULL;
    row->n_nat_addresses = 0;
    for (size_t i = 0; i < datum->n; i++) {
        if (!row->n_nat_addresses) {
            row->nat_addresses = xmalloc(datum->n * sizeof *row->nat_addresses);
        }
        row->nat_addresses[row->n_nat_addresses] = datum->keys[i].string;
        row->n_nat_addresses++;
    }
}

static void
sbrec_port_binding_parse_options(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    smap_init(&row->options);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->options,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_port_binding_parse_parent_port(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);

    if (datum->n >= 1) {
        row->parent_port = datum->keys[0].string;
    } else {
        row->parent_port = NULL;
    }
}

static void
sbrec_port_binding_parse_tag(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    size_t n = MIN(1, datum->n);
    row->tag = NULL;
    row->n_tag = 0;
    for (size_t i = 0; i < n; i++) {
        if (!row->n_tag) {
            row->tag = xmalloc(n * sizeof *row->tag);
        }
        row->tag[row->n_tag] = datum->keys[i].integer;
        row->n_tag++;
    }
}

static void
sbrec_port_binding_parse_tunnel_key(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);

    if (datum->n >= 1) {
        row->tunnel_key = datum->keys[0].integer;
    } else {
        row->tunnel_key = 0;
    }
}

static void
sbrec_port_binding_parse_type(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);

    if (datum->n >= 1) {
        row->type = datum->keys[0].string;
    } else {
        row->type = "";
    }
}

static void
sbrec_port_binding_unparse_chassis(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_port_binding_unparse_datapath(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_port_binding_unparse_encap(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_port_binding_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_port_binding_unparse_gateway_chassis(struct ovsdb_idl_row *row_)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    free(row->gateway_chassis);
}

static void
sbrec_port_binding_unparse_logical_port(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_port_binding_unparse_mac(struct ovsdb_idl_row *row_)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    free(row->mac);
}

static void
sbrec_port_binding_unparse_nat_addresses(struct ovsdb_idl_row *row_)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    free(row->nat_addresses);
}

static void
sbrec_port_binding_unparse_options(struct ovsdb_idl_row *row_)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    smap_destroy(&row->options);
}

static void
sbrec_port_binding_unparse_parent_port(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_port_binding_unparse_tag(struct ovsdb_idl_row *row_)
{
    struct sbrec_port_binding *row = sbrec_port_binding_cast(row_);
    free(row->tag);
}

static void
sbrec_port_binding_unparse_tunnel_key(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_port_binding_unparse_type(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_port_binding_init__(struct ovsdb_idl_row *row)
{
    sbrec_port_binding_init(sbrec_port_binding_cast(row));
}

/* Clears the contents of 'row' in table "Port_Binding". */
void
sbrec_port_binding_init(struct sbrec_port_binding *row)
{
    memset(row, 0, sizeof *row); 
    smap_init(&row->external_ids);
    row->logical_port = "";
    smap_init(&row->options);
    row->type = "";
}

/* Searches table "Port_Binding" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_port_binding *
sbrec_port_binding_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_port_binding_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_port_binding, uuid));
}

/* Searches table "Port_Binding" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_port_binding *
sbrec_port_binding_table_get_for_uuid(const struct sbrec_port_binding_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_port_binding_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Port_Binding" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_port_binding *
sbrec_port_binding_first(const struct ovsdb_idl *idl)
{
    return sbrec_port_binding_cast(ovsdb_idl_first_row(idl, &sbrec_table_port_binding));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_port_binding *
sbrec_port_binding_next(const struct sbrec_port_binding *row)
{
    return sbrec_port_binding_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_port_binding_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_port_binding);
}

unsigned int sbrec_port_binding_row_get_seqno(const struct sbrec_port_binding *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_port_binding *
sbrec_port_binding_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_port_binding_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_port_binding));
}

const struct sbrec_port_binding
*sbrec_port_binding_track_get_next(const struct sbrec_port_binding *row)
{
    return sbrec_port_binding_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Port_Binding".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_delete(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Port_Binding" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_port_binding *
sbrec_port_binding_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_port_binding_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_port_binding, NULL));
}

bool
sbrec_port_binding_is_updated(const struct sbrec_port_binding *row, enum sbrec_port_binding_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_port_binding_columns[column]);
}

/* Causes the original contents of column "chassis" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "chassis" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "chassis" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "chassis" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "chassis" has already been modified (with
 *     sbrec_port_binding_set_chassis()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_chassis() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_chassis(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_chassis);
}

/* Causes the original contents of column "datapath" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "datapath" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "datapath" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "datapath" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "datapath" has already been modified (with
 *     sbrec_port_binding_set_datapath()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_datapath() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_datapath(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_datapath);
}

/* Causes the original contents of column "encap" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "encap" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "encap" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "encap" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "encap" has already been modified (with
 *     sbrec_port_binding_set_encap()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_encap() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_encap(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_encap);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_port_binding_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_external_ids(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_external_ids);
}

/* Causes the original contents of column "gateway_chassis" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "gateway_chassis" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "gateway_chassis" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "gateway_chassis" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "gateway_chassis" has already been modified (with
 *     sbrec_port_binding_set_gateway_chassis()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_gateway_chassis() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_gateway_chassis(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_gateway_chassis);
}

/* Causes the original contents of column "logical_port" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "logical_port" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "logical_port" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "logical_port" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "logical_port" has already been modified (with
 *     sbrec_port_binding_set_logical_port()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_logical_port() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_logical_port(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_logical_port);
}

/* Causes the original contents of column "mac" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "mac" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "mac" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "mac" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "mac" has already been modified (with
 *     sbrec_port_binding_set_mac()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_mac() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_mac(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_mac);
}

/* Causes the original contents of column "nat_addresses" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "nat_addresses" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "nat_addresses" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "nat_addresses" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "nat_addresses" has already been modified (with
 *     sbrec_port_binding_set_nat_addresses()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_nat_addresses() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_nat_addresses(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_nat_addresses);
}

/* Causes the original contents of column "options" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "options" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "options" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "options" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "options" has already been modified (with
 *     sbrec_port_binding_set_options()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_options() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_options(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_options);
}

/* Causes the original contents of column "parent_port" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "parent_port" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "parent_port" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "parent_port" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "parent_port" has already been modified (with
 *     sbrec_port_binding_set_parent_port()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_parent_port() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_parent_port(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_parent_port);
}

/* Causes the original contents of column "tag" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "tag" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "tag" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "tag" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "tag" has already been modified (with
 *     sbrec_port_binding_set_tag()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_tag() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_tag(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_tag);
}

/* Causes the original contents of column "tunnel_key" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "tunnel_key" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "tunnel_key" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "tunnel_key" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "tunnel_key" has already been modified (with
 *     sbrec_port_binding_set_tunnel_key()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_tunnel_key() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_tunnel_key(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_tunnel_key);
}

/* Causes the original contents of column "type" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "type" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "type" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "type" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_binding_insert()).
 *
 *   - If "type" has already been modified (with
 *     sbrec_port_binding_set_type()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_binding_set_type() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_binding_verify_type(const struct sbrec_port_binding *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_binding_col_type);
}

/* Returns the "chassis" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes chassis's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "chassis" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_chassis(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_chassis);
}

/* Returns the "datapath" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes datapath's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "datapath" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_datapath(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_datapath);
}

/* Returns the "encap" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes encap's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "encap" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_encap(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_encap);
}

/* Returns the "external_ids" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_external_ids(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_external_ids);
}

/* Returns the "gateway_chassis" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes gateway_chassis's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "gateway_chassis" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_gateway_chassis(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_gateway_chassis);
}

/* Returns the "logical_port" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes logical_port's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "logical_port" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_logical_port(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_logical_port);
}

/* Returns the "mac" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes mac's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "mac" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_mac(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_mac);
}

/* Returns the "nat_addresses" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes nat_addresses's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "nat_addresses" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_nat_addresses(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_nat_addresses);
}

/* Returns the "options" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes options's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "options" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_options(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_options);
}

/* Returns the "parent_port" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes parent_port's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "parent_port" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_parent_port(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_parent_port);
}

/* Returns the "tag" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes tag's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "tag" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_tag(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_tag);
}

/* Returns the "tunnel_key" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes tunnel_key's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "tunnel_key" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_tunnel_key(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_tunnel_key);
}

/* Returns the "type" column's value from the "Port_Binding" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes type's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "type" member in sbrec_port_binding. */
const struct ovsdb_datum *
sbrec_port_binding_get_type(const struct sbrec_port_binding *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_binding_col_type);
}

/* Sets the "chassis" column from the "Port_Binding" table in 'row' to
 * the 'chassis' set.
 *
 * If "chassis" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_chassis(const struct sbrec_port_binding *row, const struct sbrec_chassis *chassis)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (chassis) {
        datum.n = 1;
        datum.keys = &key;
        key.uuid = chassis->header_.uuid;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_binding_col_chassis, &datum);
}

/* Sets the "datapath" column from the "Port_Binding" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_datapath(const struct sbrec_port_binding *row, const struct sbrec_datapath_binding *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.uuid = datapath->header_.uuid;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_binding_col_datapath, &datum);
}

/* Sets the "encap" column from the "Port_Binding" table in 'row' to
 * the 'encap' set.
 *
 * If "encap" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_encap(const struct sbrec_port_binding *row, const struct sbrec_encap *encap)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (encap) {
        datum.n = 1;
        datum.keys = &key;
        key.uuid = encap->header_.uuid;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_binding_col_encap, &datum);
}

/* Sets the "external_ids" column's value from the "Port_Binding" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_port_binding_set_external_ids(const struct sbrec_port_binding *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_port_binding_col_external_ids,
                        &datum);
}


/* Sets the "gateway_chassis" column from the "Port_Binding" table in 'row' to
 * the 'gateway_chassis' set with 'n_gateway_chassis' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_gateway_chassis(const struct sbrec_port_binding *row, struct sbrec_gateway_chassis **gateway_chassis, size_t n_gateway_chassis)
{
    struct ovsdb_datum datum;

    datum.n = n_gateway_chassis;
    datum.keys = n_gateway_chassis ? xmalloc(n_gateway_chassis * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_gateway_chassis; i++) {
        datum.keys[i].uuid = gateway_chassis[i]->header_.uuid;
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_port_binding_col_gateway_chassis, &datum);
}

/* Sets the "logical_port" column from the "Port_Binding" table in 'row' to
 * 'logical_port'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_logical_port(const struct sbrec_port_binding *row, const char *logical_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, logical_port);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_binding_col_logical_port, &datum);
}

/* Sets the "mac" column from the "Port_Binding" table in 'row' to
 * the 'mac' set with 'n_mac' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_mac(const struct sbrec_port_binding *row, const char **mac, size_t n_mac)
{
    struct ovsdb_datum datum;

    datum.n = n_mac;
    datum.keys = n_mac ? xmalloc(n_mac * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_mac; i++) {
        datum.keys[i].string = xstrdup(mac[i]);
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_port_binding_col_mac, &datum);
}

/* Sets the "nat_addresses" column from the "Port_Binding" table in 'row' to
 * the 'nat_addresses' set with 'n_nat_addresses' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_nat_addresses(const struct sbrec_port_binding *row, const char **nat_addresses, size_t n_nat_addresses)
{
    struct ovsdb_datum datum;

    datum.n = n_nat_addresses;
    datum.keys = n_nat_addresses ? xmalloc(n_nat_addresses * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_nat_addresses; i++) {
        datum.keys[i].string = xstrdup(nat_addresses[i]);
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_port_binding_col_nat_addresses, &datum);
}

/* Sets the "options" column's value from the "Port_Binding" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_port_binding_set_options(const struct sbrec_port_binding *row, const struct smap *options)
{
    struct ovsdb_datum datum;

    if (options) {
        ovsdb_datum_from_smap(&datum, options);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_port_binding_col_options,
                        &datum);
}


/* Sets the "parent_port" column from the "Port_Binding" table in 'row' to
 * the 'parent_port' set.
 *
 * If "parent_port" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_parent_port(const struct sbrec_port_binding *row, const char *parent_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (parent_port) {
        datum.n = 1;
        datum.keys = &key;
        key.string = CONST_CAST(char *, parent_port);
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_binding_col_parent_port, &datum);
}

/* Sets the "tag" column from the "Port_Binding" table in 'row' to
 * the 'tag' set with 'n_tag' entries.
 *
 * 'n_tag' may be 0 or 1; if it is 0, then 'tag'
 * may be NULL.
 *
 * Argument constraints: in range 1 to 4,095
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_tag(const struct sbrec_port_binding *row, const int64_t *tag, size_t n_tag)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (n_tag) {
        datum.n = 1;
        datum.keys = &key;
        key.integer = *tag;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_binding_col_tag, &datum);
}

/* Sets the "tunnel_key" column from the "Port_Binding" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 1 to 32,767
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_tunnel_key(const struct sbrec_port_binding *row, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_binding_col_tunnel_key, &datum);
}

/* Sets the "type" column from the "Port_Binding" table in 'row' to
 * 'type'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_set_type(const struct sbrec_port_binding *row, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_binding_col_type, &datum);
}

/* Adds the value 'new_value' to the "chassis" set column from the "Port_Binding" table
 * in 'row'.
 *
 */
void
sbrec_port_binding_update_chassis_addvalue(const struct sbrec_port_binding *row, const struct sbrec_chassis *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_port_binding_col_chassis,
                                    datum);
}

/* Deletes the value 'delete_value' from the "chassis" set column from the
 * "Port_Binding" table in 'row'.
 *
 */
void
sbrec_port_binding_update_chassis_delvalue(const struct sbrec_port_binding *row, const struct sbrec_chassis *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_port_binding_col_chassis,
                                    datum);
}

/* Adds the value 'new_value' to the "encap" set column from the "Port_Binding" table
 * in 'row'.
 *
 */
void
sbrec_port_binding_update_encap_addvalue(const struct sbrec_port_binding *row, const struct sbrec_encap *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_port_binding_col_encap,
                                    datum);
}

/* Deletes the value 'delete_value' from the "encap" set column from the
 * "Port_Binding" table in 'row'.
 *
 */
void
sbrec_port_binding_update_encap_delvalue(const struct sbrec_port_binding *row, const struct sbrec_encap *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_port_binding_col_encap,
                                    datum);
}

/* Sets an element of the "external_ids" map column from the "Port_Binding" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_port_binding_update_external_ids_setkey(const struct sbrec_port_binding *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_port_binding_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "Port_Binding" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_port_binding_update_external_ids_delkey(const struct sbrec_port_binding *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_port_binding_col_external_ids,
                                    datum);
}

/* Adds the value 'new_value' to the "gateway_chassis" set column from the "Port_Binding" table
 * in 'row'.
 *
 */
void
sbrec_port_binding_update_gateway_chassis_addvalue(const struct sbrec_port_binding *row, const struct sbrec_gateway_chassis *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_port_binding_col_gateway_chassis,
                                    datum);
}

/* Deletes the value 'delete_value' from the "gateway_chassis" set column from the
 * "Port_Binding" table in 'row'.
 *
 */
void
sbrec_port_binding_update_gateway_chassis_delvalue(const struct sbrec_port_binding *row, const struct sbrec_gateway_chassis *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_port_binding_col_gateway_chassis,
                                    datum);
}

/* Adds the value 'new_value' to the "mac" set column from the "Port_Binding" table
 * in 'row'.
 *
 */
void
sbrec_port_binding_update_mac_addvalue(const struct sbrec_port_binding *row, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_port_binding_col_mac,
                                    datum);
}

/* Deletes the value 'delete_value' from the "mac" set column from the
 * "Port_Binding" table in 'row'.
 *
 */
void
sbrec_port_binding_update_mac_delvalue(const struct sbrec_port_binding *row, const char *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_value);

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_port_binding_col_mac,
                                    datum);
}

/* Adds the value 'new_value' to the "nat_addresses" set column from the "Port_Binding" table
 * in 'row'.
 *
 */
void
sbrec_port_binding_update_nat_addresses_addvalue(const struct sbrec_port_binding *row, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_port_binding_col_nat_addresses,
                                    datum);
}

/* Deletes the value 'delete_value' from the "nat_addresses" set column from the
 * "Port_Binding" table in 'row'.
 *
 */
void
sbrec_port_binding_update_nat_addresses_delvalue(const struct sbrec_port_binding *row, const char *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_value);

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_port_binding_col_nat_addresses,
                                    datum);
}

/* Sets an element of the "options" map column from the "Port_Binding" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_port_binding_update_options_setkey(const struct sbrec_port_binding *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_port_binding_col_options,
                                    datum);
}

/* Deletes an element of the "options" map column from the "Port_Binding" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_port_binding_update_options_delkey(const struct sbrec_port_binding *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_port_binding_col_options,
                                    datum);
}

/* Adds the value 'new_value' to the "parent_port" set column from the "Port_Binding" table
 * in 'row'.
 *
 */
void
sbrec_port_binding_update_parent_port_addvalue(const struct sbrec_port_binding *row, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_port_binding_col_parent_port,
                                    datum);
}

/* Deletes the value 'delete_value' from the "parent_port" set column from the
 * "Port_Binding" table in 'row'.
 *
 */
void
sbrec_port_binding_update_parent_port_delvalue(const struct sbrec_port_binding *row, const char *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_value);

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_port_binding_col_parent_port,
                                    datum);
}

/* Adds the value 'new_value' to the "tag" set column from the "Port_Binding" table
 * in 'row'.
 *
 */
void
sbrec_port_binding_update_tag_addvalue(const struct sbrec_port_binding *row, int64_t new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].integer = new_value;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_port_binding_col_tag,
                                    datum);
}

/* Deletes the value 'delete_value' from the "tag" set column from the
 * "Port_Binding" table in 'row'.
 *
 */
void
sbrec_port_binding_update_tag_delvalue(const struct sbrec_port_binding *row, int64_t delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].integer = delete_value;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_port_binding_col_tag,
                                    datum);
}

/* Sets the "chassis" column from the "Port_Binding" table in 'row' to
 * the 'chassis' set.
 *
 * If "chassis" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_chassis(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct uuid *chassis)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (chassis) {
        datum.n = 1;
        datum.keys = &key;
        key.uuid = *chassis;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_chassis,
                          &datum);
}

/* Sets the "datapath" column from the "Port_Binding" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_datapath(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct uuid *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.uuid = *datapath;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_datapath,
                          &datum);
}

/* Sets the "encap" column from the "Port_Binding" table in 'row' to
 * the 'encap' set.
 *
 * If "encap" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_encap(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct uuid *encap)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (encap) {
        datum.n = 1;
        datum.keys = &key;
        key.uuid = *encap;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_encap,
                          &datum);
}

/* Sets the "external_ids" column's value from the "Port_Binding" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_port_binding_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_port_binding_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_port_binding_col_external_ids.type);
}


/* Sets the "gateway_chassis" column from the "Port_Binding" table in 'row' to
 * the 'gateway_chassis' set with 'n_gateway_chassis' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_gateway_chassis(struct ovsdb_idl_condition *cond, enum ovsdb_function function, struct uuid **gateway_chassis, size_t n_gateway_chassis)
{
    struct ovsdb_datum datum;
    datum.n = n_gateway_chassis;
    datum.keys = n_gateway_chassis ? xmalloc(n_gateway_chassis * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_gateway_chassis; i++) {
        datum.keys[i].uuid = *gateway_chassis[i];
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_gateway_chassis,
                          &datum);
    free(datum.keys);
}

/* Sets the "logical_port" column from the "Port_Binding" table in 'row' to
 * 'logical_port'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_logical_port(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *logical_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, logical_port);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_logical_port,
                          &datum);
}

/* Sets the "mac" column from the "Port_Binding" table in 'row' to
 * the 'mac' set with 'n_mac' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_mac(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char **mac, size_t n_mac)
{
    struct ovsdb_datum datum;
    datum.n = n_mac;
    datum.keys = n_mac ? xmalloc(n_mac * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_mac; i++) {
        datum.keys[i].string = CONST_CAST(char *, mac[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_mac,
                          &datum);
    free(datum.keys);
}

/* Sets the "nat_addresses" column from the "Port_Binding" table in 'row' to
 * the 'nat_addresses' set with 'n_nat_addresses' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_nat_addresses(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char **nat_addresses, size_t n_nat_addresses)
{
    struct ovsdb_datum datum;
    datum.n = n_nat_addresses;
    datum.keys = n_nat_addresses ? xmalloc(n_nat_addresses * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_nat_addresses; i++) {
        datum.keys[i].string = CONST_CAST(char *, nat_addresses[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_nat_addresses,
                          &datum);
    free(datum.keys);
}

/* Sets the "options" column's value from the "Port_Binding" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_port_binding_add_clause_options(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *options)
{
    struct ovsdb_datum datum;

    if (options) {
        ovsdb_datum_from_smap(&datum, options);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_port_binding_col_options,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_port_binding_col_options.type);
}


/* Sets the "parent_port" column from the "Port_Binding" table in 'row' to
 * the 'parent_port' set.
 *
 * If "parent_port" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_parent_port(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *parent_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (parent_port) {
        datum.n = 1;
        datum.keys = &key;
        key.string = CONST_CAST(char *, parent_port);
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_parent_port,
                          &datum);
}

/* Sets the "tag" column from the "Port_Binding" table in 'row' to
 * the 'tag' set with 'n_tag' entries.
 *
 * 'n_tag' may be 0 or 1; if it is 0, then 'tag'
 * may be NULL.
 *
 * Argument constraints: in range 1 to 4,095
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_tag(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const int64_t *tag, size_t n_tag)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (n_tag) {
        datum.n = 1;
        datum.keys = &key;
        key.integer = *tag;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_tag,
                          &datum);
}

/* Sets the "tunnel_key" column from the "Port_Binding" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 1 to 32,767
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_tunnel_key(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_tunnel_key,
                          &datum);
}

/* Sets the "type" column from the "Port_Binding" table in 'row' to
 * 'type'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_add_clause_type(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_binding_col_type,
                          &datum);
}

/* Destroy 'row' of kind "Port_Binding". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_port_binding_index_destroy_row(const struct sbrec_port_binding *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Port_Binding". */
struct sbrec_port_binding *
sbrec_port_binding_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_binding);
    return ALIGNED_CAST(struct sbrec_port_binding *, ovsdb_idl_index_init_row(index));
}

struct sbrec_port_binding *
sbrec_port_binding_index_find(struct ovsdb_idl_index *index, const struct sbrec_port_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_binding);
    return sbrec_port_binding_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_port_binding_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_port_binding *a, 
    const struct sbrec_port_binding *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_port_binding_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_binding);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_port_binding_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_port_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_binding);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_port_binding_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_port_binding *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_binding);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_port_binding *
sbrec_port_binding_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_port_binding_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "chassis" column from the "Port_Binding" table in 'row' to
 * the 'chassis' set.
 *
 * If "chassis" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_chassis(const struct sbrec_port_binding *row, const struct sbrec_chassis *chassis)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof (union ovsdb_atom));

    if (chassis) {
        datum.n = 1;
        datum.keys = key;
        key->uuid = chassis->header_.uuid;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_CHASSIS ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "datapath" column from the "Port_Binding" table in 'row' to
 * 'datapath'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_datapath(const struct sbrec_port_binding *row, const struct sbrec_datapath_binding *datapath)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->uuid = datapath->header_.uuid;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_DATAPATH ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "encap" column from the "Port_Binding" table in 'row' to
 * the 'encap' set.
 *
 * If "encap" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_encap(const struct sbrec_port_binding *row, const struct sbrec_encap *encap)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof (union ovsdb_atom));

    if (encap) {
        datum.n = 1;
        datum.keys = key;
        key->uuid = encap->header_.uuid;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_ENCAP ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "external_ids" column's value from the "Port_Binding" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_port_binding_index_set_external_ids(const struct sbrec_port_binding *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}


/* Sets the "gateway_chassis" column from the "Port_Binding" table in 'row' to
 * the 'gateway_chassis' set with 'n_gateway_chassis' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_gateway_chassis(const struct sbrec_port_binding *row, struct sbrec_gateway_chassis **gateway_chassis, size_t n_gateway_chassis)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_gateway_chassis;
    datum.keys = n_gateway_chassis ? xmalloc(n_gateway_chassis * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_gateway_chassis; i++) {
        datum.keys[i].uuid = gateway_chassis[i]->header_.uuid;
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_GATEWAY_CHASSIS ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "logical_port" column from the "Port_Binding" table in 'row' to
 * 'logical_port'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_logical_port(const struct sbrec_port_binding *row, const char *logical_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, logical_port);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_LOGICAL_PORT ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "mac" column from the "Port_Binding" table in 'row' to
 * the 'mac' set with 'n_mac' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_mac(const struct sbrec_port_binding *row, const char **mac, size_t n_mac)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_mac;
    datum.keys = n_mac ? xmalloc(n_mac * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_mac; i++) {
        datum.keys[i].string = xstrdup(mac[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_MAC ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "nat_addresses" column from the "Port_Binding" table in 'row' to
 * the 'nat_addresses' set with 'n_nat_addresses' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_nat_addresses(const struct sbrec_port_binding *row, const char **nat_addresses, size_t n_nat_addresses)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_nat_addresses;
    datum.keys = n_nat_addresses ? xmalloc(n_nat_addresses * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_nat_addresses; i++) {
        datum.keys[i].string = xstrdup(nat_addresses[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_NAT_ADDRESSES ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "options" column's value from the "Port_Binding" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_port_binding_index_set_options(const struct sbrec_port_binding *row, const struct smap *options)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (options) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(options);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, options) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_port_binding_columns[SBREC_PORT_BINDING_COL_OPTIONS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}


/* Sets the "parent_port" column from the "Port_Binding" table in 'row' to
 * the 'parent_port' set.
 *
 * If "parent_port" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_parent_port(const struct sbrec_port_binding *row, const char *parent_port)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof (union ovsdb_atom));

    if (parent_port) {
        datum.n = 1;
        datum.keys = key;
        key->string = CONST_CAST(char *, parent_port);
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_PARENT_PORT ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "tag" column from the "Port_Binding" table in 'row' to
 * the 'tag' set with 'n_tag' entries.
 *
 * 'n_tag' may be 0 or 1; if it is 0, then 'tag'
 * may be NULL.
 *
 * Argument constraints: in range 1 to 4,095
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_tag(const struct sbrec_port_binding *row, const int64_t *tag, size_t n_tag)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    if (n_tag) {
        datum.n = 1;
        datum.keys = key;
        key->integer = *tag;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_TAG ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "tunnel_key" column from the "Port_Binding" table in 'row' to
 * 'tunnel_key'.
 *
 * Argument constraints: in range 1 to 32,767
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_tunnel_key(const struct sbrec_port_binding *row, int64_t tunnel_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = tunnel_key;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_TUNNEL_KEY ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

/* Sets the "type" column from the "Port_Binding" table in 'row' to
 * 'type'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_binding_index_set_type(const struct sbrec_port_binding *row, const char *type)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, type);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_binding_columns[ SBREC_PORT_BINDING_COL_TYPE ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_BINDING]);
}

struct ovsdb_idl_column sbrec_port_binding_columns[SBREC_PORT_BINDING_N_COLUMNS];

void
sbrec_port_binding_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_port_binding, condition);
}

struct ovsdb_idl_column sbrec_port_binding_columns[SBREC_PORT_BINDING_N_COLUMNS] = {
    [SBREC_PORT_BINDING_COL_CHASSIS] = {
         .name = "chassis",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Chassis", .refType = OVSDB_REF_WEAK },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_chassis,
         .unparse = sbrec_port_binding_unparse_chassis,
    },

    [SBREC_PORT_BINDING_COL_DATAPATH] = {
         .name = "datapath",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Datapath_Binding", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_datapath,
         .unparse = sbrec_port_binding_unparse_datapath,
    },

    [SBREC_PORT_BINDING_COL_ENCAP] = {
         .name = "encap",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Encap", .refType = OVSDB_REF_WEAK },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_encap,
         .unparse = sbrec_port_binding_unparse_encap,
    },

    [SBREC_PORT_BINDING_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_external_ids,
         .unparse = sbrec_port_binding_unparse_external_ids,
    },

    [SBREC_PORT_BINDING_COL_GATEWAY_CHASSIS] = {
         .name = "gateway_chassis",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Gateway_Chassis", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_gateway_chassis,
         .unparse = sbrec_port_binding_unparse_gateway_chassis,
    },

    [SBREC_PORT_BINDING_COL_LOGICAL_PORT] = {
         .name = "logical_port",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_logical_port,
         .unparse = sbrec_port_binding_unparse_logical_port,
    },

    [SBREC_PORT_BINDING_COL_MAC] = {
         .name = "mac",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_mac,
         .unparse = sbrec_port_binding_unparse_mac,
    },

    [SBREC_PORT_BINDING_COL_NAT_ADDRESSES] = {
         .name = "nat_addresses",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_nat_addresses,
         .unparse = sbrec_port_binding_unparse_nat_addresses,
    },

    [SBREC_PORT_BINDING_COL_OPTIONS] = {
         .name = "options",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_options,
         .unparse = sbrec_port_binding_unparse_options,
    },

    [SBREC_PORT_BINDING_COL_PARENT_PORT] = {
         .name = "parent_port",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_parent_port,
         .unparse = sbrec_port_binding_unparse_parent_port,
    },

    [SBREC_PORT_BINDING_COL_TAG] = {
         .name = "tag",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(1), .max = INT64_C(4095) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_tag,
         .unparse = sbrec_port_binding_unparse_tag,
    },

    [SBREC_PORT_BINDING_COL_TUNNEL_KEY] = {
         .name = "tunnel_key",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_C(1), .max = INT64_C(32767) },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_tunnel_key,
         .unparse = sbrec_port_binding_unparse_tunnel_key,
    },

    [SBREC_PORT_BINDING_COL_TYPE] = {
         .name = "type",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_binding_parse_type,
         .unparse = sbrec_port_binding_unparse_type,
    },

};

/* Port_Group table. */

const struct sbrec_port_group_table *
sbrec_port_group_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_port_group_table *) idl;
}

const struct sbrec_port_group *
sbrec_port_group_table_first(const struct sbrec_port_group_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_port_group_first(idl);
}


const struct sbrec_port_group *
sbrec_port_group_table_track_get_first(const struct sbrec_port_group_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_port_group_track_get_first(idl);
}


static void
sbrec_port_group_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_group *row = sbrec_port_group_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_port_group_parse_ports(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_port_group *row = sbrec_port_group_cast(row_);
    row->ports = NULL;
    row->n_ports = 0;
    for (size_t i = 0; i < datum->n; i++) {
        if (!row->n_ports) {
            row->ports = xmalloc(datum->n * sizeof *row->ports);
        }
        row->ports[row->n_ports] = datum->keys[i].string;
        row->n_ports++;
    }
}

static void
sbrec_port_group_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_port_group_unparse_ports(struct ovsdb_idl_row *row_)
{
    struct sbrec_port_group *row = sbrec_port_group_cast(row_);
    free(row->ports);
}

static void
sbrec_port_group_init__(struct ovsdb_idl_row *row)
{
    sbrec_port_group_init(sbrec_port_group_cast(row));
}

/* Clears the contents of 'row' in table "Port_Group". */
void
sbrec_port_group_init(struct sbrec_port_group *row)
{
    memset(row, 0, sizeof *row); 
    row->name = "";
}

/* Searches table "Port_Group" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_port_group *
sbrec_port_group_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_port_group_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_port_group, uuid));
}

/* Searches table "Port_Group" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_port_group *
sbrec_port_group_table_get_for_uuid(const struct sbrec_port_group_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_port_group_get_for_uuid(idl, uuid);
}

/* Returns a row in table "Port_Group" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_port_group *
sbrec_port_group_first(const struct ovsdb_idl *idl)
{
    return sbrec_port_group_cast(ovsdb_idl_first_row(idl, &sbrec_table_port_group));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_port_group *
sbrec_port_group_next(const struct sbrec_port_group *row)
{
    return sbrec_port_group_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_port_group_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_port_group);
}

unsigned int sbrec_port_group_row_get_seqno(const struct sbrec_port_group *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_port_group *
sbrec_port_group_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_port_group_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_port_group));
}

const struct sbrec_port_group
*sbrec_port_group_track_get_next(const struct sbrec_port_group *row)
{
    return sbrec_port_group_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "Port_Group".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_group_delete(const struct sbrec_port_group *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "Port_Group" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_port_group *
sbrec_port_group_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_port_group_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_port_group, NULL));
}

bool
sbrec_port_group_is_updated(const struct sbrec_port_group *row, enum sbrec_port_group_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_port_group_columns[column]);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_group_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_port_group_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_group_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_group_verify_name(const struct sbrec_port_group *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_group_col_name);
}

/* Causes the original contents of column "ports" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ports" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ports" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ports" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_port_group_insert()).
 *
 *   - If "ports" has already been modified (with
 *     sbrec_port_group_set_ports()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_port_group_set_ports() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_port_group_verify_ports(const struct sbrec_port_group *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_port_group_col_ports);
}

/* Returns the "name" column's value from the "Port_Group" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_port_group. */
const struct ovsdb_datum *
sbrec_port_group_get_name(const struct sbrec_port_group *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_group_col_name);
}

/* Returns the "ports" column's value from the "Port_Group" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes ports's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ports" member in sbrec_port_group. */
const struct ovsdb_datum *
sbrec_port_group_get_ports(const struct sbrec_port_group *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_port_group_col_ports);
}

/* Sets the "name" column from the "Port_Group" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_group_set_name(const struct sbrec_port_group *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_port_group_col_name, &datum);
}

/* Sets the "ports" column from the "Port_Group" table in 'row' to
 * the 'ports' set with 'n_ports' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_group_set_ports(const struct sbrec_port_group *row, const char **ports, size_t n_ports)
{
    struct ovsdb_datum datum;

    datum.n = n_ports;
    datum.keys = n_ports ? xmalloc(n_ports * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_ports; i++) {
        datum.keys[i].string = xstrdup(ports[i]);
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_port_group_col_ports, &datum);
}

/* Adds the value 'new_value' to the "ports" set column from the "Port_Group" table
 * in 'row'.
 *
 */
void
sbrec_port_group_update_ports_addvalue(const struct sbrec_port_group *row, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_port_group_col_ports,
                                    datum);
}

/* Deletes the value 'delete_value' from the "ports" set column from the
 * "Port_Group" table in 'row'.
 *
 */
void
sbrec_port_group_update_ports_delvalue(const struct sbrec_port_group *row, const char *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_value);

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_port_group_col_ports,
                                    datum);
}

/* Sets the "name" column from the "Port_Group" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_group_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_group_col_name,
                          &datum);
}

/* Sets the "ports" column from the "Port_Group" table in 'row' to
 * the 'ports' set with 'n_ports' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_group_add_clause_ports(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char **ports, size_t n_ports)
{
    struct ovsdb_datum datum;
    datum.n = n_ports;
    datum.keys = n_ports ? xmalloc(n_ports * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_ports; i++) {
        datum.keys[i].string = CONST_CAST(char *, ports[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_port_group_col_ports,
                          &datum);
    free(datum.keys);
}

/* Destroy 'row' of kind "Port_Group". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_port_group_index_destroy_row(const struct sbrec_port_group *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "Port_Group". */
struct sbrec_port_group *
sbrec_port_group_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_group);
    return ALIGNED_CAST(struct sbrec_port_group *, ovsdb_idl_index_init_row(index));
}

struct sbrec_port_group *
sbrec_port_group_index_find(struct ovsdb_idl_index *index, const struct sbrec_port_group *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_group);
    return sbrec_port_group_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_port_group_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_port_group *a, 
    const struct sbrec_port_group *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_port_group_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_group);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_port_group_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_port_group *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_group);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_port_group_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_port_group *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_port_group);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_port_group *
sbrec_port_group_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_port_group_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "name" column from the "Port_Group" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_group_index_set_name(const struct sbrec_port_group *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_group_columns[ SBREC_PORT_GROUP_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_GROUP]);
}

/* Sets the "ports" column from the "Port_Group" table in 'row' to
 * the 'ports' set with 'n_ports' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_port_group_index_set_ports(const struct sbrec_port_group *row, const char **ports, size_t n_ports)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_ports;
    datum.keys = n_ports ? xmalloc(n_ports * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_ports; i++) {
        datum.keys[i].string = xstrdup(ports[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_port_group_columns[ SBREC_PORT_GROUP_COL_PORTS ], &datum, &sbrec_table_classes[SBREC_TABLE_PORT_GROUP]);
}

struct ovsdb_idl_column sbrec_port_group_columns[SBREC_PORT_GROUP_N_COLUMNS];

void
sbrec_port_group_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_port_group, condition);
}

struct ovsdb_idl_column sbrec_port_group_columns[SBREC_PORT_GROUP_N_COLUMNS] = {
    [SBREC_PORT_GROUP_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_group_parse_name,
         .unparse = sbrec_port_group_unparse_name,
    },

    [SBREC_PORT_GROUP_COL_PORTS] = {
         .name = "ports",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_port_group_parse_ports,
         .unparse = sbrec_port_group_unparse_ports,
    },

};

/* RBAC_Permission table. */

const struct sbrec_rbac_permission_table *
sbrec_rbac_permission_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_rbac_permission_table *) idl;
}

const struct sbrec_rbac_permission *
sbrec_rbac_permission_table_first(const struct sbrec_rbac_permission_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_rbac_permission_first(idl);
}


const struct sbrec_rbac_permission *
sbrec_rbac_permission_table_track_get_first(const struct sbrec_rbac_permission_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_rbac_permission_track_get_first(idl);
}


static void
sbrec_rbac_permission_parse_authorization(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_rbac_permission *row = sbrec_rbac_permission_cast(row_);
    row->authorization = NULL;
    row->n_authorization = 0;
    for (size_t i = 0; i < datum->n; i++) {
        if (!row->n_authorization) {
            row->authorization = xmalloc(datum->n * sizeof *row->authorization);
        }
        row->authorization[row->n_authorization] = datum->keys[i].string;
        row->n_authorization++;
    }
}

static void
sbrec_rbac_permission_parse_insert_delete(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_rbac_permission *row = sbrec_rbac_permission_cast(row_);

    if (datum->n >= 1) {
        row->insert_delete = datum->keys[0].boolean;
    } else {
        row->insert_delete = false;
    }
}

static void
sbrec_rbac_permission_parse_table(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_rbac_permission *row = sbrec_rbac_permission_cast(row_);

    if (datum->n >= 1) {
        row->table = datum->keys[0].string;
    } else {
        row->table = "";
    }
}

static void
sbrec_rbac_permission_parse_update(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_rbac_permission *row = sbrec_rbac_permission_cast(row_);
    row->update = NULL;
    row->n_update = 0;
    for (size_t i = 0; i < datum->n; i++) {
        if (!row->n_update) {
            row->update = xmalloc(datum->n * sizeof *row->update);
        }
        row->update[row->n_update] = datum->keys[i].string;
        row->n_update++;
    }
}

static void
sbrec_rbac_permission_unparse_authorization(struct ovsdb_idl_row *row_)
{
    struct sbrec_rbac_permission *row = sbrec_rbac_permission_cast(row_);
    free(row->authorization);
}

static void
sbrec_rbac_permission_unparse_insert_delete(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_rbac_permission_unparse_table(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_rbac_permission_unparse_update(struct ovsdb_idl_row *row_)
{
    struct sbrec_rbac_permission *row = sbrec_rbac_permission_cast(row_);
    free(row->update);
}

static void
sbrec_rbac_permission_init__(struct ovsdb_idl_row *row)
{
    sbrec_rbac_permission_init(sbrec_rbac_permission_cast(row));
}

/* Clears the contents of 'row' in table "RBAC_Permission". */
void
sbrec_rbac_permission_init(struct sbrec_rbac_permission *row)
{
    memset(row, 0, sizeof *row); 
    row->table = "";
}

/* Searches table "RBAC_Permission" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_rbac_permission *
sbrec_rbac_permission_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_rbac_permission_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_rbac_permission, uuid));
}

/* Searches table "RBAC_Permission" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_rbac_permission *
sbrec_rbac_permission_table_get_for_uuid(const struct sbrec_rbac_permission_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_rbac_permission_get_for_uuid(idl, uuid);
}

/* Returns a row in table "RBAC_Permission" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_rbac_permission *
sbrec_rbac_permission_first(const struct ovsdb_idl *idl)
{
    return sbrec_rbac_permission_cast(ovsdb_idl_first_row(idl, &sbrec_table_rbac_permission));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_rbac_permission *
sbrec_rbac_permission_next(const struct sbrec_rbac_permission *row)
{
    return sbrec_rbac_permission_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_rbac_permission_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_rbac_permission);
}

unsigned int sbrec_rbac_permission_row_get_seqno(const struct sbrec_rbac_permission *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_rbac_permission *
sbrec_rbac_permission_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_rbac_permission_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_rbac_permission));
}

const struct sbrec_rbac_permission
*sbrec_rbac_permission_track_get_next(const struct sbrec_rbac_permission *row)
{
    return sbrec_rbac_permission_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "RBAC_Permission".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_rbac_permission_delete(const struct sbrec_rbac_permission *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "RBAC_Permission" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_rbac_permission *
sbrec_rbac_permission_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_rbac_permission_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_rbac_permission, NULL));
}

bool
sbrec_rbac_permission_is_updated(const struct sbrec_rbac_permission *row, enum sbrec_rbac_permission_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_rbac_permission_columns[column]);
}

/* Causes the original contents of column "authorization" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "authorization" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "authorization" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "authorization" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_rbac_permission_insert()).
 *
 *   - If "authorization" has already been modified (with
 *     sbrec_rbac_permission_set_authorization()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_rbac_permission_set_authorization() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_rbac_permission_verify_authorization(const struct sbrec_rbac_permission *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_rbac_permission_col_authorization);
}

/* Causes the original contents of column "insert_delete" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "insert_delete" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "insert_delete" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "insert_delete" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_rbac_permission_insert()).
 *
 *   - If "insert_delete" has already been modified (with
 *     sbrec_rbac_permission_set_insert_delete()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_rbac_permission_set_insert_delete() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_rbac_permission_verify_insert_delete(const struct sbrec_rbac_permission *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_rbac_permission_col_insert_delete);
}

/* Causes the original contents of column "table" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "table" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "table" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "table" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_rbac_permission_insert()).
 *
 *   - If "table" has already been modified (with
 *     sbrec_rbac_permission_set_table()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_rbac_permission_set_table() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_rbac_permission_verify_table(const struct sbrec_rbac_permission *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_rbac_permission_col_table);
}

/* Causes the original contents of column "update" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "update" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "update" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "update" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_rbac_permission_insert()).
 *
 *   - If "update" has already been modified (with
 *     sbrec_rbac_permission_set_update()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_rbac_permission_set_update() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_rbac_permission_verify_update(const struct sbrec_rbac_permission *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_rbac_permission_col_update);
}

/* Returns the "authorization" column's value from the "RBAC_Permission" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes authorization's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "authorization" member in sbrec_rbac_permission. */
const struct ovsdb_datum *
sbrec_rbac_permission_get_authorization(const struct sbrec_rbac_permission *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_rbac_permission_col_authorization);
}

/* Returns the "insert_delete" column's value from the "RBAC_Permission" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_BOOLEAN.
 * (This helps to avoid silent bugs if someone changes insert_delete's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "insert_delete" member in sbrec_rbac_permission. */
const struct ovsdb_datum *
sbrec_rbac_permission_get_insert_delete(const struct sbrec_rbac_permission *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_BOOLEAN);
    return ovsdb_idl_read(&row->header_, &sbrec_rbac_permission_col_insert_delete);
}

/* Returns the "table" column's value from the "RBAC_Permission" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes table's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "table" member in sbrec_rbac_permission. */
const struct ovsdb_datum *
sbrec_rbac_permission_get_table(const struct sbrec_rbac_permission *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_rbac_permission_col_table);
}

/* Returns the "update" column's value from the "RBAC_Permission" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes update's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "update" member in sbrec_rbac_permission. */
const struct ovsdb_datum *
sbrec_rbac_permission_get_update(const struct sbrec_rbac_permission *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_rbac_permission_col_update);
}

/* Sets the "authorization" column from the "RBAC_Permission" table in 'row' to
 * the 'authorization' set with 'n_authorization' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_set_authorization(const struct sbrec_rbac_permission *row, const char **authorization, size_t n_authorization)
{
    struct ovsdb_datum datum;

    datum.n = n_authorization;
    datum.keys = n_authorization ? xmalloc(n_authorization * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_authorization; i++) {
        datum.keys[i].string = xstrdup(authorization[i]);
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_rbac_permission_col_authorization, &datum);
}

/* Sets the "insert_delete" column from the "RBAC_Permission" table in 'row' to
 * 'insert_delete'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_set_insert_delete(const struct sbrec_rbac_permission *row, bool insert_delete)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = insert_delete;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_rbac_permission_col_insert_delete, &datum);
}

/* Sets the "table" column from the "RBAC_Permission" table in 'row' to
 * 'table'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_set_table(const struct sbrec_rbac_permission *row, const char *table)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, table);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_rbac_permission_col_table, &datum);
}

/* Sets the "update" column from the "RBAC_Permission" table in 'row' to
 * the 'update' set with 'n_update' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_set_update(const struct sbrec_rbac_permission *row, const char **update, size_t n_update)
{
    struct ovsdb_datum datum;

    datum.n = n_update;
    datum.keys = n_update ? xmalloc(n_update * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_update; i++) {
        datum.keys[i].string = xstrdup(update[i]);
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_rbac_permission_col_update, &datum);
}

/* Adds the value 'new_value' to the "authorization" set column from the "RBAC_Permission" table
 * in 'row'.
 *
 */
void
sbrec_rbac_permission_update_authorization_addvalue(const struct sbrec_rbac_permission *row, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_rbac_permission_col_authorization,
                                    datum);
}

/* Deletes the value 'delete_value' from the "authorization" set column from the
 * "RBAC_Permission" table in 'row'.
 *
 */
void
sbrec_rbac_permission_update_authorization_delvalue(const struct sbrec_rbac_permission *row, const char *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_value);

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_rbac_permission_col_authorization,
                                    datum);
}

/* Adds the value 'new_value' to the "update" set column from the "RBAC_Permission" table
 * in 'row'.
 *
 */
void
sbrec_rbac_permission_update_update_addvalue(const struct sbrec_rbac_permission *row, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_rbac_permission_col_update,
                                    datum);
}

/* Deletes the value 'delete_value' from the "update" set column from the
 * "RBAC_Permission" table in 'row'.
 *
 */
void
sbrec_rbac_permission_update_update_delvalue(const struct sbrec_rbac_permission *row, const char *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_value);

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_rbac_permission_col_update,
                                    datum);
}

/* Sets the "authorization" column from the "RBAC_Permission" table in 'row' to
 * the 'authorization' set with 'n_authorization' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_add_clause_authorization(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char **authorization, size_t n_authorization)
{
    struct ovsdb_datum datum;
    datum.n = n_authorization;
    datum.keys = n_authorization ? xmalloc(n_authorization * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_authorization; i++) {
        datum.keys[i].string = CONST_CAST(char *, authorization[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_rbac_permission_col_authorization,
                          &datum);
    free(datum.keys);
}

/* Sets the "insert_delete" column from the "RBAC_Permission" table in 'row' to
 * 'insert_delete'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_add_clause_insert_delete(struct ovsdb_idl_condition *cond, enum ovsdb_function function, bool insert_delete)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = insert_delete;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_rbac_permission_col_insert_delete,
                          &datum);
}

/* Sets the "table" column from the "RBAC_Permission" table in 'row' to
 * 'table'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_add_clause_table(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *table)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, table);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_rbac_permission_col_table,
                          &datum);
}

/* Sets the "update" column from the "RBAC_Permission" table in 'row' to
 * the 'update' set with 'n_update' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_add_clause_update(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char **update, size_t n_update)
{
    struct ovsdb_datum datum;
    datum.n = n_update;
    datum.keys = n_update ? xmalloc(n_update * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_update; i++) {
        datum.keys[i].string = CONST_CAST(char *, update[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_rbac_permission_col_update,
                          &datum);
    free(datum.keys);
}

/* Destroy 'row' of kind "RBAC_Permission". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_rbac_permission_index_destroy_row(const struct sbrec_rbac_permission *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "RBAC_Permission". */
struct sbrec_rbac_permission *
sbrec_rbac_permission_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_permission);
    return ALIGNED_CAST(struct sbrec_rbac_permission *, ovsdb_idl_index_init_row(index));
}

struct sbrec_rbac_permission *
sbrec_rbac_permission_index_find(struct ovsdb_idl_index *index, const struct sbrec_rbac_permission *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_permission);
    return sbrec_rbac_permission_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_rbac_permission_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_rbac_permission *a, 
    const struct sbrec_rbac_permission *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_rbac_permission_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_permission);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_rbac_permission_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_rbac_permission *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_permission);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_rbac_permission_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_rbac_permission *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_permission);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_rbac_permission *
sbrec_rbac_permission_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_rbac_permission_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "authorization" column from the "RBAC_Permission" table in 'row' to
 * the 'authorization' set with 'n_authorization' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_index_set_authorization(const struct sbrec_rbac_permission *row, const char **authorization, size_t n_authorization)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_authorization;
    datum.keys = n_authorization ? xmalloc(n_authorization * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_authorization; i++) {
        datum.keys[i].string = xstrdup(authorization[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_rbac_permission_columns[ SBREC_RBAC_PERMISSION_COL_AUTHORIZATION ], &datum, &sbrec_table_classes[SBREC_TABLE_RBAC_PERMISSION]);
}

/* Sets the "insert_delete" column from the "RBAC_Permission" table in 'row' to
 * 'insert_delete'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_index_set_insert_delete(const struct sbrec_rbac_permission *row, bool insert_delete)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->boolean = insert_delete;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_rbac_permission_columns[ SBREC_RBAC_PERMISSION_COL_INSERT_DELETE ], &datum, &sbrec_table_classes[SBREC_TABLE_RBAC_PERMISSION]);
}

/* Sets the "table" column from the "RBAC_Permission" table in 'row' to
 * 'table'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_index_set_table(const struct sbrec_rbac_permission *row, const char *table)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, table);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_rbac_permission_columns[ SBREC_RBAC_PERMISSION_COL_TABLE ], &datum, &sbrec_table_classes[SBREC_TABLE_RBAC_PERMISSION]);
}

/* Sets the "update" column from the "RBAC_Permission" table in 'row' to
 * the 'update' set with 'n_update' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_permission_index_set_update(const struct sbrec_rbac_permission *row, const char **update, size_t n_update)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_update;
    datum.keys = n_update ? xmalloc(n_update * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_update; i++) {
        datum.keys[i].string = xstrdup(update[i]);
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_rbac_permission_columns[ SBREC_RBAC_PERMISSION_COL_UPDATE ], &datum, &sbrec_table_classes[SBREC_TABLE_RBAC_PERMISSION]);
}

struct ovsdb_idl_column sbrec_rbac_permission_columns[SBREC_RBAC_PERMISSION_N_COLUMNS];

void
sbrec_rbac_permission_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_rbac_permission, condition);
}

struct ovsdb_idl_column sbrec_rbac_permission_columns[SBREC_RBAC_PERMISSION_N_COLUMNS] = {
    [SBREC_RBAC_PERMISSION_COL_AUTHORIZATION] = {
         .name = "authorization",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_rbac_permission_parse_authorization,
         .unparse = sbrec_rbac_permission_unparse_authorization,
    },

    [SBREC_RBAC_PERMISSION_COL_INSERT_DELETE] = {
         .name = "insert_delete",
         .type = {
            .key = {
               .type = OVSDB_TYPE_BOOLEAN,
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_rbac_permission_parse_insert_delete,
         .unparse = sbrec_rbac_permission_unparse_insert_delete,
    },

    [SBREC_RBAC_PERMISSION_COL_TABLE] = {
         .name = "table",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_rbac_permission_parse_table,
         .unparse = sbrec_rbac_permission_unparse_table,
    },

    [SBREC_RBAC_PERMISSION_COL_UPDATE] = {
         .name = "update",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_rbac_permission_parse_update,
         .unparse = sbrec_rbac_permission_unparse_update,
    },

};

/* RBAC_Role table. */

const struct sbrec_rbac_role_table *
sbrec_rbac_role_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_rbac_role_table *) idl;
}

const struct sbrec_rbac_role *
sbrec_rbac_role_table_first(const struct sbrec_rbac_role_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_rbac_role_first(idl);
}


const struct sbrec_rbac_role *
sbrec_rbac_role_table_track_get_first(const struct sbrec_rbac_role_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_rbac_role_track_get_first(idl);
}


static void
sbrec_rbac_role_parse_name(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_rbac_role *row = sbrec_rbac_role_cast(row_);

    if (datum->n >= 1) {
        row->name = datum->keys[0].string;
    } else {
        row->name = "";
    }
}

static void
sbrec_rbac_role_parse_permissions(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_rbac_role *row = sbrec_rbac_role_cast(row_);
    row->key_permissions = NULL;
    row->value_permissions = NULL;
    row->n_permissions = 0;
    for (size_t i = 0; i < datum->n; i++) {
        struct sbrec_rbac_permission *valueRow = sbrec_rbac_permission_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_rbac_permission, &datum->values[i].uuid));
        if (!valueRow) {
            continue;
        }
        if (!row->n_permissions) {
            row->key_permissions = xmalloc(datum->n * sizeof *row->key_permissions);
            row->value_permissions = xmalloc(datum->n * sizeof *row->value_permissions);
        }
        row->key_permissions[row->n_permissions] = datum->keys[i].string;
        row->value_permissions[row->n_permissions] = valueRow;
        row->n_permissions++;
    }
}

static void
sbrec_rbac_role_unparse_name(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_rbac_role_unparse_permissions(struct ovsdb_idl_row *row_)
{
    struct sbrec_rbac_role *row = sbrec_rbac_role_cast(row_);
    free(row->key_permissions);
    free(row->value_permissions);
}

static void
sbrec_rbac_role_init__(struct ovsdb_idl_row *row)
{
    sbrec_rbac_role_init(sbrec_rbac_role_cast(row));
}

/* Clears the contents of 'row' in table "RBAC_Role". */
void
sbrec_rbac_role_init(struct sbrec_rbac_role *row)
{
    memset(row, 0, sizeof *row); 
    row->name = "";
}

/* Searches table "RBAC_Role" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_rbac_role *
sbrec_rbac_role_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_rbac_role_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_rbac_role, uuid));
}

/* Searches table "RBAC_Role" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_rbac_role *
sbrec_rbac_role_table_get_for_uuid(const struct sbrec_rbac_role_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_rbac_role_get_for_uuid(idl, uuid);
}

/* Returns a row in table "RBAC_Role" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_rbac_role *
sbrec_rbac_role_first(const struct ovsdb_idl *idl)
{
    return sbrec_rbac_role_cast(ovsdb_idl_first_row(idl, &sbrec_table_rbac_role));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_rbac_role *
sbrec_rbac_role_next(const struct sbrec_rbac_role *row)
{
    return sbrec_rbac_role_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_rbac_role_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_rbac_role);
}

unsigned int sbrec_rbac_role_row_get_seqno(const struct sbrec_rbac_role *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_rbac_role *
sbrec_rbac_role_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_rbac_role_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_rbac_role));
}

const struct sbrec_rbac_role
*sbrec_rbac_role_track_get_next(const struct sbrec_rbac_role *row)
{
    return sbrec_rbac_role_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "RBAC_Role".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_rbac_role_delete(const struct sbrec_rbac_role *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "RBAC_Role" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_rbac_role *
sbrec_rbac_role_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_rbac_role_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_rbac_role, NULL));
}

bool
sbrec_rbac_role_is_updated(const struct sbrec_rbac_role *row, enum sbrec_rbac_role_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_rbac_role_columns[column]);
}

/* Causes the original contents of column "name" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "name" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "name" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "name" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_rbac_role_insert()).
 *
 *   - If "name" has already been modified (with
 *     sbrec_rbac_role_set_name()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_rbac_role_set_name() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_rbac_role_verify_name(const struct sbrec_rbac_role *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_rbac_role_col_name);
}

/* Causes the original contents of column "permissions" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "permissions" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "permissions" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "permissions" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_rbac_role_insert()).
 *
 *   - If "permissions" has already been modified (with
 *     sbrec_rbac_role_set_permissions()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_rbac_role_set_permissions() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_rbac_role_verify_permissions(const struct sbrec_rbac_role *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_rbac_role_col_permissions);
}

/* Returns the "name" column's value from the "RBAC_Role" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes name's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "name" member in sbrec_rbac_role. */
const struct ovsdb_datum *
sbrec_rbac_role_get_name(const struct sbrec_rbac_role *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_rbac_role_col_name);
}

/* Returns the "permissions" column's value from the "RBAC_Role" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes permissions's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "permissions" member in sbrec_rbac_role. */
const struct ovsdb_datum *
sbrec_rbac_role_get_permissions(const struct sbrec_rbac_role *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_rbac_role_col_permissions);
}

/* Sets the "name" column from the "RBAC_Role" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_role_set_name(const struct sbrec_rbac_role *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_rbac_role_col_name, &datum);
}

/* Sets the "permissions" column from the "RBAC_Role" table in 'row' to
 * the map with keys 'key_permissions' and values 'value_permissions'
 * with 'n_permissions' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_role_set_permissions(const struct sbrec_rbac_role *row, const char **key_permissions, struct sbrec_rbac_permission **value_permissions, size_t n_permissions)
{
    struct ovsdb_datum datum;

    datum.n = n_permissions;
    datum.keys = n_permissions ? xmalloc(n_permissions * sizeof *datum.keys) : NULL;
    datum.values = xmalloc(n_permissions * sizeof *datum.values);
    for (size_t i = 0; i < n_permissions; i++) {
        datum.keys[i].string = xstrdup(key_permissions[i]);
        datum.values[i].uuid = value_permissions[i]->header_.uuid;
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_rbac_role_col_permissions, &datum);
}

/* Sets an element of the "permissions" map column from the "RBAC_Role" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_rbac_role_update_permissions_setkey(const struct sbrec_rbac_role *row, const char *new_key, const struct sbrec_rbac_permission *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_rbac_role_col_permissions,
                                    datum);
}

/* Deletes an element of the "permissions" map column from the "RBAC_Role" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_rbac_role_update_permissions_delkey(const struct sbrec_rbac_role *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_rbac_role_col_permissions,
                                    datum);
}

/* Sets the "name" column from the "RBAC_Role" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_role_add_clause_name(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_rbac_role_col_name,
                          &datum);
}

/* Sets the "permissions" column from the "RBAC_Role" table in 'row' to
 * the map with keys 'key_permissions' and values 'value_permissions'
 * with 'n_permissions' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_role_add_clause_permissions(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char **key_permissions, struct uuid **value_permissions, size_t n_permissions)
{
    struct ovsdb_datum datum;
    datum.n = n_permissions;
    datum.keys = n_permissions ? xmalloc(n_permissions * sizeof *datum.keys) : NULL;
    datum.values = xmalloc(n_permissions * sizeof *datum.values);
    for (size_t i = 0; i < n_permissions; i++) {
        datum.keys[i].string = CONST_CAST(char *, key_permissions[i]);
        datum.values[i].uuid = *value_permissions[i];
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_UUID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_rbac_role_col_permissions,
                          &datum);
    free(datum.keys);
    free(datum.values);
}

/* Destroy 'row' of kind "RBAC_Role". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_rbac_role_index_destroy_row(const struct sbrec_rbac_role *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "RBAC_Role". */
struct sbrec_rbac_role *
sbrec_rbac_role_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_role);
    return ALIGNED_CAST(struct sbrec_rbac_role *, ovsdb_idl_index_init_row(index));
}

struct sbrec_rbac_role *
sbrec_rbac_role_index_find(struct ovsdb_idl_index *index, const struct sbrec_rbac_role *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_role);
    return sbrec_rbac_role_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_rbac_role_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_rbac_role *a, 
    const struct sbrec_rbac_role *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_rbac_role_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_role);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_rbac_role_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_rbac_role *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_role);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_rbac_role_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_rbac_role *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_rbac_role);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_rbac_role *
sbrec_rbac_role_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_rbac_role_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "name" column from the "RBAC_Role" table in 'row' to
 * 'name'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_role_index_set_name(const struct sbrec_rbac_role *row, const char *name)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, name);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_rbac_role_columns[ SBREC_RBAC_ROLE_COL_NAME ], &datum, &sbrec_table_classes[SBREC_TABLE_RBAC_ROLE]);
}

/* Sets the "permissions" column from the "RBAC_Role" table in 'row' to
 * the map with keys 'key_permissions' and values 'value_permissions'
 * with 'n_permissions' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_rbac_role_index_set_permissions(const struct sbrec_rbac_role *row, const char **key_permissions, struct sbrec_rbac_permission **value_permissions, size_t n_permissions)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_permissions;
    datum.keys = n_permissions ? xmalloc(n_permissions * sizeof *datum.keys) : NULL;
    datum.values = xmalloc(n_permissions * sizeof *datum.values);
    for (i = 0; i < n_permissions; i++) {
        datum.keys[i].string = xstrdup(key_permissions[i]);
        datum.values[i].uuid = value_permissions[i]->header_.uuid;
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_STRING, OVSDB_TYPE_UUID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_rbac_role_columns[ SBREC_RBAC_ROLE_COL_PERMISSIONS ], &datum, &sbrec_table_classes[SBREC_TABLE_RBAC_ROLE]);
}

struct ovsdb_idl_column sbrec_rbac_role_columns[SBREC_RBAC_ROLE_N_COLUMNS];

void
sbrec_rbac_role_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_rbac_role, condition);
}

struct ovsdb_idl_column sbrec_rbac_role_columns[SBREC_RBAC_ROLE_N_COLUMNS] = {
    [SBREC_RBAC_ROLE_COL_NAME] = {
         .name = "name",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_rbac_role_parse_name,
         .unparse = sbrec_rbac_role_unparse_name,
    },

    [SBREC_RBAC_ROLE_COL_PERMISSIONS] = {
         .name = "permissions",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_UUID,
                .uuid = { .refTableName = "RBAC_Permission", .refType = OVSDB_REF_WEAK },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_rbac_role_parse_permissions,
         .unparse = sbrec_rbac_role_unparse_permissions,
    },

};

/* SB_Global table. */

const struct sbrec_sb_global_table *
sbrec_sb_global_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_sb_global_table *) idl;
}

const struct sbrec_sb_global *
sbrec_sb_global_table_first(const struct sbrec_sb_global_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_sb_global_first(idl);
}


const struct sbrec_sb_global *
sbrec_sb_global_table_track_get_first(const struct sbrec_sb_global_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_sb_global_track_get_first(idl);
}


static void
sbrec_sb_global_parse_connections(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);
    row->connections = NULL;
    row->n_connections = 0;
    for (size_t i = 0; i < datum->n; i++) {
        struct sbrec_connection *keyRow = sbrec_connection_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_connection, &datum->keys[i].uuid));
        if (!keyRow) {
            continue;
        }
        if (!row->n_connections) {
            row->connections = xmalloc(datum->n * sizeof *row->connections);
        }
        row->connections[row->n_connections] = keyRow;
        row->n_connections++;
    }
}

static void
sbrec_sb_global_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_sb_global_parse_ipsec(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);

    if (datum->n >= 1) {
        row->ipsec = datum->keys[0].boolean;
    } else {
        row->ipsec = false;
    }
}

static void
sbrec_sb_global_parse_nb_cfg(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);

    if (datum->n >= 1) {
        row->nb_cfg = datum->keys[0].integer;
    } else {
        row->nb_cfg = 0;
    }
}

static void
sbrec_sb_global_parse_options(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);
    smap_init(&row->options);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->options,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_sb_global_parse_ssl(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);

    if (datum->n >= 1) {
        row->ssl = sbrec_ssl_cast(ovsdb_idl_get_row_arc(row_, &sbrec_table_ssl, &datum->keys[0].uuid));
    } else {
        row->ssl = NULL;
    }
}

static void
sbrec_sb_global_unparse_connections(struct ovsdb_idl_row *row_)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);
    free(row->connections);
}

static void
sbrec_sb_global_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_sb_global_unparse_ipsec(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_sb_global_unparse_nb_cfg(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_sb_global_unparse_options(struct ovsdb_idl_row *row_)
{
    struct sbrec_sb_global *row = sbrec_sb_global_cast(row_);
    smap_destroy(&row->options);
}

static void
sbrec_sb_global_unparse_ssl(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_sb_global_init__(struct ovsdb_idl_row *row)
{
    sbrec_sb_global_init(sbrec_sb_global_cast(row));
}

/* Clears the contents of 'row' in table "SB_Global". */
void
sbrec_sb_global_init(struct sbrec_sb_global *row)
{
    memset(row, 0, sizeof *row); 
    smap_init(&row->external_ids);
    smap_init(&row->options);
}

/* Searches table "SB_Global" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_sb_global *
sbrec_sb_global_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_sb_global_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_sb_global, uuid));
}

/* Searches table "SB_Global" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_sb_global *
sbrec_sb_global_table_get_for_uuid(const struct sbrec_sb_global_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_sb_global_get_for_uuid(idl, uuid);
}

/* Returns a row in table "SB_Global" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_sb_global *
sbrec_sb_global_first(const struct ovsdb_idl *idl)
{
    return sbrec_sb_global_cast(ovsdb_idl_first_row(idl, &sbrec_table_sb_global));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_sb_global *
sbrec_sb_global_next(const struct sbrec_sb_global *row)
{
    return sbrec_sb_global_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_sb_global_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_sb_global);
}

unsigned int sbrec_sb_global_row_get_seqno(const struct sbrec_sb_global *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_sb_global *
sbrec_sb_global_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_sb_global_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_sb_global));
}

const struct sbrec_sb_global
*sbrec_sb_global_track_get_next(const struct sbrec_sb_global *row)
{
    return sbrec_sb_global_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "SB_Global".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_sb_global_delete(const struct sbrec_sb_global *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "SB_Global" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_sb_global *
sbrec_sb_global_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_sb_global_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_sb_global, NULL));
}

bool
sbrec_sb_global_is_updated(const struct sbrec_sb_global *row, enum sbrec_sb_global_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_sb_global_columns[column]);
}

/* Causes the original contents of column "connections" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "connections" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "connections" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "connections" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_sb_global_insert()).
 *
 *   - If "connections" has already been modified (with
 *     sbrec_sb_global_set_connections()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_sb_global_set_connections() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_sb_global_verify_connections(const struct sbrec_sb_global *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_sb_global_col_connections);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_sb_global_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_sb_global_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_sb_global_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_sb_global_verify_external_ids(const struct sbrec_sb_global *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_sb_global_col_external_ids);
}

/* Causes the original contents of column "ipsec" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ipsec" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ipsec" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ipsec" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_sb_global_insert()).
 *
 *   - If "ipsec" has already been modified (with
 *     sbrec_sb_global_set_ipsec()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_sb_global_set_ipsec() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_sb_global_verify_ipsec(const struct sbrec_sb_global *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_sb_global_col_ipsec);
}

/* Causes the original contents of column "nb_cfg" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "nb_cfg" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "nb_cfg" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "nb_cfg" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_sb_global_insert()).
 *
 *   - If "nb_cfg" has already been modified (with
 *     sbrec_sb_global_set_nb_cfg()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_sb_global_set_nb_cfg() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_sb_global_verify_nb_cfg(const struct sbrec_sb_global *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_sb_global_col_nb_cfg);
}

/* Causes the original contents of column "options" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "options" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "options" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "options" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_sb_global_insert()).
 *
 *   - If "options" has already been modified (with
 *     sbrec_sb_global_set_options()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_sb_global_set_options() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_sb_global_verify_options(const struct sbrec_sb_global *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_sb_global_col_options);
}

/* Causes the original contents of column "ssl" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ssl" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ssl" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ssl" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_sb_global_insert()).
 *
 *   - If "ssl" has already been modified (with
 *     sbrec_sb_global_set_ssl()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_sb_global_set_ssl() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_sb_global_verify_ssl(const struct sbrec_sb_global *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_sb_global_col_ssl);
}

/* Returns the "connections" column's value from the "SB_Global" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes connections's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "connections" member in sbrec_sb_global. */
const struct ovsdb_datum *
sbrec_sb_global_get_connections(const struct sbrec_sb_global *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_sb_global_col_connections);
}

/* Returns the "external_ids" column's value from the "SB_Global" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_sb_global. */
const struct ovsdb_datum *
sbrec_sb_global_get_external_ids(const struct sbrec_sb_global *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_sb_global_col_external_ids);
}

/* Returns the "ipsec" column's value from the "SB_Global" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_BOOLEAN.
 * (This helps to avoid silent bugs if someone changes ipsec's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ipsec" member in sbrec_sb_global. */
const struct ovsdb_datum *
sbrec_sb_global_get_ipsec(const struct sbrec_sb_global *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_BOOLEAN);
    return ovsdb_idl_read(&row->header_, &sbrec_sb_global_col_ipsec);
}

/* Returns the "nb_cfg" column's value from the "SB_Global" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_INTEGER.
 * (This helps to avoid silent bugs if someone changes nb_cfg's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "nb_cfg" member in sbrec_sb_global. */
const struct ovsdb_datum *
sbrec_sb_global_get_nb_cfg(const struct sbrec_sb_global *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_INTEGER);
    return ovsdb_idl_read(&row->header_, &sbrec_sb_global_col_nb_cfg);
}

/* Returns the "options" column's value from the "SB_Global" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes options's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "options" member in sbrec_sb_global. */
const struct ovsdb_datum *
sbrec_sb_global_get_options(const struct sbrec_sb_global *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_sb_global_col_options);
}

/* Returns the "ssl" column's value from the "SB_Global" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_UUID.
 * (This helps to avoid silent bugs if someone changes ssl's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ssl" member in sbrec_sb_global. */
const struct ovsdb_datum *
sbrec_sb_global_get_ssl(const struct sbrec_sb_global *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_UUID);
    return ovsdb_idl_read(&row->header_, &sbrec_sb_global_col_ssl);
}

/* Sets the "connections" column from the "SB_Global" table in 'row' to
 * the 'connections' set with 'n_connections' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_set_connections(const struct sbrec_sb_global *row, struct sbrec_connection **connections, size_t n_connections)
{
    struct ovsdb_datum datum;

    datum.n = n_connections;
    datum.keys = n_connections ? xmalloc(n_connections * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_connections; i++) {
        datum.keys[i].uuid = connections[i]->header_.uuid;
    }
    ovsdb_idl_txn_write(&row->header_, &sbrec_sb_global_col_connections, &datum);
}

/* Sets the "external_ids" column's value from the "SB_Global" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_sb_global_set_external_ids(const struct sbrec_sb_global *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_sb_global_col_external_ids,
                        &datum);
}


/* Sets the "ipsec" column from the "SB_Global" table in 'row' to
 * 'ipsec'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_set_ipsec(const struct sbrec_sb_global *row, bool ipsec)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = ipsec;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_sb_global_col_ipsec, &datum);
}

/* Sets the "nb_cfg" column from the "SB_Global" table in 'row' to
 * 'nb_cfg'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_set_nb_cfg(const struct sbrec_sb_global *row, int64_t nb_cfg)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = nb_cfg;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_sb_global_col_nb_cfg, &datum);
}

/* Sets the "options" column's value from the "SB_Global" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_sb_global_set_options(const struct sbrec_sb_global *row, const struct smap *options)
{
    struct ovsdb_datum datum;

    if (options) {
        ovsdb_datum_from_smap(&datum, options);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_sb_global_col_options,
                        &datum);
}


/* Sets the "ssl" column from the "SB_Global" table in 'row' to
 * the 'ssl' set.
 *
 * If "ssl" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_set_ssl(const struct sbrec_sb_global *row, const struct sbrec_ssl *ssl)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (ssl) {
        datum.n = 1;
        datum.keys = &key;
        key.uuid = ssl->header_.uuid;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_sb_global_col_ssl, &datum);
}

/* Adds the value 'new_value' to the "connections" set column from the "SB_Global" table
 * in 'row'.
 *
 */
void
sbrec_sb_global_update_connections_addvalue(const struct sbrec_sb_global *row, const struct sbrec_connection *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_sb_global_col_connections,
                                    datum);
}

/* Deletes the value 'delete_value' from the "connections" set column from the
 * "SB_Global" table in 'row'.
 *
 */
void
sbrec_sb_global_update_connections_delvalue(const struct sbrec_sb_global *row, const struct sbrec_connection *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_sb_global_col_connections,
                                    datum);
}

/* Sets an element of the "external_ids" map column from the "SB_Global" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_sb_global_update_external_ids_setkey(const struct sbrec_sb_global *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_sb_global_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "SB_Global" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_sb_global_update_external_ids_delkey(const struct sbrec_sb_global *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_sb_global_col_external_ids,
                                    datum);
}

/* Sets an element of the "options" map column from the "SB_Global" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_sb_global_update_options_setkey(const struct sbrec_sb_global *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_sb_global_col_options,
                                    datum);
}

/* Deletes an element of the "options" map column from the "SB_Global" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_sb_global_update_options_delkey(const struct sbrec_sb_global *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_sb_global_col_options,
                                    datum);
}

/* Adds the value 'new_value' to the "ssl" set column from the "SB_Global" table
 * in 'row'.
 *
 */
void
sbrec_sb_global_update_ssl_addvalue(const struct sbrec_sb_global *row, const struct sbrec_ssl *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = new_value->header_.uuid;

    ovsdb_idl_txn_write_partial_set(&row->header_,
                                    &sbrec_sb_global_col_ssl,
                                    datum);
}

/* Deletes the value 'delete_value' from the "ssl" set column from the
 * "SB_Global" table in 'row'.
 *
 */
void
sbrec_sb_global_update_ssl_delvalue(const struct sbrec_sb_global *row, const struct sbrec_ssl *delete_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->values);
    datum->values = NULL;

    datum->keys[0].uuid = delete_value->header_.uuid;

    ovsdb_idl_txn_delete_partial_set(&row->header_,
                                    &sbrec_sb_global_col_ssl,
                                    datum);
}

/* Sets the "connections" column from the "SB_Global" table in 'row' to
 * the 'connections' set with 'n_connections' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_add_clause_connections(struct ovsdb_idl_condition *cond, enum ovsdb_function function, struct uuid **connections, size_t n_connections)
{
    struct ovsdb_datum datum;
    datum.n = n_connections;
    datum.keys = n_connections ? xmalloc(n_connections * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (size_t i = 0; i < n_connections; i++) {
        datum.keys[i].uuid = *connections[i];
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_sb_global_col_connections,
                          &datum);
    free(datum.keys);
}

/* Sets the "external_ids" column's value from the "SB_Global" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_sb_global_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_sb_global_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_sb_global_col_external_ids.type);
}


/* Sets the "ipsec" column from the "SB_Global" table in 'row' to
 * 'ipsec'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_add_clause_ipsec(struct ovsdb_idl_condition *cond, enum ovsdb_function function, bool ipsec)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = ipsec;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_sb_global_col_ipsec,
                          &datum);
}

/* Sets the "nb_cfg" column from the "SB_Global" table in 'row' to
 * 'nb_cfg'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_add_clause_nb_cfg(struct ovsdb_idl_condition *cond, enum ovsdb_function function, int64_t nb_cfg)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.integer = nb_cfg;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_sb_global_col_nb_cfg,
                          &datum);
}

/* Sets the "options" column's value from the "SB_Global" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_sb_global_add_clause_options(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *options)
{
    struct ovsdb_datum datum;

    if (options) {
        ovsdb_datum_from_smap(&datum, options);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_sb_global_col_options,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_sb_global_col_options.type);
}


/* Sets the "ssl" column from the "SB_Global" table in 'row' to
 * the 'ssl' set.
 *
 * If "ssl" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_add_clause_ssl(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct uuid *ssl)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    if (ssl) {
        datum.n = 1;
        datum.keys = &key;
        key.uuid = *ssl;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_sb_global_col_ssl,
                          &datum);
}

/* Destroy 'row' of kind "SB_Global". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_sb_global_index_destroy_row(const struct sbrec_sb_global *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "SB_Global". */
struct sbrec_sb_global *
sbrec_sb_global_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_sb_global);
    return ALIGNED_CAST(struct sbrec_sb_global *, ovsdb_idl_index_init_row(index));
}

struct sbrec_sb_global *
sbrec_sb_global_index_find(struct ovsdb_idl_index *index, const struct sbrec_sb_global *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_sb_global);
    return sbrec_sb_global_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_sb_global_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_sb_global *a, 
    const struct sbrec_sb_global *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_sb_global_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_sb_global);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_sb_global_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_sb_global *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_sb_global);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_sb_global_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_sb_global *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_sb_global);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_sb_global *
sbrec_sb_global_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_sb_global_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "connections" column from the "SB_Global" table in 'row' to
 * the 'connections' set with 'n_connections' entries.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_index_set_connections(const struct sbrec_sb_global *row, struct sbrec_connection **connections, size_t n_connections)
{
    struct ovsdb_datum datum;
    size_t i;

    datum.n = n_connections;
    datum.keys = n_connections ? xmalloc(n_connections * sizeof *datum.keys) : NULL;
    datum.values = NULL;
    for (i = 0; i < n_connections; i++) {
        datum.keys[i].uuid = connections[i]->header_.uuid;
    }
    ovsdb_datum_sort_unique(&datum, OVSDB_TYPE_UUID, OVSDB_TYPE_VOID);
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_sb_global_columns[ SBREC_SB_GLOBAL_COL_CONNECTIONS ], &datum, &sbrec_table_classes[SBREC_TABLE_SB_GLOBAL]);
}

/* Sets the "external_ids" column's value from the "SB_Global" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_sb_global_index_set_external_ids(const struct sbrec_sb_global *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_sb_global_columns[SBREC_SB_GLOBAL_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_SB_GLOBAL]);
}


/* Sets the "ipsec" column from the "SB_Global" table in 'row' to
 * 'ipsec'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_index_set_ipsec(const struct sbrec_sb_global *row, bool ipsec)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->boolean = ipsec;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_sb_global_columns[ SBREC_SB_GLOBAL_COL_IPSEC ], &datum, &sbrec_table_classes[SBREC_TABLE_SB_GLOBAL]);
}

/* Sets the "nb_cfg" column from the "SB_Global" table in 'row' to
 * 'nb_cfg'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_index_set_nb_cfg(const struct sbrec_sb_global *row, int64_t nb_cfg)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->integer = nb_cfg;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_sb_global_columns[ SBREC_SB_GLOBAL_COL_NB_CFG ], &datum, &sbrec_table_classes[SBREC_TABLE_SB_GLOBAL]);
}

/* Sets the "options" column's value from the "SB_Global" table in 'row'
 * to 'options'.
 *
 * The caller retains ownership of 'options' and everything in it. */
void
sbrec_sb_global_index_set_options(const struct sbrec_sb_global *row, const struct smap *options)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (options) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(options);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, options) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_sb_global_columns[SBREC_SB_GLOBAL_COL_OPTIONS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_SB_GLOBAL]);
}


/* Sets the "ssl" column from the "SB_Global" table in 'row' to
 * the 'ssl' set.
 *
 * If "ssl" is null, the column will be the empty set,
 * otherwise it will contain the specified value.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_sb_global_index_set_ssl(const struct sbrec_sb_global *row, const struct sbrec_ssl *ssl)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof (union ovsdb_atom));

    if (ssl) {
        datum.n = 1;
        datum.keys = key;
        key->uuid = ssl->header_.uuid;
    } else {
        datum.n = 0;
        datum.keys = NULL;
    }
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_sb_global_columns[ SBREC_SB_GLOBAL_COL_SSL ], &datum, &sbrec_table_classes[SBREC_TABLE_SB_GLOBAL]);
}

struct ovsdb_idl_column sbrec_sb_global_columns[SBREC_SB_GLOBAL_N_COLUMNS];

void
sbrec_sb_global_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_sb_global, condition);
}

struct ovsdb_idl_column sbrec_sb_global_columns[SBREC_SB_GLOBAL_N_COLUMNS] = {
    [SBREC_SB_GLOBAL_COL_CONNECTIONS] = {
         .name = "connections",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "Connection", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_sb_global_parse_connections,
         .unparse = sbrec_sb_global_unparse_connections,
    },

    [SBREC_SB_GLOBAL_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_sb_global_parse_external_ids,
         .unparse = sbrec_sb_global_unparse_external_ids,
    },

    [SBREC_SB_GLOBAL_COL_IPSEC] = {
         .name = "ipsec",
         .type = {
            .key = {
               .type = OVSDB_TYPE_BOOLEAN,
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_sb_global_parse_ipsec,
         .unparse = sbrec_sb_global_unparse_ipsec,
    },

    [SBREC_SB_GLOBAL_COL_NB_CFG] = {
         .name = "nb_cfg",
         .type = {
            .key = {
               .type = OVSDB_TYPE_INTEGER,
               .integer = { .min = INT64_MIN, .max = INT64_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_sb_global_parse_nb_cfg,
         .unparse = sbrec_sb_global_unparse_nb_cfg,
    },

    [SBREC_SB_GLOBAL_COL_OPTIONS] = {
         .name = "options",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_sb_global_parse_options,
         .unparse = sbrec_sb_global_unparse_options,
    },

    [SBREC_SB_GLOBAL_COL_SSL] = {
         .name = "ssl",
         .type = {
            .key = {
               .type = OVSDB_TYPE_UUID,
               .uuid = { .refTableName = "SSL", .refType = OVSDB_REF_STRONG },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 0,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_sb_global_parse_ssl,
         .unparse = sbrec_sb_global_unparse_ssl,
    },

};

/* SSL table. */

const struct sbrec_ssl_table *
sbrec_ssl_table_get(const struct ovsdb_idl *idl)
{
    return (const struct sbrec_ssl_table *) idl;
}

const struct sbrec_ssl *
sbrec_ssl_table_first(const struct sbrec_ssl_table *table)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_ssl_first(idl);
}


const struct sbrec_ssl *
sbrec_ssl_table_track_get_first(const struct sbrec_ssl_table *table)
{
    const struct ovsdb_idl *idl =  (const struct ovsdb_idl *) table;
    return sbrec_ssl_track_get_first(idl);
}


static void
sbrec_ssl_parse_bootstrap_ca_cert(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_ssl *row = sbrec_ssl_cast(row_);

    if (datum->n >= 1) {
        row->bootstrap_ca_cert = datum->keys[0].boolean;
    } else {
        row->bootstrap_ca_cert = false;
    }
}

static void
sbrec_ssl_parse_ca_cert(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_ssl *row = sbrec_ssl_cast(row_);

    if (datum->n >= 1) {
        row->ca_cert = datum->keys[0].string;
    } else {
        row->ca_cert = "";
    }
}

static void
sbrec_ssl_parse_certificate(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_ssl *row = sbrec_ssl_cast(row_);

    if (datum->n >= 1) {
        row->certificate = datum->keys[0].string;
    } else {
        row->certificate = "";
    }
}

static void
sbrec_ssl_parse_external_ids(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_ssl *row = sbrec_ssl_cast(row_);
    smap_init(&row->external_ids);
    for (size_t i = 0; i < datum->n; i++) {
        smap_add(&row->external_ids,
                 datum->keys[i].string,
                 datum->values[i].string);
    }
}

static void
sbrec_ssl_parse_private_key(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_ssl *row = sbrec_ssl_cast(row_);

    if (datum->n >= 1) {
        row->private_key = datum->keys[0].string;
    } else {
        row->private_key = "";
    }
}

static void
sbrec_ssl_parse_ssl_ciphers(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_ssl *row = sbrec_ssl_cast(row_);

    if (datum->n >= 1) {
        row->ssl_ciphers = datum->keys[0].string;
    } else {
        row->ssl_ciphers = "";
    }
}

static void
sbrec_ssl_parse_ssl_protocols(struct ovsdb_idl_row *row_, const struct ovsdb_datum *datum)
{
    struct sbrec_ssl *row = sbrec_ssl_cast(row_);

    if (datum->n >= 1) {
        row->ssl_protocols = datum->keys[0].string;
    } else {
        row->ssl_protocols = "";
    }
}

static void
sbrec_ssl_unparse_bootstrap_ca_cert(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_ssl_unparse_ca_cert(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_ssl_unparse_certificate(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_ssl_unparse_external_ids(struct ovsdb_idl_row *row_)
{
    struct sbrec_ssl *row = sbrec_ssl_cast(row_);
    smap_destroy(&row->external_ids);
}

static void
sbrec_ssl_unparse_private_key(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_ssl_unparse_ssl_ciphers(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_ssl_unparse_ssl_protocols(struct ovsdb_idl_row *row OVS_UNUSED)
{
    /* Nothing to do. */
}

static void
sbrec_ssl_init__(struct ovsdb_idl_row *row)
{
    sbrec_ssl_init(sbrec_ssl_cast(row));
}

/* Clears the contents of 'row' in table "SSL". */
void
sbrec_ssl_init(struct sbrec_ssl *row)
{
    memset(row, 0, sizeof *row); 
    row->ca_cert = "";
    row->certificate = "";
    smap_init(&row->external_ids);
    row->private_key = "";
    row->ssl_ciphers = "";
    row->ssl_protocols = "";
}

/* Searches table "SSL" in 'idl' for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_ssl *
sbrec_ssl_get_for_uuid(const struct ovsdb_idl *idl, const struct uuid *uuid)
{
    return sbrec_ssl_cast(ovsdb_idl_get_row_for_uuid(idl, &sbrec_table_ssl, uuid));
}

/* Searches table "SSL" for a row with UUID 'uuid'.  Returns
 * a pointer to the row if there is one, otherwise a null pointer.  */
const struct sbrec_ssl *
sbrec_ssl_table_get_for_uuid(const struct sbrec_ssl_table *table, const struct uuid *uuid)
{
    const struct ovsdb_idl *idl = (const struct ovsdb_idl *) table;
    return sbrec_ssl_get_for_uuid(idl, uuid);
}

/* Returns a row in table "SSL" in 'idl', or a null pointer if that
 * table is empty.
 *
 * Database tables are internally maintained as hash tables, so adding or
 * removing rows while traversing the same table can cause some rows to be
 * visited twice or not at apply. */
const struct sbrec_ssl *
sbrec_ssl_first(const struct ovsdb_idl *idl)
{
    return sbrec_ssl_cast(ovsdb_idl_first_row(idl, &sbrec_table_ssl));
}

/* Returns a row following 'row' within its table, or a null pointer if 'row'
 * is the last row in its table. */
const struct sbrec_ssl *
sbrec_ssl_next(const struct sbrec_ssl *row)
{
    return sbrec_ssl_cast(ovsdb_idl_next_row(&row->header_));
}

unsigned int sbrec_ssl_get_seqno(const struct ovsdb_idl *idl)
{
    return ovsdb_idl_table_get_seqno(idl, &sbrec_table_ssl);
}

unsigned int sbrec_ssl_row_get_seqno(const struct sbrec_ssl *row, enum ovsdb_idl_change change)
{
    return ovsdb_idl_row_get_seqno(&row->header_, change);
}

const struct sbrec_ssl *
sbrec_ssl_track_get_first(const struct ovsdb_idl *idl)
{
    return sbrec_ssl_cast(ovsdb_idl_track_get_first(idl, &sbrec_table_ssl));
}

const struct sbrec_ssl
*sbrec_ssl_track_get_next(const struct sbrec_ssl *row)
{
    return sbrec_ssl_cast(ovsdb_idl_track_get_next(&row->header_));
}


/* Deletes 'row' from table "SSL".  'row' may be freed, so it must not be
 * accessed afterward.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_ssl_delete(const struct sbrec_ssl *row)
{
    ovsdb_idl_txn_delete(&row->header_);
}

/* Inserts and returns a new row in the table "SSL" in the database
 * with open transaction 'txn'.
 *
 * The new row is assigned a randomly generated provisional UUID.
 * ovsdb-server will assign a different UUID when 'txn' is committed,
 * but the IDL will replace any uses of the provisional UUID in the
 * data to be to be committed by the UUID assigned by ovsdb-server. */
struct sbrec_ssl *
sbrec_ssl_insert(struct ovsdb_idl_txn *txn)
{
    return sbrec_ssl_cast(ovsdb_idl_txn_insert(txn, &sbrec_table_ssl, NULL));
}

bool
sbrec_ssl_is_updated(const struct sbrec_ssl *row, enum sbrec_ssl_column_id column)
{
    return ovsdb_idl_track_is_updated(&row->header_, &sbrec_ssl_columns[column]);
}

/* Causes the original contents of column "bootstrap_ca_cert" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "bootstrap_ca_cert" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "bootstrap_ca_cert" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "bootstrap_ca_cert" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_ssl_insert()).
 *
 *   - If "bootstrap_ca_cert" has already been modified (with
 *     sbrec_ssl_set_bootstrap_ca_cert()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_ssl_set_bootstrap_ca_cert() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_ssl_verify_bootstrap_ca_cert(const struct sbrec_ssl *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_ssl_col_bootstrap_ca_cert);
}

/* Causes the original contents of column "ca_cert" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ca_cert" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ca_cert" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ca_cert" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_ssl_insert()).
 *
 *   - If "ca_cert" has already been modified (with
 *     sbrec_ssl_set_ca_cert()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_ssl_set_ca_cert() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_ssl_verify_ca_cert(const struct sbrec_ssl *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_ssl_col_ca_cert);
}

/* Causes the original contents of column "certificate" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "certificate" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "certificate" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "certificate" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_ssl_insert()).
 *
 *   - If "certificate" has already been modified (with
 *     sbrec_ssl_set_certificate()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_ssl_set_certificate() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_ssl_verify_certificate(const struct sbrec_ssl *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_ssl_col_certificate);
}

/* Causes the original contents of column "external_ids" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "external_ids" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "external_ids" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "external_ids" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_ssl_insert()).
 *
 *   - If "external_ids" has already been modified (with
 *     sbrec_ssl_set_external_ids()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_ssl_set_external_ids() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_ssl_verify_external_ids(const struct sbrec_ssl *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_ssl_col_external_ids);
}

/* Causes the original contents of column "private_key" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "private_key" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "private_key" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "private_key" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_ssl_insert()).
 *
 *   - If "private_key" has already been modified (with
 *     sbrec_ssl_set_private_key()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_ssl_set_private_key() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_ssl_verify_private_key(const struct sbrec_ssl *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_ssl_col_private_key);
}

/* Causes the original contents of column "ssl_ciphers" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ssl_ciphers" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ssl_ciphers" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ssl_ciphers" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_ssl_insert()).
 *
 *   - If "ssl_ciphers" has already been modified (with
 *     sbrec_ssl_set_ssl_ciphers()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_ssl_set_ssl_ciphers() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_ssl_verify_ssl_ciphers(const struct sbrec_ssl *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_ssl_col_ssl_ciphers);
}

/* Causes the original contents of column "ssl_protocols" in 'row' to be
 * verified as a prerequisite to completing the transaction.  That is, if
 * "ssl_protocols" in 'row' changed (or if 'row' was deleted) between the
 * time that the IDL originally read its contents and the time that the
 * transaction aborts and ovsdb_idl_txn_commit() returns TXN_TRY_AGAIN.
 *
 * The intention is that, to ensure that no transaction commits based on dirty
 * reads, an application should call this function any time "ssl_protocols" is
 * read as part of a read-modify-write operation.
 *
 * In some cases this function reduces to a no-op, because the current value
 * of "ssl_protocols" is already known:
 *
 *   - If 'row' is a row created by the current transaction (returned by
 *     sbrec_ssl_insert()).
 *
 *   - If "ssl_protocols" has already been modified (with
 *     sbrec_ssl_set_ssl_protocols()) within the current transaction.
 *
 * Because of the latter property, always call this function *before*
 * sbrec_ssl_set_ssl_protocols() for a given read-modify-write.
 *
 * The caller must have started a transaction with ovsdb_idl_txn_create(). */
void
sbrec_ssl_verify_ssl_protocols(const struct sbrec_ssl *row)
{
    ovsdb_idl_txn_verify(&row->header_, &sbrec_ssl_col_ssl_protocols);
}

/* Returns the "bootstrap_ca_cert" column's value from the "SSL" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_BOOLEAN.
 * (This helps to avoid silent bugs if someone changes bootstrap_ca_cert's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "bootstrap_ca_cert" member in sbrec_ssl. */
const struct ovsdb_datum *
sbrec_ssl_get_bootstrap_ca_cert(const struct sbrec_ssl *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_BOOLEAN);
    return ovsdb_idl_read(&row->header_, &sbrec_ssl_col_bootstrap_ca_cert);
}

/* Returns the "ca_cert" column's value from the "SSL" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes ca_cert's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ca_cert" member in sbrec_ssl. */
const struct ovsdb_datum *
sbrec_ssl_get_ca_cert(const struct sbrec_ssl *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_ssl_col_ca_cert);
}

/* Returns the "certificate" column's value from the "SSL" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes certificate's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "certificate" member in sbrec_ssl. */
const struct ovsdb_datum *
sbrec_ssl_get_certificate(const struct sbrec_ssl *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_ssl_col_certificate);
}

/* Returns the "external_ids" column's value from the "SSL" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * 'value_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes external_ids's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "external_ids" member in sbrec_ssl. */
const struct ovsdb_datum *
sbrec_ssl_get_external_ids(const struct sbrec_ssl *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED,
    enum ovsdb_atomic_type value_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    ovs_assert(value_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_ssl_col_external_ids);
}

/* Returns the "private_key" column's value from the "SSL" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes private_key's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "private_key" member in sbrec_ssl. */
const struct ovsdb_datum *
sbrec_ssl_get_private_key(const struct sbrec_ssl *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_ssl_col_private_key);
}

/* Returns the "ssl_ciphers" column's value from the "SSL" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes ssl_ciphers's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ssl_ciphers" member in sbrec_ssl. */
const struct ovsdb_datum *
sbrec_ssl_get_ssl_ciphers(const struct sbrec_ssl *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_ssl_col_ssl_ciphers);
}

/* Returns the "ssl_protocols" column's value from the "SSL" table in 'row'
 * as a struct ovsdb_datum.  This is useful occasionally: for example,
 * ovsdb_datum_find_key() is an easier and more efficient way to search
 * for a given key than implementing the same operation on the "cooked"
 * form in 'row'.
 *
 * 'key_type' must be OVSDB_TYPE_STRING.
 * (This helps to avoid silent bugs if someone changes ssl_protocols's
 * type without updating the caller.)
 *
 * The caller must not modify or free the returned value.
 *
 * Various kinds of changes can invalidate the returned value: modifying
 * 'column' within 'row', deleting 'row', or completing an ongoing transaction.
 * If the returned value is needed for a long time, it is best to make a copy
 * of it with ovsdb_datum_clone().
 *
 * This function is rarely useful, since it is easier to access the value
 * directly through the "ssl_protocols" member in sbrec_ssl. */
const struct ovsdb_datum *
sbrec_ssl_get_ssl_protocols(const struct sbrec_ssl *row,
    enum ovsdb_atomic_type key_type OVS_UNUSED)
{
    ovs_assert(key_type == OVSDB_TYPE_STRING);
    return ovsdb_idl_read(&row->header_, &sbrec_ssl_col_ssl_protocols);
}

/* Sets the "bootstrap_ca_cert" column from the "SSL" table in 'row' to
 * 'bootstrap_ca_cert'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_set_bootstrap_ca_cert(const struct sbrec_ssl *row, bool bootstrap_ca_cert)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = bootstrap_ca_cert;
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_ssl_col_bootstrap_ca_cert, &datum);
}

/* Sets the "ca_cert" column from the "SSL" table in 'row' to
 * 'ca_cert'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_set_ca_cert(const struct sbrec_ssl *row, const char *ca_cert)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ca_cert);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_ssl_col_ca_cert, &datum);
}

/* Sets the "certificate" column from the "SSL" table in 'row' to
 * 'certificate'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_set_certificate(const struct sbrec_ssl *row, const char *certificate)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, certificate);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_ssl_col_certificate, &datum);
}

/* Sets the "external_ids" column's value from the "SSL" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_ssl_set_external_ids(const struct sbrec_ssl *row, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }
    ovsdb_idl_txn_write(&row->header_,
                        &sbrec_ssl_col_external_ids,
                        &datum);
}


/* Sets the "private_key" column from the "SSL" table in 'row' to
 * 'private_key'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_set_private_key(const struct sbrec_ssl *row, const char *private_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, private_key);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_ssl_col_private_key, &datum);
}

/* Sets the "ssl_ciphers" column from the "SSL" table in 'row' to
 * 'ssl_ciphers'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_set_ssl_ciphers(const struct sbrec_ssl *row, const char *ssl_ciphers)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ssl_ciphers);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_ssl_col_ssl_ciphers, &datum);
}

/* Sets the "ssl_protocols" column from the "SSL" table in 'row' to
 * 'ssl_protocols'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_set_ssl_protocols(const struct sbrec_ssl *row, const char *ssl_protocols)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ssl_protocols);
    datum.values = NULL;
    ovsdb_idl_txn_write_clone(&row->header_, &sbrec_ssl_col_ssl_protocols, &datum);
}

/* Sets an element of the "external_ids" map column from the "SSL" table in 'row'
 * to 'new_value' given the key value 'new_key'.
 *
 */
void
sbrec_ssl_update_external_ids_setkey(const struct sbrec_ssl *row, const char *new_key, const char *new_value)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = xmalloc(datum->n * sizeof *datum->values);

    datum->keys[0].string = xstrdup(new_key);
    datum->values[0].string = xstrdup(new_value);

    ovsdb_idl_txn_write_partial_map(&row->header_,
                                    &sbrec_ssl_col_external_ids,
                                    datum);
}

/* Deletes an element of the "external_ids" map column from the "SSL" table in 'row'
 * given the key value 'delete_key'.
 *
 */
void
sbrec_ssl_update_external_ids_delkey(const struct sbrec_ssl *row, const char *delete_key)
{
    struct ovsdb_datum *datum;

    datum = xmalloc(sizeof *datum);
    datum->n = 1;
    datum->keys = xmalloc(datum->n * sizeof *datum->keys);
    datum->values = NULL;

    datum->keys[0].string = xstrdup(delete_key);

    ovsdb_idl_txn_delete_partial_map(&row->header_,
                                    &sbrec_ssl_col_external_ids,
                                    datum);
}

/* Sets the "bootstrap_ca_cert" column from the "SSL" table in 'row' to
 * 'bootstrap_ca_cert'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_add_clause_bootstrap_ca_cert(struct ovsdb_idl_condition *cond, enum ovsdb_function function, bool bootstrap_ca_cert)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.boolean = bootstrap_ca_cert;
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_ssl_col_bootstrap_ca_cert,
                          &datum);
}

/* Sets the "ca_cert" column from the "SSL" table in 'row' to
 * 'ca_cert'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_add_clause_ca_cert(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *ca_cert)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ca_cert);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_ssl_col_ca_cert,
                          &datum);
}

/* Sets the "certificate" column from the "SSL" table in 'row' to
 * 'certificate'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_add_clause_certificate(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *certificate)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, certificate);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_ssl_col_certificate,
                          &datum);
}

/* Sets the "external_ids" column's value from the "SSL" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_ssl_add_clause_external_ids(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const struct smap *external_ids)
{
    struct ovsdb_datum datum;

    if (external_ids) {
        ovsdb_datum_from_smap(&datum, external_ids);
    } else {
        ovsdb_datum_init_empty(&datum);
    }

    ovsdb_idl_condition_add_clause(cond,
                                   function,
                                   &sbrec_ssl_col_external_ids,
                                   &datum);

    ovsdb_datum_destroy(&datum, &sbrec_ssl_col_external_ids.type);
}


/* Sets the "private_key" column from the "SSL" table in 'row' to
 * 'private_key'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_add_clause_private_key(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *private_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, private_key);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_ssl_col_private_key,
                          &datum);
}

/* Sets the "ssl_ciphers" column from the "SSL" table in 'row' to
 * 'ssl_ciphers'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_add_clause_ssl_ciphers(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *ssl_ciphers)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ssl_ciphers);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_ssl_col_ssl_ciphers,
                          &datum);
}

/* Sets the "ssl_protocols" column from the "SSL" table in 'row' to
 * 'ssl_protocols'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_add_clause_ssl_protocols(struct ovsdb_idl_condition *cond, enum ovsdb_function function, const char *ssl_protocols)
{
    struct ovsdb_datum datum;
    union ovsdb_atom key;

    datum.n = 1;
    datum.keys = &key;
    key.string = CONST_CAST(char *, ssl_protocols);
    datum.values = NULL;
    ovsdb_idl_condition_add_clause(cond,
                          function,
                          &sbrec_ssl_col_ssl_protocols,
                          &datum);
}

/* Destroy 'row' of kind "SSL". The row must have been
 * created with ovsdb_idl_index_init_row.
 */
void
sbrec_ssl_index_destroy_row(const struct sbrec_ssl *row)
{
    ovsdb_idl_index_destroy_row(&row->header_);
}
        

/* Creates a new row of kind "SSL". */
struct sbrec_ssl *
sbrec_ssl_index_init_row(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_ssl);
    return ALIGNED_CAST(struct sbrec_ssl *, ovsdb_idl_index_init_row(index));
}

struct sbrec_ssl *
sbrec_ssl_index_find(struct ovsdb_idl_index *index, const struct sbrec_ssl *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_ssl);
    return sbrec_ssl_cast(ovsdb_idl_index_find(index, &target->header_));
}

/* Compares 'a' to 'b' and returns a strcmp()-type result. */
int
sbrec_ssl_index_compare(
    struct ovsdb_idl_index *index, 
    const struct sbrec_ssl *a, 
    const struct sbrec_ssl *b)
{
    return ovsdb_idl_index_compare(index, &a->header_, &b->header_);
}

struct ovsdb_idl_cursor
sbrec_ssl_cursor_first(struct ovsdb_idl_index *index)
{
    ovs_assert(index->table->class_ == &sbrec_table_ssl);
    return ovsdb_idl_cursor_first(index);
}

struct ovsdb_idl_cursor
sbrec_ssl_cursor_first_eq(
    struct ovsdb_idl_index *index, const struct sbrec_ssl *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_ssl);
    return ovsdb_idl_cursor_first_eq(index, &target->header_);
}

struct ovsdb_idl_cursor
sbrec_ssl_cursor_first_ge(
    struct ovsdb_idl_index *index, const struct sbrec_ssl *target)
{
    ovs_assert(index->table->class_ == &sbrec_table_ssl);
    return ovsdb_idl_cursor_first_ge(index, &target->header_);
}

struct sbrec_ssl *
sbrec_ssl_cursor_data(struct ovsdb_idl_cursor *cursor)
{
    return sbrec_ssl_cast(ovsdb_idl_cursor_data(cursor));
}


/* Sets the "bootstrap_ca_cert" column from the "SSL" table in 'row' to
 * 'bootstrap_ca_cert'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_index_set_bootstrap_ca_cert(const struct sbrec_ssl *row, bool bootstrap_ca_cert)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->boolean = bootstrap_ca_cert;
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_ssl_columns[ SBREC_SSL_COL_BOOTSTRAP_CA_CERT ], &datum, &sbrec_table_classes[SBREC_TABLE_SSL]);
}

/* Sets the "ca_cert" column from the "SSL" table in 'row' to
 * 'ca_cert'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_index_set_ca_cert(const struct sbrec_ssl *row, const char *ca_cert)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, ca_cert);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_ssl_columns[ SBREC_SSL_COL_CA_CERT ], &datum, &sbrec_table_classes[SBREC_TABLE_SSL]);
}

/* Sets the "certificate" column from the "SSL" table in 'row' to
 * 'certificate'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_index_set_certificate(const struct sbrec_ssl *row, const char *certificate)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, certificate);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_ssl_columns[ SBREC_SSL_COL_CERTIFICATE ], &datum, &sbrec_table_classes[SBREC_TABLE_SSL]);
}

/* Sets the "external_ids" column's value from the "SSL" table in 'row'
 * to 'external_ids'.
 *
 * The caller retains ownership of 'external_ids' and everything in it. */
void
sbrec_ssl_index_set_external_ids(const struct sbrec_ssl *row, const struct smap *external_ids)
{
    struct ovsdb_datum *datum = xmalloc(sizeof(struct ovsdb_datum));

    if (external_ids) {
        struct smap_node *node;
        size_t i;

        datum->n = smap_count(external_ids);
        datum->keys = xmalloc(datum->n * sizeof *datum->keys);
        datum->values = xmalloc(datum->n * sizeof *datum->values);

        i = 0;
        SMAP_FOR_EACH (node, external_ids) {
            datum->keys[i].string = node->key;
            datum->values[i].string = node->value;
            i++;
        }
        ovsdb_datum_sort_unique(datum, OVSDB_TYPE_STRING, OVSDB_TYPE_STRING);
    } else {
        ovsdb_datum_init_empty(datum);
    }
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_),
                          &sbrec_ssl_columns[SBREC_SSL_COL_EXTERNAL_IDS],
                          datum,
                          &sbrec_table_classes[SBREC_TABLE_SSL]);
}


/* Sets the "private_key" column from the "SSL" table in 'row' to
 * 'private_key'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_index_set_private_key(const struct sbrec_ssl *row, const char *private_key)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, private_key);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_ssl_columns[ SBREC_SSL_COL_PRIVATE_KEY ], &datum, &sbrec_table_classes[SBREC_TABLE_SSL]);
}

/* Sets the "ssl_ciphers" column from the "SSL" table in 'row' to
 * 'ssl_ciphers'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_index_set_ssl_ciphers(const struct sbrec_ssl *row, const char *ssl_ciphers)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, ssl_ciphers);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_ssl_columns[ SBREC_SSL_COL_SSL_CIPHERS ], &datum, &sbrec_table_classes[SBREC_TABLE_SSL]);
}

/* Sets the "ssl_protocols" column from the "SSL" table in 'row' to
 * 'ssl_protocols'.
 *
 * The caller retains ownership of the arguments. */
void
sbrec_ssl_index_set_ssl_protocols(const struct sbrec_ssl *row, const char *ssl_protocols)
{
    struct ovsdb_datum datum;
    union ovsdb_atom *key = xmalloc(sizeof(union ovsdb_atom));

    datum.n = 1;
    datum.keys = key;
    key->string = CONST_CAST(char *, ssl_protocols);
    datum.values = NULL;
    ovsdb_idl_index_write(CONST_CAST(struct ovsdb_idl_row *, &row->header_), &sbrec_ssl_columns[ SBREC_SSL_COL_SSL_PROTOCOLS ], &datum, &sbrec_table_classes[SBREC_TABLE_SSL]);
}

struct ovsdb_idl_column sbrec_ssl_columns[SBREC_SSL_N_COLUMNS];

void
sbrec_ssl_set_condition(struct ovsdb_idl *idl, struct ovsdb_idl_condition *condition)
{
    ovsdb_idl_set_condition(idl, &sbrec_table_ssl, condition);
}

struct ovsdb_idl_column sbrec_ssl_columns[SBREC_SSL_N_COLUMNS] = {
    [SBREC_SSL_COL_BOOTSTRAP_CA_CERT] = {
         .name = "bootstrap_ca_cert",
         .type = {
            .key = {
               .type = OVSDB_TYPE_BOOLEAN,
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_ssl_parse_bootstrap_ca_cert,
         .unparse = sbrec_ssl_unparse_bootstrap_ca_cert,
    },

    [SBREC_SSL_COL_CA_CERT] = {
         .name = "ca_cert",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_ssl_parse_ca_cert,
         .unparse = sbrec_ssl_unparse_ca_cert,
    },

    [SBREC_SSL_COL_CERTIFICATE] = {
         .name = "certificate",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_ssl_parse_certificate,
         .unparse = sbrec_ssl_unparse_certificate,
    },

    [SBREC_SSL_COL_EXTERNAL_IDS] = {
         .name = "external_ids",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = {
                .type = OVSDB_TYPE_STRING,
                .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .n_min = 0,
            .n_max = UINT_MAX,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_ssl_parse_external_ids,
         .unparse = sbrec_ssl_unparse_external_ids,
    },

    [SBREC_SSL_COL_PRIVATE_KEY] = {
         .name = "private_key",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_ssl_parse_private_key,
         .unparse = sbrec_ssl_unparse_private_key,
    },

    [SBREC_SSL_COL_SSL_CIPHERS] = {
         .name = "ssl_ciphers",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_ssl_parse_ssl_ciphers,
         .unparse = sbrec_ssl_unparse_ssl_ciphers,
    },

    [SBREC_SSL_COL_SSL_PROTOCOLS] = {
         .name = "ssl_protocols",
         .type = {
            .key = {
               .type = OVSDB_TYPE_STRING,
               .string = { .minLen = 0, .maxLen = UINT_MAX },
            },
            .value = OVSDB_BASE_VOID_INIT,
            .n_min = 1,
            .n_max = 1,
         },
         .is_mutable = true,
         .is_synthetic = false,
         .parse = sbrec_ssl_parse_ssl_protocols,
         .unparse = sbrec_ssl_unparse_ssl_protocols,
    },

};

struct ovsdb_idl_table_class sbrec_table_classes[SBREC_N_TABLES] = {
    {"Address_Set", true, false,
     sbrec_address_set_columns, ARRAY_SIZE(sbrec_address_set_columns),
     sizeof(struct sbrec_address_set), sbrec_address_set_init__},
    {"Chassis", true, false,
     sbrec_chassis_columns, ARRAY_SIZE(sbrec_chassis_columns),
     sizeof(struct sbrec_chassis), sbrec_chassis_init__},
    {"Connection", false, false,
     sbrec_connection_columns, ARRAY_SIZE(sbrec_connection_columns),
     sizeof(struct sbrec_connection), sbrec_connection_init__},
    {"DHCP_Options", true, false,
     sbrec_dhcp_options_columns, ARRAY_SIZE(sbrec_dhcp_options_columns),
     sizeof(struct sbrec_dhcp_options), sbrec_dhcp_options_init__},
    {"DHCPv6_Options", true, false,
     sbrec_dhcpv6_options_columns, ARRAY_SIZE(sbrec_dhcpv6_options_columns),
     sizeof(struct sbrec_dhcpv6_options), sbrec_dhcpv6_options_init__},
    {"DNS", true, false,
     sbrec_dns_columns, ARRAY_SIZE(sbrec_dns_columns),
     sizeof(struct sbrec_dns), sbrec_dns_init__},
    {"Datapath_Binding", true, false,
     sbrec_datapath_binding_columns, ARRAY_SIZE(sbrec_datapath_binding_columns),
     sizeof(struct sbrec_datapath_binding), sbrec_datapath_binding_init__},
    {"Encap", false, false,
     sbrec_encap_columns, ARRAY_SIZE(sbrec_encap_columns),
     sizeof(struct sbrec_encap), sbrec_encap_init__},
    {"Gateway_Chassis", false, false,
     sbrec_gateway_chassis_columns, ARRAY_SIZE(sbrec_gateway_chassis_columns),
     sizeof(struct sbrec_gateway_chassis), sbrec_gateway_chassis_init__},
    {"Logical_Flow", true, false,
     sbrec_logical_flow_columns, ARRAY_SIZE(sbrec_logical_flow_columns),
     sizeof(struct sbrec_logical_flow), sbrec_logical_flow_init__},
    {"MAC_Binding", true, false,
     sbrec_mac_binding_columns, ARRAY_SIZE(sbrec_mac_binding_columns),
     sizeof(struct sbrec_mac_binding), sbrec_mac_binding_init__},
    {"Meter", true, false,
     sbrec_meter_columns, ARRAY_SIZE(sbrec_meter_columns),
     sizeof(struct sbrec_meter), sbrec_meter_init__},
    {"Meter_Band", false, false,
     sbrec_meter_band_columns, ARRAY_SIZE(sbrec_meter_band_columns),
     sizeof(struct sbrec_meter_band), sbrec_meter_band_init__},
    {"Multicast_Group", true, false,
     sbrec_multicast_group_columns, ARRAY_SIZE(sbrec_multicast_group_columns),
     sizeof(struct sbrec_multicast_group), sbrec_multicast_group_init__},
    {"Port_Binding", true, false,
     sbrec_port_binding_columns, ARRAY_SIZE(sbrec_port_binding_columns),
     sizeof(struct sbrec_port_binding), sbrec_port_binding_init__},
    {"Port_Group", true, false,
     sbrec_port_group_columns, ARRAY_SIZE(sbrec_port_group_columns),
     sizeof(struct sbrec_port_group), sbrec_port_group_init__},
    {"RBAC_Permission", true, false,
     sbrec_rbac_permission_columns, ARRAY_SIZE(sbrec_rbac_permission_columns),
     sizeof(struct sbrec_rbac_permission), sbrec_rbac_permission_init__},
    {"RBAC_Role", true, false,
     sbrec_rbac_role_columns, ARRAY_SIZE(sbrec_rbac_role_columns),
     sizeof(struct sbrec_rbac_role), sbrec_rbac_role_init__},
    {"SB_Global", true, true,
     sbrec_sb_global_columns, ARRAY_SIZE(sbrec_sb_global_columns),
     sizeof(struct sbrec_sb_global), sbrec_sb_global_init__},
    {"SSL", false, true,
     sbrec_ssl_columns, ARRAY_SIZE(sbrec_ssl_columns),
     sizeof(struct sbrec_ssl), sbrec_ssl_init__},
};

struct ovsdb_idl_class sbrec_idl_class = {
    "OVN_Southbound", sbrec_table_classes, ARRAY_SIZE(sbrec_table_classes)
};

/* Return the schema version.  The caller must not free the returned value. */
const char *
sbrec_get_db_version(void)
{
    return "2.1.0";
}
    """)

def ovsdb_escape(string):
    def escape(match):
        c = match.group(0)
        if c == '\0':
            raise ovs.db.error.Error("strings may not contain null bytes")
        elif c == '\\':
            return '\\\\'
        elif c == '\n':
            return '\\n'
        elif c == '\r':
            return '\\r'
        elif c == '\t':
            return '\\t'
        elif c == '\b':
            return '\\b'
        elif c == '\a':
            return '\\a'
        else:
            return '\\x%02x' % ord(c)
    return re.sub(r'["\\\000-\037]', escape, string)

def usage():
    print("""\
%(argv0)s: ovsdb schema compiler
usage: %(argv0)s [OPTIONS] COMMAND ARG...

The following commands are supported:
  annotate SCHEMA ANNOTATIONS print SCHEMA combined with ANNOTATIONS
  c-idl-header IDL            print C header file for IDL
  c-idl-source IDL            print C source file for IDL implementation

The following options are also available:
  -h, --help                  display this help message
  -V, --version               display version information\
""" % {'argv0': argv0})
    sys.exit(0)

if __name__ == "__main__":
    try:
        try:
            options, args = getopt.gnu_getopt(sys.argv[1:], 'C:hV',
                                              ['directory',
                                               'help',
                                               'version'])
        except getopt.GetoptError as geo:
            sys.stderr.write("%s: %s\n" % (argv0, geo.msg))
            sys.exit(1)

        for key, value in options:
            if key in ['-h', '--help']:
                usage()
            elif key in ['-V', '--version']:
                print("ovsdb-idlc (Open vSwitch) @VERSION@")
            elif key in ['-C', '--directory']:
                os.chdir(value)
            else:
                sys.exit(0)

        optKeys = [key for key, value in options]

        if not args:
            sys.stderr.write("%s: missing command argument "
                             "(use --help for help)\n" % argv0)
            sys.exit(1)

        commands = {"annotate": (annotateSchema, 2),
                    "c-idl-header": (printCIDLHeader, 1),
                    "c-idl-source": (printCIDLSource, 1)}

        if not args[0] in commands:
            sys.stderr.write("%s: unknown command \"%s\" "
                             "(use --help for help)\n" % (argv0, args[0]))
            sys.exit(1)

        func, n_args = commands[args[0]]
        if len(args) - 1 != n_args:
            sys.stderr.write("%s: \"%s\" requires %d arguments but %d "
                             "provided\n"
                             % (argv0, args[0], n_args, len(args) - 1))
            sys.exit(1)

        # Salam
        if args[1] == "ovn/lib/ovn-sb-idl.ovsidl":
            if args[0] == "c-idl-header":
                print_ovn_sb_idlh()
            elif args[0] == "c-idl-source":
                print_ovn_sb_idlc()
            else:
                func(*args[1:])
        else:
            func(*args[1:])
    except ovs.db.error.Error as e:
        sys.stderr.write("%s: %s\n" % (argv0, e))
        sys.exit(1)

# Local variables:
# mode: python
# End:
